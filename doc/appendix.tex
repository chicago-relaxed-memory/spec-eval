\subsection{Operations on sets of pomsets}
\label{app:sets-of-pomsets}

Here we give the formal definitions for the operations described at the
beginning of \S\ref{sec:semantics}.

In transactional memory, begin and commit actions are memory fences: that is,
they are a barrier to reordering memory accesses.  To capture this (and other
memory barriers), we identify sets $\Rel$ and $\Acq \subseteq\Act$.  For
transactions, we have $(\DB{\aVal})\in\Acq$ for begins,
$(\DC{\aVal})\in \Rel$ for commits.  We say that $\aAct$ is a \emph{release}
if $\aAct\in\Rel$ and $\aAct$ is an \emph{acquire} if $\aAct\in\Acq$.
% In a pomset, a release event is one
% labelled with a release action, and an acquire event is one labelled by an
% acquire action.  

\begin{definition}
  \label{def:prefix}
Let $\aAct \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{\cEv\}$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item if $\bEv \ltN \aEv$ then $\bEv \ltN' \aEv$,
\item $\labelling'(\cEv) = (\aForm, \aAct)$, and
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then $\labelling'(\aEv) =
  (\bForm' \mid \bAct)$, where:
  \begin{itemize}
  \item $\cEv <' \aEv$ whenever $\aAct$ is an acquire or $\bAct$ is a release, 
  \item if $\aAct$ is an acquire then $\bForm'$ is independent of every $\bLoc$,
  \item if $\aAct$ and $\bAct$ both write to some $\bLoc$,
    then $\cEv \gtN' \aEv$, and
  \item $\bForm'$ implies \(\left\{\begin{array}{l@{~}ll}
    % \bForm[\aVal/\aLoc]                     & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$} & \textsc{[dependent read]} \\
    % \bForm[\aVal/\aLoc] \text{ and } \bForm & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  & \textsc{[independent read]} \\
    % \bForm                                  & \mbox{otherwise}                                              & \textsc{[non-read]} \\        
    \bForm[\aVal/\aLoc]                     \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$} \\\qquad \textsc{[dependent read]} \\[\jot]
    \bForm[\aVal/\aLoc] \text{ and } \bForm \\\quad \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  \\\qquad \textsc{[independent read]} \\[\jot]
    \bForm                                  \\\quad \mbox{otherwise}                                              \\\qquad \textsc{[non-read]} \\
  \end{array}\right.\)
  \end{itemize}
\end{itemize}
\end{definition}
The first constraint ensures that events are ordered before a release and
after an acquire.  The second constraint ensures that thread-local reads do
not cross acquire fences.

% Prefixing is used to define the semantics of reads and writes, and
% adds a new event $\cEv$ with action $\aAct$.  As in the definition
% of parallel composition, the definition allows the new event to overlap with
% events in $\aPSS$ as long as they agree on the action.

The tricky parts of the
definition are the named cases, which place requirements on read
dependencies.  If $\aAct$ reads $\aVal$ from $\aLoc$, we have to
decide whether $\aEv$ depends on $\cEv$ for some $\aEv$ with old
precondition $\bForm$ and new precondition $\bForm'$. The first case
\textsc{[dependent read]} is that the dependency exists, in which case
$\bForm'$ just has to imply $\bForm[\aVal/\aLoc]$. The more interesting 
case is \textsc{[independent read]}, in which case $\bForm'$ has to imply
$\bForm[\aVal/\aLoc]$ and $\bForm$. This corresponds to a case where
$\aEv$ can be performed with or without $\cEv$.
In particular, if $\bForm$ is independent of $\aLoc$ then we can pick
$\bForm'$ to be $\bForm$, and the independent read case will apply.
For example,
if $\aAct$ and $\bAct$ write to the same location, $\aAct$ reads $\aVal$ from $\aLoc$, $\bForm$ is independent of $\aLoc$,
and
$\aPSS$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{b}{c}
\end{tikzpicture}\]
then $\aAct\prefix\aPSS$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm \mid \bAct}{right=of a}
  \event{c}{\cForm[\vec\aVal/\vec\aLoc] \mid \cAct}{right=of b}
  \po[out=25,in=155]{a}{c}
  \wk{a}{b}
  \po{b}{c}
\end{tikzpicture}\]


\begin{definition}
Let $\aPS_0 \in (\aPSS_1 \parallel \aPSS_2)$
whenever there are $\aPS_1 \in \aPSS_1$ and $\aPS_2 \in \aPSS_2$ such that:
\begin{itemize}
\item $\Event_0 = \Event_1 \cup \Event_2$,
\item if $\aEv \le_1 \bEv$ or $\aEv \le_2 \bEv$ then $\aEv \le_0 \bEv$,
\item if $\aEv \ltN_1 \bEv$ or $\aEv \ltN_2 \bEv$ then $\aEv \ltN_0 \bEv$,
\item if $\labelling_0(\aEv) = (\aForm_0 \mid \aAct)$ then either:
  \begin{itemize}
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$
    and $\aForm_0$ implies $\aForm_1 \lor \aForm_2$,
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\aEv \not\in \Event_2$
    and $\aForm_0$ implies $\aForm_1$, or
  \item $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$ and $\aEv \not\in \Event_1$
    and $\aForm_0$ implies $\aForm_2$.
  \end{itemize}
\end{itemize}
\end{definition}
% We use $\aPSS_1 \parallel \aPSS_2$ in defining the semantics of conditionals
% and concurrency.
% It contains the union of pomsets from $\aPSS_1$ and $\aPSS_2$,
% allowing overlap as long as they agree on actions. For example, if
% $\aPSS_1$ and $\aPSS_2$ contain:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm_1 \mid \bAct}{right=of a}
%   \po{a}{b}
% \end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
%   \event{b}{\bForm_2 \mid \bAct}{}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \wk{b}{c}
% \end{tikzpicture}\]
% then $\aPSS_1 \parallel \aPSS_2$ contains:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{a}{\aForm \mid \aAct}{}
%   \event{b}{\bForm_1 \lor \bForm_2 \mid \bAct}{right=of a}
%   \event{c}{\cForm \mid \cAct}{right=of b}
%   \po{a}{b}
%   \wk{b}{c}
% \end{tikzpicture}\]

\begin{definition}
Let $\aPSS[\aExp/\aLoc]$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$, and
\item if $\bEv \ltN \aEv$ then $\bEv \ltN' \aEv$, and
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) = (\bForm[\aExp/\aLoc] \mid \aAct)$.
\end{itemize}
and similarly for $\aPSS[\aLoc/\aReg]$.
\end{definition}

\begin{definition}
Let $(\aForm \guard \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever:
\begin{itemize}
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\aForm$ implies $\bForm$.
\end{itemize}
\end{definition}



\begin{definition}
\label{def:x-closed}
  A 3-valued pomset is $\aLoc$-closed if,
  for every $\aEv\in\Event$:
  \begin{itemize}
  \item $\aEv$ is independent of $\aLoc$, and
  \item if $\aEv$ reads from $\aLoc$, then there is a $\bEv$ such that $\aEv$ can read $\aLoc$ from $\bEv$.
  \end{itemize}
\end{definition}

The definitions as they stand allow cycles in weak edges. This is necessary for examples such
as $(\aLoc\GETS\bLoc-1\SEMI \aLoc\GETS1 \PAR \bLoc\GETS\aLoc-1\SEMI\bLoc\GETS1)$
which has execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx0}{\DW{\aLoc}{0}}{right=of ry1}
  \event{wx1}{\DW{\aLoc}{1}}{right=of wx0}
  \event{rx1}{\DR{\aLoc}{1}}{right=2.5em of wx1}
  \event{wy0}{\DW{\bLoc}{0}}{right=of rx1}
  \event{wy1}{\DW{\bLoc}{1}}{right=of wy0}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \po{ry1}{wx0}
  \po{rx1}{wy0}
  \rf{wx1}{rx1}
  \rf[in=20,out=160]{wy1}{ry1}
\end{tikzpicture}\]
However, in order to model release/acquire fencing in transactions, we need to ban
executions such as:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{\aLoc}{0}}{}
  \event{wx1}{\DW{\aLoc}{1}}{below=7ex of wx0}
  \event{wy1}{\DC{}}{below right=of wx0}
  \event{ry1}{\DB{}}{right=2.5em of wy1}
  % \event{wy1}{\DWRel{\bLoc}{1}}{below right=of wx0}
  % \event{ry1}{\DRAcq{\bLoc}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{\aLoc}{0}}{above right=of ry1}
  \event{rx1}{\DR{\aLoc}{1}}{below=7ex of rx0}
  \wk[out=-75,in=75]{wx0}{wx1}
  \wk[out=105,in=-105]{wx1}{wx0}
  \po{wx0}{wy1}
  \po{wx1}{wy1}
  \po{ry1}{rx0}
  \po{ry1}{rx1}
  \rf{wy1}{ry1}
  \rf{wx0}{rx0}
  \rf{wx1}{rx1}
\end{tikzpicture}\]
The problem here is the weak cycle between $(\DW\aLoc0)$ and $(\DW\aLoc1)$,
which according to Definition~\ref{def:rf}, allows both $(\DR\aLoc0)$ and
$(\DR\aLoc1)$, even though one of them must be a stale value. This can be addressed by
requiring $\ltN$ to form a \emph{per-location} partial order. This is a form
of partial coherence, and can be strengthened to total coherence by requiring
$\ltN$ to be a per-location total order.

\begin{definition}
  A 3-valued pomset is \emph{partially} (resp.~\emph{totally}) $\aLoc$-\emph{coherent}
  if, when restricted to events which write to $\aLoc$,
  $\ltN$ forms a partial (resp.~total) order.
\end{definition}

\begin{definition}
Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aPS$ is $\aLoc$-closed and partially $\aLoc$-coherent.
\end{definition}

\subsection{Blockers}
\label{app:blockers}

Recall the preliminary definition of reads-from in \S\ref{sec:pomsets}, which
defined an $\aLoc$-blocker to be and event $\cEv$ that writes to $\aLoc$ such that
$\bEv < \cEv < \aEv$.  Were we to adopt this definition, then concurrent
threads could turn events that were not $\aLoc$-blockers into an
$\aLoc$-blocker, even if the new thread does not mention $\aLoc$.

To see this, consider the program
\begin{math}
  (
  \aLoc\GETS1\SEMI
  \bLoc\GETS\aLoc
  \PAR
  \aLoc\GETS\cLoc+1\SEMI
  \bLoc\GETS\aLoc
  \PAR
  \IF(z=2)\THEN\aReg\GETS\aLoc\FI
  )
\end{math}
with execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \rf[out=20,in=160]{wx1}{rx1}
\end{tikzpicture}\]
and the program
\begin{math}
  (
  \cLoc\GETS\bLoc\SEMI
  \cLoc\GETS\bLoc
  )
\end{math}
with execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wz1}{\DW{\cLoc}{1}}{right=of ry1}
  \event{ry2}{\DR{\bLoc}{2}}{right=of wz1}
  \event{wz2}{\DW{\cLoc}{2}}{right=of ry2}
  \po{ry1}{wz1}
  \po{ry2}{wz2}
\end{tikzpicture}\]
If these are placed in parallel, then a possible execution is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \event{ry1}{\DR{\bLoc}{1}}{below=of wy1}
  \event{wz1}{\DW{\cLoc}{1}}{right=of ry1}
  \event{ry2}{\DR{\bLoc}{2}}{below=of wy2}
  \event{wz2}{\DW{\cLoc}{2}}{right=of ry2}
  \po{ry1}{wz1}
  \po{ry2}{wz2}
  \rf{wy1}{ry1}
  \rf{wz1}{rz1}
  \rf{wy2}{ry2}
  \rf{wz2}{rz2}
\end{tikzpicture}\]
and now the $(\DW{\aLoc}{2})$ event is an $\aLoc$-blocker,
so $(\DR{\aLoc}{1})$ cannot
read from $(\DW{\aLoc}{1})$.

In the final definition of reads-from in \S\ref{sec:pomsets} we
ruled out $\aLoc$-blockers by requring that any
event $\cEv$ that writes to $\aLoc$ has
either $\bEv \ltN \cEv$ or $\cEv \ltN \aEv$.
With this definition, in order for $(\DR{\aLoc}{1})$ to read from
$(\DW{\aLoc}{1})$, we either need $(\DW{\aLoc}{1}) \ltN (\DW{\aLoc}{2})$
or $(\DW{\aLoc}{2}) \ltN (\DR{\aLoc}{1})$, for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \rf[out=20,in=160]{wx1}{rx1}
  \wk[out=-150,in=-30]{rx1}{wx2}
  \wk{wy1}{wy2}
\end{tikzpicture}\]
then putting this in parallel as before results in:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \rf[out=20,in=160]{wx1}{rx1}
  \wk[out=-150,in=-30]{rx1}{wx2}
  \wk{wy1}{wy2}
  \event{ry1}{\DR{\bLoc}{1}}{below=of wy1}
  \event{wz1}{\DW{\cLoc}{1}}{right=of ry1}
  \event{ry2}{\DR{\bLoc}{2}}{below=of wy2}
  \event{wz2}{\DW{\cLoc}{2}}{right=of ry2}
  \po{ry1}{wz1}
  \po{ry2}{wz2}
  \rf{wy1}{ry1}
  \rf{wz1}{rz1}
  \rf{wy2}{ry2}
  \rf{wz2}{rz2}
  \wk[out=30,in=150]{wz1}{wz2}
\end{tikzpicture}\]
but this is \emph{not} a valid 3-valued pomset,
since $(\DW{\aLoc}{2}) < (\DR{\aLoc}{1})$ but also $(\DW{\aLoc}{2}) \ltN (\DR{\aLoc}{1})$,
which is a contradiction.


\input{logic}


\subsection{Release/acquire synchronization}
\label{app:ra}

% In relaxed memory models, synchronization actions act as memory fences: that
% is, they are a barrier to reordering memory accesses.  In this section, we
% present a simple model of release/acquire fencing. In
% \S\ref{sec:transactions}, we show that this can be scaled up to a model of
% transactional memory.

% We assume there are sets $\Rel$ and $\Acq \subseteq\Act$.  We say that
% $\aAct$ is a \emph{release action} if $\aAct\in\Rel$ and $\aAct$ is an
% \emph{acquire action} if $\aAct\in\Acq$.
% In a pomset, a release event is one labelled with a release action,
% and an acquire event is one labelled by an acquire action.
% To give the semantics of fences, we add extra constraints
% to Definition~\ref{def:prefix} of prefixing %$\aAct\prefix\aPSS$
% (recalling that $\cEv$ is the %$\aAct$-labelled
% event being introduced):
% \begin{itemize}
% \item $\cEv \le \aEv$ whenever $\cEv$ is an acquire event or $\aEv$ is a release event, and
% \item if $\cEv$ is an acquire event then $\aEv$ is independent of $\aLoc$,
%   for every $\aLoc$.
% \end{itemize}
% The first constraint ensures that events are ordered before a release and
% after an acquire.  The second constraint ensures that thread-local reads do
% not cross acquire fences.

We can develop a simple model of release/acquire synchronization using the
following actions: % we will use
% releasing writes and acquiring reads:
\begin{itemize}
\item $(\DWRel{\aLoc}{\aVal})$, a release action that writes $\aVal$ to $\aLoc$, and
\item $(\DRAcq{\aLoc}{\aVal})$, an acquire action that reads $\aVal$ from $\aLoc$.
\end{itemize}
The semantics of programs with releasing write and acquiring read are similar
to regular write and read, with $\DWRel\aLoc\aVal$ replacing
$\DW\aLoc\aVal$ and $\DRAcq\aLoc\aVal$ replacing $\DR\aLoc\aVal$:
\begin{eqnarray*}
  \sem{\REL\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; \bigl((\aExp=\aVal) \guard (\DWRel\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]\bigr) \\
  \sem{\ACQ\aReg\GETS\aLoc\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; (\DRAcq\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg]
\end{eqnarray*}

To see the need for the first constraint on prefixing, consider the program:
\[
  \VAR x\GETS0\SEMI \VAR f\GETS0\SEMI
  (x\GETS 1\SEMI \REL f\GETS1 \PAR \ACQ r\GETS f; s\GETS x)
\]
This has an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wf0}{\DW{f}{0}}{right=of wx0}
  \event{wx1}{\DW{x}{1}}{below=of wx0}
  \event{wf1}{\DWRel{f}{1}}{right=of wx1}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx1}{\DR{x}{1}}{right=of rf1}
  \po{wx0}{wf1}
  \po{wf0}{wf1}
  \po{wx1}{wf1}
  \po{rf1}{rx1}
  \rf{wf1}{rf1}
  \rf[out=20,in=160]{wx1}{rx1}
  \wk{wx0}{wx1}
\end{tikzpicture}\]
but \emph{not}:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wf0}{\DW{f}{0}}{right=of wx0}
  \event{wx1}{\DW{x}{1}}{below=of wx0}
  \event{wf1}{\DWRel{f}{1}}{right=of wx1}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx0}{\DR{x}{0}}{right=of rf1}
  \po{wx0}{wf1}
  \po{wf0}{wf1}
  \po{wx1}{wf1}
  \po{rf1}{rx1}
  \rf{wf1}{rf1}
  \rf[out=-20,in=160]{wx0}{rx0}
  \wk{wx0}{wx1}
\end{tikzpicture}\]
since $(\DW x0) \gtN (\DW x1) < (\DR x0)$, so this pomset does not satisfy the
requirements to be $x$-closed.
If we replace the release
with a plain write, then the outcome $(\DRAcq f1)$ and $(\DR x0)$ is possible:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wf0}{\DW{f}{0}}{right=of wx0}
  \event{wx1}{\DW{x}{1}}{below=of wx0}
  \event{wf1}{\DW{f}{1}}{right=of wx1}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx0}{\DR{x}{0}}{right=of rf1}
  \wk{wf0}{wf1}
  \po{rf1}{rx0}
  \rf{wf1}{rf1}
  \rf[out=-20,in=160]{wx0}{rx0}
  \wk{wx0}{wx1}
\end{tikzpicture}\]
since no order is required between $(\DW x1)$ and $(\DW f1)$.  
Symmetrically, if we replace the acquire of the original program
with a plain read, then the outcome $(\DR f1)$ and $(\DR x0)$ is possible.
% \begin{verbatim}
%   x := 0; rel f := 0; ||
%   acq r := f; if (r == 0) { x := x+1; rel f := 1; } ||
%   acq s := f; if (r == 1) { x := x+1; rel f := 2; }
% \end{verbatim}
% This has an execution:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wf0}{\DWRel{f}{0}}{below=of wx0}
%   \event{rf0}{\DRAcq{f}{0}}{right=2.5 em of wx0}
%   \event{rx0}{\DR{x}{0}}{below=of rf0}
%   \event{wx1}{\DW{x}{1}}{below=of rx0}
%   \event{wf1}{\DWRel{f}{1}}{below=of wx1}
%   \event{rf1}{\DRAcq{f}{1}}{right=2.5 em of rf0}
%   \event{rx1}{\DR{x}{1}}{below=of rf1}
%   \event{wx2}{\DW{x}{2}}{below=of rx1}
%   \event{wf2}{\DWRel{f}{2}}{below=of wx2}
%   \po{wx0}{wf0}
%   \po{rf0}{rx0}
%   \po{rx0}{wx1}
%   \po{wx1}{wf1}
%   \po{rf1}{rx1}
%   \po{rx1}{wx2}
%   \po{wx2}{wf2}
%   \rf{wf0}{rf0}
%   \rf{wx0}{rx0}
%   \rf{wf1}{rf1}
%   \rf{wx1}{rx1}
% \end{tikzpicture}\]
% but \emph{not}:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wf0}{\DWRel{f}{0}}{below=of wx0}
%   \event{rf0}{\DRAcq{f}{0}}{right=2.5 em of wx0}
%   \event{rx0}{\DR{x}{0}}{below=of rf0}
%   \event{wx1}{\DW{x}{1}}{below=of rx0}
%   \event{wf1}{\DWRel{f}{1}}{below=of wx1}
%   \event{rf1}{\DRAcq{f}{1}}{right=2.5 em of rf0}
%   \event{rx0b}{\DR{x}{0}}{below=of rf1}
%   \event{wx1b}{\DW{x}{1}}{below=of rx0b}
%   \event{wf2}{\DWRel{f}{2}}{below=of wx1b}
%   \po{wx0}{wf0}
%   \po{rf0}{rx0}
%   \po{rx0}{wx1}
%   \po{wx1}{wf1}
%   \po{rf1}{rx0b}
%   \po{rx0b}{wx1b}
%   \po{wx1b}{wf2}
%   \rf{wf0}{rf0}
%   \rf{wx0}{rx0}
%   \rf{wf1}{rf1}
%   \rf{wx0}{rx0b}
% \end{tikzpicture}\]
% since $(\DW x0) < (\DW x1) < (\DR x0)$, so this pomset does not satisfy the
% requirements to be an rf-pomset.

% The notion rf-pomset is sufficient to capture hardware models and
% release/acquire access in C++, where reads-from implies happens-before
% \cite{alglave}.  To model C++ relaxed access, it
% would be necessary to use a more general notion of rf-pomset, where
% $(\bEv,\aLoc,\aEv) \in \RF$ does not necessarily imply $\bEv < \aEv$, instead
% requiring that $(\mathord< \cup \mathord\RF)$ be acyclic.

%% To see the need for the second constraint on prefixing, consider the program:
%% \begin{displaymath}
%%   (
%%   x\GETS1\SEMI
%%   \REL f\GETS 1\SEMI
%%   \ACQ r\GETS f\SEMI
%%   y\GETS x
%%   )
%%   \PAR
%%   (
%%   \ACQ s\GETS f\SEMI
%%   x\GETS2\SEMI
%%   \REL f\GETS 2\SEMI
%%   )
%% \end{displaymath}
%% whose semantics includes execution:
%% \begin{displaymath}
%% \begin{tikzpicture}[node distance=1em]
%%   \event{wx1}{\DW{x}{1}}{}
%%   \event{wf1}{\DWRel{f}{1}}{right=of wx1}
%%   \event{rf1}{\DRAcq{f}{2}}{below=of wf1}
%%   \event{wx2}{\DW{x}{2}}{right=of rf1}
%%   \event{wf2}{\DWRel{f}{1}}{right=of wx2}
%%   \event{rf2}{\DRAcq{f}{2}}{above=of wf2}
%%   \event{wy1}{\DW{y}{1}}{right=of rf2}
%%   \po{wx1}{wf1}
%%   \rf{wf1}{rf1}
%%   \po{rf1}{wx2}
%%   \po{wx2}{wf2}
%%   \rf{wf2}{rf2}
%%   \po{rf2}{wy1}
%% \end{tikzpicture}
%% \end{displaymath}
%% This execution exists because
%% \begin{math}
%%   \sem{y\GETS x}
%% \end{math}
%% includes
%% \begin{math}
%%   (x=1\mid \DW{y}{1})
%% \end{math}
%% and the precondition $x=1$ is fulfilled by the preceding write $x\GETS1$.  In
%% implementation term, this execution is reading $1$ from $x$ in a ``stale
%% cache.''  The alternative execution that attempts to read $1$ from the $x$ in
%% ``main memory,'' has an explicit $(\DR{x}{1})$ between $(\DRAcq{f}{2})$ and
%% $(\DW{y}{1})$, and thus will fail to be $x$-closed.

%% To prevent thread-local writes from crossing release/acquire pairs, we
%% require that pomsets in the semantics of acquire have no free locations.
%% This corresponds to the idea that acquires flush the read cache, and
%% therefore reads must reload values from main memory after an acquire.

% In addition, we must change the semantics of write from
% \S\ref{sec:sets-of-pomsets} to ensure that an action is generated for every
% write that might be published by a subsequent release action.
% Formally, $\sem{\aLoc\GETS\aExp\SEMI \aCmd}$ only includes pomsets
% from $\sem{\aCmd}[\aExp/\aLoc]$ that contain a write to
% $\aLoc$ that is not preceded by a release.


\subsection{Causality test cases}
\label{app:tc}

\citet{PughWebsite} developed a set of twenty {causality test cases} in the
process of revising the Java Memory Model (JMM)
\cite{Manson:2005:JMM:1047659.1040336}.  Using hand calculation, we have
confirmed that our model gives the desired result for all twenty cases,
unrolling loops as necessary.  Our model also gives the desired results for
all of the examples in \citet[\textsection 4]{DBLP:conf/esop/BattyMNPS15} and
all but one in \citet[\textsection 5.3]{SevcikThesis}:
redundant-write-after-read-elimination fails for any
sensible non-coherent semantics.  Our model agrees with the JMM on the
``surprising and controversial behaviors'' of \citet[\textsection
8]{Manson:2005:JMM:1047659.1040336}, and thus fails to validate thread
inlining.

In this section, we discuss three of the causality test cases and the thread
inlining from \cite{Manson:2005:JMM:1047659.1040336}.  In presenting the
examples, we unroll loops, correct typos and simplify the code.  

\subsubsection{Causality test case 8}

Test case 8 asks whether:
\begin{displaymath}
  \VAR x\GETS 0\SEMI
  \VAR y\GETS 0\SEMI
  (\IF(x<2)\THEN y\GETS 1\FI 
  \PAR
  x\GETS y)
\end{displaymath}
may read $1$ for both $x$ and $y$.  This behavior is allowed, since
``interthread analysis could determine that $x$ and $y$ are always either $0$
or $1$.''  This breaks the dependency between the read of $x$ and the write
to $y$ in the first thread, allowing the write to be moved earlier.

The semantics of TC8 includes
\[\begin{tikzpicture}[node distance=1em]
  \event{ix}{\DW{x}{0}}{}
  \event{iy}{\DW{y}{0}}{right=of ix}
  \event{rx1}{\DR{x}{1}}{right=2.1em of iy}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.1em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \po{ry1}{wx1}
  \po[out=30,in=150]{ix}{rx1}
  \rf[in=-25,out=-160]{wx1}{rx1}
  \rf[out=20,in=160]{wy1}{ry1}
  \wk[out=-25,in=-150]{ix}{wx1}
  \wk[out=25,in=155]{iy}{wy1}
\end{tikzpicture}\]
Where we require $(\DW{x}{0})<(\DR{x}{1})$ but not $(\DR{x}{1})<(\DW{y}{1})$.
To see why this execution exists, consider the left thread with syntax sugar
removed:
\begin{displaymath}
  r\GETS x\SEMI \IF(r<2)\THEN y\GETS 1\FI
\end{displaymath}
\begin{math}
  \sem{\IF(r<2)\THEN y\GETS 1\FI}
\end{math}
includes
\begin{math}
  (r<2\mid\DW{y}{1}).
\end{math}
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wy1}{r<2\mid\DW{y}{1}}{}
% \end{tikzpicture}\]
Thus, by Figure~\ref{fig:programs}, 
\begin{math}
  \sem{r\GETS x\SEMI \IF(r<2)\THEN y\GETS 1\FI}
\end{math}
includes
\begin{math}
  (\DR{x}{1}) \prefix (r<2\mid\DW{y}{1})[x/r]
\end{math}
which simplifies to
\begin{math}
  (\DR{x}{1}) \prefix (x<2\mid\DW{y}{1}),
\end{math}
which, by Definition~\ref{def:prefix}, includes:
\[\begin{tikzpicture}[node distance=1em,baselinecenter]
    \event{rx1}{\DR{x}{1}}{}
    \event{wy1}{x<2\mid\DW{y}{1}}{right=of rx1}
  \end{tikzpicture}\]
Here we have used the \textsc{[non-ordering read]} clause of Definition~\ref{def:prefix}:
``$\bForm'$ implies $\bForm[\aVal/\aLoc] \land \bForm$, if $\aAct$ reads $\aVal$ from $\aLoc$,''
where $a=(\DR{x}{1})$,  $\bForm=\bForm'=(x<2)$.  We can use this case since
$x<2$ implies $1<2\land x<2$.

Prefixing with $(\DW{x}{0})$ allows us to discharge the assumption $x<2$,
arriving at:
\[\begin{tikzpicture}[node distance=1em,baselinecenter]
    \event{ix}{\DW{x}{0}}{}
    \event{rx1}{\DR{x}{1}}{right=2.5 em of ix}
    \event{wy1}{\DW{y}{1}}{right=of rx1}
    \po{ix}{rx1}
  \end{tikzpicture}\]
Here we have used the \textsc{[ordering read]}
clause of \ref{def:prefix}:
``$\bForm'$ implies $\bForm[\aVal/\aLoc]$, if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$,''
where $a=(\DW{x}{0})$,  $\bForm=(x<2)$ and $\bForm'=\TRUE$.  As long as
require
\begin{math}
  (\DW{x}{0})<
  (\DR{x}{1}),
\end{math}
we can use this case since $\TRUE$ implies $0<2$.

\subsubsection{Causality test case 9}

Test case 9 asks whether:
\begin{displaymath}
  \VAR x\GETS 0\SEMI
  \VAR y\GETS 0\SEMI
  (\IF(x<2)\THEN y\GETS 1\FI 
  \PAR
  x\GETS y
  \PAR
  y\GETS 2\SEMI)
\end{displaymath}
may read $1$ for both $x$ and $y$.  This behavior is also allowed.  This is
``similar to test case $8$, except that $x$ is not always $0$ or
$1$. However, a compiler might determine that the read of $x$ by thread $1$
will never see the write by thread $3$ (perhaps because thread $3$ will be
scheduled after thread $1$)''

Reasoning as for test case 8, the semantics of test case 9 includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{ix}{\DW{x}{0}}{}
  \event{iy}{\DW{y}{0}}{right=of ix}
  \event{rx1}{\DR{x}{1}}{right=2.2 em of iy}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.2em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wx2}{\DW{x}{2}}{below=3ex of $(ix)!0.5!(iy)$}%{right=2.5em of wx1}
  \po{ry1}{wx1}
  \po[out=30,in=150]{ix}{rx1}
  \rf[in=-25,out=-160]{wx1}{rx1}
  \rf[out=20,in=160]{wy1}{ry1}
  \wk[out=-25,in=-150]{ix}{wx1}
  \wk[out=25,in=155]{iy}{wy1}
  \wk{ix}{wx2}
  % \wk[out=-25,in=-150]{ix}{wx2}
\end{tikzpicture}\]

Thus, with respect to the introduction of new threads, our model appears to
be more robust than the event structures semantics of
\cite{DBLP:conf/lics/JeffreyR16}, which fails on this test case.

\subsubsection{Causality test case 14}

Test case 14 asks whether:
\begin{multline*}
  \VAR a\GETS 0\SEMI
  \VAR b\GETS 0\SEMI
  \VAR y\GETS 0\SEMI\\[-.5ex]
  (\IF(a)\THEN b\GETS 1\ELSE y\GETS 1\FI 
  \PAR\\[-.5ex]
  \WHILE(y+b==0) \THEN\SKIP\FI\; a\GETS1)
\end{multline*}
may read $1$ for $a$ and $b$, yet $0$ for $y$.  Here $a$ and $b$ are regular
variables and $y$ is volatile, which is equivalent to release/acquire in this
example.  This behavior is also disallowed, since ``in all sequentially
consistent executions, [the read of $a$ gets $0$] and the program is
correctly synchronized. Since the program is correctly synchronized in all SC
executions, no non-SC behaviors are allowed.''

Unrolling the loop once, we have:
\begin{multline*}
  \VAR a\GETS 0\SEMI
  \VAR b\GETS 0\SEMI
  \VAR y\GETS 0\SEMI\\[-.5ex]
  (\IF(a)\THEN b\GETS 1\ELSE y\GETS 1\FI 
  \PAR\\[-.5ex]
  \IF(y\lor b)\THEN a\GETS 1\FI)
\end{multline*}
We argue that any execution with $(\DR{a}{1})$, $(\DR{b}{1})$, and
$(\DR{y}{0})$ must be cyclic.  The closure requirements require that
\begin{math}
  (\DW{a}{1})<(\DR{a}{1})
  \;\text{and}\;
  (\DR{b}{1})<(\DR{b}{1}).
\end{math}
Ignoring initialization, least ordered execution that includes all of these
actions is:
\[\begin{tikzpicture}[node distance=1em]
  \event{ra1}{\DR{a}{1}}{}
  \event{wb1}{\DW{b}{1}}{below=of ra1}
  \nonevent{wy1}{\DW{y}{1}}{left=of wb1}
  \event{rb1}{\DR{b}{1}}{right=4.5em of ra1}
  \event{ry0}{\DR{y}{0}}{right=of rb1}
  \event{wa1}{\DW{a}{1}}{below=of rb1}
  \po{ra1}{wb1}
  \po{rb1}{wa1}
  \rf{wa1}{ra1}
  \rf{wb1}{rb1}
\end{tikzpicture}\]
where the read of $a$ is ordering for $(\DW{b}{1})$ but
not $(\DW{y}{1})$, and the read of $b$ is ordering for $(\DW{a}{1})$ but the
read of $y$ is not.  $(\DW{y}{1})$ is crossed out, since its
precondition must imply $(\lnot a)[1/a]$, which is equivalent to $\FALSE$.
To avoid order from $(\DR{y}{0})$ to $(\DW{a}{1})$, we
have strengthened the predicate on $(\DW{a}{1})$ from $(y\lor b)$ to
$(y=0\land b=1)$.  Note that we cannot use this trick symmetrically to remove
the order from $(\DR{b}{1})$ to $(\DW{a}{1})$, since $b=1$ does not follow
from the initialization of $b$.


\subsubsection{Thread inlining}

One property one could ask of a model of shared memory is thread
inlining: any execution of $\sem{P\SEMI Q}$ is an execution of $\sem{P
  \PAR Q}$. This is \emph{not} a goal of our model, and indeed is not
satisfied, due to the different semantics of concurrent and sequential
memory accesses. We demonstrate this by considering an example from
the Java Memory Model~\cite{Manson:2005:JMM:1047659.1040336}, which shows that Java does not
satisfy thread inlining either.

The lack of thread inlining is related to the different dependency
relations introduced by sequential and concurrent access.
Recall from \S\ref{sec:sequential-memory} that the program
\verb`(x := 0; y := x+1;)` has execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
but that \verb`(x := 1; || y := x+1;)` has:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
That is, in the sequential case there is no dependency from the
write of $x$ to the write of $y$, but in the concurrent case there
is such a dependency.

This can be used to construct a counter-example to thread inlining, based on~\cite[Ex~11]{Manson:2005:JMM:1047659.1040336}:
\begin{verbatim}
  x := 0; if (x == 1) { z := 1; } else { x := 1; } || y := x; || x := y;
\end{verbatim}
This has no execution containing $(\DW z1)$. Any attempt to build such an execution
results in a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{rx1b}{\DR{x}{1}}{below=of wx1a}%{right=2.5em of wx1a}
  \event{wy1}{\DW{y}{1}}{right=of rx1b}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{wx1b}{\DW{x}{1}}{right=of ry1}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
  \po{rx1b}{wy1}
  \po{ry1}{wx1b}
  \rf{wy1}{ry1}
  \rf[out=160, in=30]{wx1b}{rx1a}
  \rf[out=160, in=30]{wx1b}{rx1b}
\end{tikzpicture}\]
Inlining the thread \verb|(y := x)| gives~\cite[Ex~12]{Manson:2005:JMM:1047659.1040336}:
\begin{verbatim}
  x := 0; if (x == 1) { z := 1; } else { x := 1; } y := x; || x := y;
\end{verbatim}
with execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{wx1b}{\DW{x}{1}}{right=of ry1}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
  \po{ry1}{wx1b}
  \rf{wy1}{ry1}
  \rf[out=160, in=30]{wx1b}{rx1a}
\end{tikzpicture}\]
To see why this execution exists, consider the program fragment:
\begin{verbatim}
  if (x == 1) { z := 1; } else { x := 1; } y := x;
\end{verbatim}
Removing the syntax sugar, this is:
\begin{verbatim}
  r1 := x; if (r1 == 1) {
    z := 1; r2 := x; y := r2; skip
  } else {
    x := 1; r3 := x; y := r3; skip
  }
\end{verbatim}
Now, $\sem{z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP}$
includes pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{r_1=1 \mid \DW{z}{1}}{}
  \event{wy1}{r_1=x=1 \mid \DW{y}{1}}{right=of wz1}
\end{tikzpicture}\]
and $\sem{x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP}$
includes pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1a}{r_1\neq 1 \mid \DW{x}{1}}{}
  \event{wy1}{r_1\neq 1 \mid \DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
so  $\sem{\IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{r_1=1 \mid \DW{z}{1}}{}
  \event{wx1a}{r_1\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{(r_1=x=1) \lor (r_1\neq1) \mid \DW{y}{1}}{below=3ex of $(wz1)!0.5!(wx1a)$}
\end{tikzpicture}\]
which means $\sem{\IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}[x/r_1]$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{x=1 \mid \DW{z}{1}}{}
  \event{wx1a}{x\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{(x=x=1) \lor (x\neq1)) \mid \DW{y}{1}}{below=3ex of $(wz1)!0.5!(wx1a)$}%{right=of wx1a}
\end{tikzpicture}\]
Now $(x=x=1) \lor (x\neq1)$ is a tautology, so this is just:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{x=1 \mid \DW{z}{1}}{}
  \event{wx1a}{x\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
and so $\sem{r_1 \GETS x\SEMI \IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{1=1 \mid \DW{z}{1}}{right=of rx1a}
  \event{wx1a}{1\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
\end{tikzpicture}\]
which simplifies to:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
\end{tikzpicture}\]
as required. The rest of the example is straightforward, and shows that our semantics
agrees with the JMM in not supporting thread inlining.



% \subsection{Word tearing}

% \todo{Remove this section, since it's not needed for transactions?}

% In \S\ref{sec:transactions}, we shall be considering transactional memory,
% and in \S\ref{sec:transactions} show that we can model a simplified version
% of an information flow attack on transactions. In order to model transactions,
% we need to consider actions that can write many memory locations at once,
% since this is part of the semantics of commitment. To lead up to this, we first
% consider a simpler scenario of many-location writes and reads, which is word
% tearing.

% In word tearing, a program contains a write instruction with data larger
% than the hardware word size, for example copying a byte array, or assigning
% a 64-bit float on a 32-bit architecture. For example, consider the program:
% \begin{verbatim}
%   (x := [0, 0];) || (x := [1, 1];) || (r := x;)
% \end{verbatim}
% This has executions in which the read of $x$ only reads from one of the writes,
% for example:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx00}{\DW{x}{[0,0]}}{}
%   \event{wx11}{\DW{x}{[1,1]}}{right=2.5em of wx00}
%   \event{rx00}{\DR{x}{[0,0]}}{right=2.5em of wx11}
%   \rf[out=20, in=160]{wx00}{rx00}
% \end{tikzpicture}\]
% but also has executions in which the read of $x$ reads from both writes,
% for example:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx00}{\DW{x}{[0,0]}}{}
%   \event{wx11}{\DW{x}{[1,1]}}{right=2.5em of wx00}
%   \event{rx01}{\DR{x}{[0,1]}}{right=2.5em of wx11}
%   \rfx[out=20, in=160]{wx00}{x[0]}{rx01}
%   \rfx[out=-20, in=-160]{wx11}{x[1]}{rx01}
% \end{tikzpicture}\]
% Word tearing can occur, for example, in Java extended floating point~\cite{jmm},
% LLVM 64-bit instructions on 32-bit hardware~\cite{llvm}, or in
% JavaScript SharedArrayBuffers~\cite{js-sab}.

% \newcommand{\rfControl}[4][]{\draw[rf,#1](#2) .. controls (#3) .. (#4);}
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wx1}{\DW{x}{1}}{right=of wx0}
%   \event{wy0}{\DW{y}{0}}{right=2.5em of wx1}
%   \event{wy1}{\DW{y}{1}}{right=of wy0}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wy1}
%   \event{ry0}{\DR{y}{0}}{right=of rx1}
%   \event{ry1}{\DR{y}{1}}{right=2.5 em of ry0}
%   \event{rx0}{\DR{x}{0}}{right=of ry1}
%   \rf[out=20,in=160]{wx1}{rx1}
%   \rf[out=20,in=160]{wy0}{ry0}
%   \rf[out=340,in=200]{wy1}{ry1}
%   \coordinate (a) [below=of wy1];
%   \rfControl[out=340,in=200]{wx0}{a}{rx0}
%   \wk{wx0}{wx1}
%   \wk{wy0}{wy1}
%   \po{rx1}{ry0}
%   \po{ry1}{rx0}
% \end{tikzpicture}\]


% Batty section 4:
% \cite[\S4]{DBLP:conf/esop/BattyMNPS15},
% Example LB+ctrldata+ctrl-double (language must allow)
% r1=loadrlx(x) //reads 42
% if (r1 == 42)
%   storerlx(y,r1)

% r2=loadrlx(y) //reads 42
% if (r2 == 42)
%   storerlx (x,42)
% else
% storerlx (x,42)

% a:RRLX x=42 sb,dd,cd
% c:RRLX y=42 sb,cd
%   This is forbidden on hardware if compiled naively, as the architectures respect read-to-write control dependencies, but in practice compilers will collapse con- ditionals like that of the second thread, removing the control dependencies from the read of y to the writes of x and making the code identical to the previous example. As that example is allowed and observable on hardware (and we pre- sume that it would be impractical to outlaw such optimisation for C or C++), the language must also allow this execution. But this execution has a cycle in the union of reads-from and dependency, so we cannot simply exclude all those.
% Then one might hope for some other adaptation of the C/C++11 model, but the following example shows at least that there is no per-candidate-execution solution.
% Example LB+ctrldata+ctrl-single (language can and should forbid)
% r1=loadrlx(x) //reads 42 if (r1 == 42)
% storerlx (y,r1) r2=loadrlx (y) //reads 42 if (r2 == 42)
% a:RRLX x=42 sb,dd,cd
% rf
% b:WRLX y=42
% c:RRLX y=42 sb,cd
% rf
% d:WRLX x=42
% rf rf
% b:WRLX y=42 d:WRLX x=42
%   storerlx (x,42)
