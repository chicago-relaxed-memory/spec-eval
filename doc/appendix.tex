\subsection{Blockers}
\label{sec:blockers}

Recall the preliminary definition of reads-from in \S\ref{sec:pomsets}, which
defined an $\aLoc$-blocker to be and event $\cEv$ that writes to $\aLoc$ such that
$\bEv < \cEv < \aEv$.  Were we to adopt this definition, then concurrent
threads could turn events that were not $\aLoc$-blockers into an
$\aLoc$-blocker, even if the new thread does not mention $\aLoc$.

To see this, consider the program
\begin{math}
  (
  \aLoc\GETS1\SEMI
  \bLoc\GETS\aLoc
  \PAR
  \aLoc\GETS\cLoc+1\SEMI
  \bLoc\GETS\aLoc
  \PAR
  \IF(z=2)\THEN\aReg\GETS\aLoc\FI
  )
\end{math}
with execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \rf[out=20,in=160]{wx1}{rx1}
\end{tikzpicture}\]
and the program
\begin{math}
  (
  \cLoc\GETS\bLoc\SEMI
  \cLoc\GETS\bLoc
  )
\end{math}
with execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wz1}{\DW{\cLoc}{1}}{right=of ry1}
  \event{ry2}{\DR{\bLoc}{2}}{right=of wz1}
  \event{wz2}{\DW{\cLoc}{2}}{right=of ry2}
  \po{ry1}{wz1}
  \po{ry2}{wz2}
\end{tikzpicture}\]
If these are placed in parallel, then a possible execution is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \event{ry1}{\DR{\bLoc}{1}}{below=of wy1}
  \event{wz1}{\DW{\cLoc}{1}}{right=of ry1}
  \event{ry2}{\DR{\bLoc}{2}}{below=of wy2}
  \event{wz2}{\DW{\cLoc}{2}}{right=of ry2}
  \po{ry1}{wz1}
  \po{ry2}{wz2}
  \rf{wy1}{ry1}
  \rf{wz1}{rz1}
  \rf{wy2}{ry2}
  \rf{wz2}{rz2}
\end{tikzpicture}\]
and now the $(\DW{\aLoc}{2})$ event is an $\aLoc$-blocker,
so $(\DR{\aLoc}{1})$ cannot
read from $(\DW{\aLoc}{1})$.

In the final definition of reads-from in \S\ref{sec:pomsets} we
ruled out $\aLoc$-blockers by requring that any
event $\cEv$ that writes to $\aLoc$ has
either $\bEv \ltN \cEv$ or $\cEv \ltN \aEv$.
With this definition, in order for $(\DR{\aLoc}{1})$ to read from
$(\DW{\aLoc}{1})$, we either need $(\DW{\aLoc}{1}) \ltN (\DW{\aLoc}{2})$
or $(\DW{\aLoc}{2}) \ltN (\DR{\aLoc}{1})$, for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \rf[out=20,in=160]{wx1}{rx1}
  \wk[out=-150,in=-30]{rx1}{wx2}
  \wk{wy1}{wy2}
\end{tikzpicture}\]
then putting this in parallel as before results in:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rz1}{\DR{\cLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rz1}
  \event{rz2}{\DR{\cLoc}{2}}{right=of wx2}
  \event{rx1}{\DR{\aLoc}{1}}{right=of rz2}
  \event{rx1a}{\DR{\aLoc}{1}}{below=of wx1}
  \event{wy1}{\DW{\bLoc}{1}}{below=of rx1a}
  \event{rx2a}{\DR{\aLoc}{2}}{below=of wx2}
  \event{wy2}{\DW{\bLoc}{2}}{below=of rx2a}
  \rf{wx1}{rx1a}
  \po{rx1a}{wy1}
  \rf{wx2}{rx2a}
  \po{rx2a}{wy2}
  \po{rz1}{wx2}
  \po{rz2}{rx1}
  \rf[out=20,in=160]{wx1}{rx1}
  \wk[out=-150,in=-30]{rx1}{wx2}
  \wk{wy1}{wy2}
  \event{ry1}{\DR{\bLoc}{1}}{below=of wy1}
  \event{wz1}{\DW{\cLoc}{1}}{right=of ry1}
  \event{ry2}{\DR{\bLoc}{2}}{below=of wy2}
  \event{wz2}{\DW{\cLoc}{2}}{right=of ry2}
  \po{ry1}{wz1}
  \po{ry2}{wz2}
  \rf{wy1}{ry1}
  \rf{wz1}{rz1}
  \rf{wy2}{ry2}
  \rf{wz2}{rz2}
  \wk[out=30,in=150]{wz1}{wz2}
\end{tikzpicture}\]
but this is \emph{not} a valid 3-valued pomset,
since $(\DW{\aLoc}{2}) < (\DR{\aLoc}{1})$ but also $(\DW{\aLoc}{2}) \ltN (\DR{\aLoc}{1})$,
which is a contradiction.


\section{Causality test cases}
\label{sec:tc}

\citet{PughWebsite} developed a set of twenty {causality test cases} in the
process of revising the Java Memory Model (JMM)
\cite{Manson:2005:JMM:1047659.1040336}.  Using hand calculation, we have
confirmed that our model gives the desired result for all twenty cases,
unrolling loops as necessary.  Our model also gives the desired results for
all of the examples in \citet[\textsection 4]{DBLP:conf/esop/BattyMNPS15} and
all but one in \citet[\textsection 5.3]{SevcikThesis}:
redundant-write-after-read-elimination fails for any
sensible non-coherent semantics.  Our model agrees with the JMM on the
``surprising and controversial behaviors'' of \citet[\textsection
8]{Manson:2005:JMM:1047659.1040336}, and thus fails to validate thread
inlining.

In this section, we discuss three of the causality test cases and the thread
inlining from \cite{Manson:2005:JMM:1047659.1040336}.  In presenting the
examples, we unroll loops, correct typos and simplify the code.  

\subsection{Causality test case 8}

Test case 8 asks whether:
\begin{displaymath}
  \VAR x\GETS 0\SEMI
  \VAR y\GETS 0\SEMI
  (\IF(x<2)\THEN y\GETS 1\FI 
  \PAR
  x\GETS y)
\end{displaymath}
may read $1$ for both $x$ and $y$.  This behavior is allowed, since
``interthread analysis could determine that $x$ and $y$ are always either $0$
or $1$.''  This breaks the dependency between the read of $x$ and the write
to $y$ in the first thread, allowing the write to be moved earlier.

The semantics of TC8 includes
\[\begin{tikzpicture}[node distance=1em]
  \event{ix}{\DW{x}{0}}{}
  \event{iy}{\DW{y}{0}}{right=of ix}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of iy}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy0}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \po{ry1}{wx1}
  \po[out=30,in=150]{ix}{rx1}
  \rf[in=-25,out=-160]{wx1}{rx1}
  \rf[out=20,in=160]{wy1}{ry1}
  \wk[out=-25,in=-150]{ix}{wx1}
  \wk[out=25,in=155]{iy}{wy1}
\end{tikzpicture}\]
Where we require $(\DW{x}{0})<(\DR{x}{1})$ but not $(\DR{x}{1})<(\DW{y}{1})$.
To see why this execution exists, consider the left thread with syntax sugar
removed:
\begin{displaymath}
  r\GETS x\SEMI \IF(r<2)\THEN y\GETS 1\FI
\end{displaymath}
\begin{math}
  \sem{\IF(r<2)\THEN y\GETS 1\FI}
\end{math}
includes
\begin{math}
  (r<2\mid\DW{y}{1}).
\end{math}
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wy1}{r<2\mid\DW{y}{1}}{}
% \end{tikzpicture}\]
Thus, by Definition~\ref{def:programs}, 
\begin{math}
  \sem{r\GETS x\SEMI \IF(r<2)\THEN y\GETS 1\FI}
\end{math}
includes
\begin{math}
  (\DR{x}{1}) \prefix (r<2\mid\DW{y}{1})[x/r]
\end{math}
which simplifies to
\begin{math}
  (\DR{x}{1}) \prefix (x<2\mid\DW{y}{1}),
\end{math}
which, by Definition~\ref{def:prefix}, includes:
\[\begin{tikzpicture}[node distance=1em,baselinecenter]
    \event{rx1}{\DR{x}{1}}{}
    \event{wy1}{x<2\mid\DW{y}{1}}{right=of rx1}
  \end{tikzpicture}\]
Here we have used the \textsc{[non-ordering read]} clause of Definition~\ref{def:prefix}:
``$\bForm'$ implies $\bForm[\aVal/\aLoc] \land \bForm$, if $\aAct$ reads $\aVal$ from $\aLoc$,''
where $a=(\DR{x}{1})$,  $\bForm=\bForm'=(x<2)$.  We can use this case since
$x<2$ implies $1<2\land x<2$.

Prefixing with $(\DW{x}{0})$ allows us to discharge the assumption $x<2$,
arriving at:
\[\begin{tikzpicture}[node distance=1em,baselinecenter]
    \event{ix}{\DW{x}{0}}{}
    \event{rx1}{\DR{x}{1}}{right=2.5 em of ix}
    \event{wy1}{\DW{y}{1}}{right=of rx1}
    \po{ix}{rx1}
  \end{tikzpicture}\]
Here we have used the \textsc{[ordering read]}
clause of \ref{def:prefix}:
``$\bForm'$ implies $\bForm[\aVal/\aLoc]$, if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$,''
where $a=(\DW{x}{0})$,  $\bForm=(x<2)$ and $\bForm'=\TRUE$.  As long as
require
\begin{math}
  (\DW{x}{0})<
  (\DR{x}{1}),
\end{math}
we can use this case since $\TRUE$ implies $0<2$.

\subsection{Causality test case 9}

Test case 9 asks whether:
\begin{displaymath}
  \VAR x\GETS 0\SEMI
  \VAR y\GETS 0\SEMI
  (\IF(x<2)\THEN y\GETS 1\FI 
  \PAR
  x\GETS y
  \PAR
  y\GETS 2\SEMI)
\end{displaymath}
may read $1$ for both $x$ and $y$.  This behavior is also allowed.  This is
``similar to test case $8$, except that $x$ is not always $0$ or
$1$. However, a compiler might determine that the read of $x$ by thread $1$
will never see the write by thread $3$ (perhaps because thread $3$ will be
scheduled after thread $1$)''

Reasoning as for test case 8, the semantics of test case 9 includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{ix}{\DW{x}{0}}{}
  \event{iy}{\DW{y}{0}}{right=of ix}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of iy}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy0}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \event{wx2}{\DW{x}{2}}{right=2.5em of wx1}
  \po{ry1}{wx1}
  \po[out=30,in=150]{ix}{rx1}
  \rf[in=-25,out=-160]{wx1}{rx1}
  \rf[out=20,in=160]{wy1}{ry1}
  \wk[out=-25,in=-150]{ix}{wx1}
  \wk[out=25,in=155]{iy}{wy1}
  \wk[out=-25,in=-150]{ix}{wx2}
\end{tikzpicture}\]

Thus, with respect to the introduction of new threads, our model appears to
be more robust than the event structures semantics of
\cite{DBLP:conf/lics/JeffreyR16}, which fails on this test case.

\subsection{Causality test case 14}

Test case 14 asks whether:
\begin{displaymath}
  \VAR a\GETS 0\SEMI
  \VAR b\GETS 0\SEMI
  \VAR y\GETS 0\SEMI
  (\IF(a)\THEN b\GETS 1\ELSE y\GETS 1\FI 
  \PAR
  \WHILE(y+b==0) \THEN\SKIP\FI\; a\GETS1)
\end{displaymath}
may read $1$ for $a$ and $b$, yet $0$ for $y$.  Here $a$ and $b$ are regular
variables and $y$ is volatile, which is equivalent to release/acquire in this
example.  This behavior is also disallowed, since ``in all sequentially
consistent executions, [the read of $a$ gets $0$] and the program is
correctly synchronized. Since the program is correctly synchronized in all SC
executions, no non-SC behaviors are allowed.''

Unrolling the loop once, we have:
\begin{displaymath}
  \VAR a\GETS 0\SEMI
  \VAR b\GETS 0\SEMI
  \VAR y\GETS 0\SEMI
  (\IF(a)\THEN b\GETS 1\ELSE y\GETS 1\FI 
  \PAR
  \IF(y\lor b)\THEN a\GETS 1\FI)
\end{displaymath}
We argue that any execution with $(\DR{a}{1})$, $(\DR{b}{1})$, and
$(\DR{y}{0})$ must be cyclic.  The closure requirements require that
\begin{math}
  (\DW{a}{1})<(\DR{a}{1})
  \;\text{and}\;
  (\DR{b}{1})<(\DR{b}{1}).
\end{math}
Ignoring initialization, least ordered execution that includes all of these
actions is:
\[\begin{tikzpicture}[node distance=1em]
  \event{ra1}{\DR{a}{1}}{}
  \event{wb1}{\DW{b}{1}}{below=of ra1}
  \nonevent{wy1}{\DW{y}{1}}{left=of wb1}
  \event{rb1}{\DR{b}{1}}{right=4.5em of ra1}
  \event{ry0}{\DR{y}{0}}{right=of rb1}
  \event{wa1}{\DW{a}{1}}{below=of rb1}
  \po{ra1}{wb1}
  \po{rb1}{wa1}
  \rf{wa1}{ra1}
  \rf{wb1}{rb1}
\end{tikzpicture}\]
where the read of $a$ is ordering for $(\DW{b}{1})$ but
not $(\DW{y}{1})$, and the read of $b$ is ordering for $(\DW{a}{1})$ but the
read of $y$ is not.  $(\DW{y}{1})$ is crossed out, since its
precondition must imply $(\lnot a)[1/a]$, which is equivalent to $\FALSE$.
To avoid order from $(\DR{y}{0})$ to $(\DW{a}{1})$, we
have strengthened the predicate on $(\DW{a}{1})$ from $(y\lor b)$ to
$(y=0\land b=1)$.  Note that we cannot use this trick symmetrically to remove
the order from $(\DR{b}{1})$ to $(\DW{a}{1})$, since $b=1$ does not follow
from the initialization of $b$.


\subsection{Thread inlining}

One property one could ask of a model of shared memory is thread
inlining: any execution of $\sem{P\SEMI Q}$ is an execution of $\sem{P
  \PAR Q}$. This is \emph{not} a goal of our model, and indeed is not
satisfied, due to the different semantics of concurrent and sequential
memory accesses. We demonstrate this by considering an example from
the Java Memory Model~\cite{Manson:2005:JMM:1047659.1040336}, which shows that Java does not
satisfy thread inlining either.

The lack of thread inlining is related to the different dependency
relations introduced by sequential and concurrent access.
Recall from \S\ref{sec:sequential-memory} that the program
\verb`(x := 0; y := x+1;)` has execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
but that \verb`(x := 1; || y := x+1;)` has:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
That is, in the sequential case there is no dependency from the
write of $x$ to the write of $y$, but in the concurrent case there
is such a dependency.

This can be used to construct a counter-example to thread inlining, based on~\cite[Ex~11]{Manson:2005:JMM:1047659.1040336}:
\begin{verbatim}
  x := 0; if (x == 1) { z := 1; } else { x := 1; } || y := x; || x := y;
\end{verbatim}
This has no execution containing $(\DW z1)$. Any attempt to build such an execution
results in a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{rx1b}{\DR{x}{1}}{right=2.5em of wx1a}
  \event{wy1}{\DW{y}{1}}{right=of rx1b}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{wx1b}{\DW{x}{1}}{right=of ry1}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
  \po{rx1b}{wy1}
  \po{ry1}{wx1b}
  \rf{wy1}{ry1}
  \rf[out=160, in=30]{wx1b}{rx1a}
  \rf[out=160, in=30]{wx1b}{rx1b}
\end{tikzpicture}\]
Inlining the thread \verb|(y := x)| gives~\cite[Ex~12]{Manson:2005:JMM:1047659.1040336}:
\begin{verbatim}
  x := 0; if (x == 1) { z := 1; } else { x := 1; } y := x; || x := y;
\end{verbatim}
with execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{wx1b}{\DW{x}{1}}{right=of ry1}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
  \po{ry1}{wx1b}
  \rf{wy1}{ry1}
  \rf[out=160, in=30]{wx1b}{rx1a}
\end{tikzpicture}\]
To see why this execution exists, consider the program fragment:
\begin{verbatim}
  if (x == 1) { z := 1; } else { x := 1; } y := x;
\end{verbatim}
Removing the syntax sugar, this is:
\begin{verbatim}
  r1 := x; if (r1 == 1) {
    z := 1; r2 := x; y := r2; skip
  } else {
    x := 1; r3 := x; y := r3; skip
  }
\end{verbatim}
Now, $\sem{z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP}$
includes pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{r_1=1 \mid \DW{z}{1}}{}
  \event{wy1}{r_1=x=1 \mid \DW{y}{1}}{right=of wz1}
\end{tikzpicture}\]
and $\sem{x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP}$
includes pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1a}{r_1\neq 1 \mid \DW{x}{1}}{}
  \event{wy1}{r_1\neq 1 \mid \DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
so  $\sem{\IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{r_1=1 \mid \DW{z}{1}}{}
  \event{wx1a}{r_1\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{(r_1=x=1) \lor (r_1\neq1) \mid \DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
which means $\sem{\IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}[x/r_1]$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{x=1 \mid \DW{z}{1}}{}
  \event{wx1a}{x\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{(x=x=1) \lor (x\neq1)) \mid \DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
Now $(x=x=1) \lor (x\neq1)$ is a tautology, so this is just:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{x=1 \mid \DW{z}{1}}{}
  \event{wx1a}{x\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
and so $\sem{r_1 \GETS x\SEMI \IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{1=1 \mid \DW{z}{1}}{right=of rx1a}
  \event{wx1a}{1\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
\end{tikzpicture}\]
which simplifies to:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
\end{tikzpicture}\]
as required. The rest of the example is straightforward, and shows that our semantics
agrees with the JMM in not supporting thread inlining.



% \subsection{Word tearing}

% \todo{Remove this section, since it's not needed for transactions?}

% In \S\ref{sec:transactions}, we shall be considering transactional memory,
% and in \S\ref{sec:transactions} show that we can model a simplified version
% of an information flow attack on transactions. In order to model transactions,
% we need to consider actions that can write many memory locations at once,
% since this is part of the semantics of commitment. To lead up to this, we first
% consider a simpler scenario of many-location writes and reads, which is word
% tearing.

% In word tearing, a program contains a write instruction with data larger
% than the hardware word size, for example copying a byte array, or assigning
% a 64-bit float on a 32-bit architecture. For example, consider the program:
% \begin{verbatim}
%   (x := [0, 0];) || (x := [1, 1];) || (r := x;)
% \end{verbatim}
% This has executions in which the read of $x$ only reads from one of the writes,
% for example:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx00}{\DW{x}{[0,0]}}{}
%   \event{wx11}{\DW{x}{[1,1]}}{right=2.5em of wx00}
%   \event{rx00}{\DR{x}{[0,0]}}{right=2.5em of wx11}
%   \rf[out=20, in=160]{wx00}{rx00}
% \end{tikzpicture}\]
% but also has executions in which the read of $x$ reads from both writes,
% for example:
g% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx00}{\DW{x}{[0,0]}}{}
%   \event{wx11}{\DW{x}{[1,1]}}{right=2.5em of wx00}
%   \event{rx01}{\DR{x}{[0,1]}}{right=2.5em of wx11}
%   \rfx[out=20, in=160]{wx00}{x[0]}{rx01}
%   \rfx[out=-20, in=-160]{wx11}{x[1]}{rx01}
% \end{tikzpicture}\]
% Word tearing can occur, for example, in Java extended floating point~\cite{jmm},
% LLVM 64-bit instructions on 32-bit hardware~\cite{llvm}, or in
% JavaScript SharedArrayBuffers~\cite{js-sab}.

% \newcommand{\rfControl}[4][]{\draw[rf,#1](#2) .. controls (#3) .. (#4);}
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wx1}{\DW{x}{1}}{right=of wx0}
%   \event{wy0}{\DW{y}{0}}{right=2.5em of wx1}
%   \event{wy1}{\DW{y}{1}}{right=of wy0}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wy1}
%   \event{ry0}{\DR{y}{0}}{right=of rx1}
%   \event{ry1}{\DR{y}{1}}{right=2.5 em of ry0}
%   \event{rx0}{\DR{x}{0}}{right=of ry1}
%   \rf[out=20,in=160]{wx1}{rx1}
%   \rf[out=20,in=160]{wy0}{ry0}
%   \rf[out=340,in=200]{wy1}{ry1}
%   \coordinate (a) [below=of wy1];
%   \rfControl[out=340,in=200]{wx0}{a}{rx0}
%   \wk{wx0}{wx1}
%   \wk{wy0}{wy1}
%   \po{rx1}{ry0}
%   \po{ry1}{rx0}
% \end{tikzpicture}\]


% Batty section 4:
% \cite[\S4]{DBLP:conf/esop/BattyMNPS15},
% Example LB+ctrldata+ctrl-double (language must allow)
% r1=loadrlx(x) //reads 42
% if (r1 == 42)
%   storerlx(y,r1)

% r2=loadrlx(y) //reads 42
% if (r2 == 42)
%   storerlx (x,42)
% else
% storerlx (x,42)

% a:RRLX x=42 sb,dd,cd
% c:RRLX y=42 sb,cd
%   This is forbidden on hardware if compiled naively, as the architectures respect read-to-write control dependencies, but in practice compilers will collapse con- ditionals like that of the second thread, removing the control dependencies from the read of y to the writes of x and making the code identical to the previous example. As that example is allowed and observable on hardware (and we pre- sume that it would be impractical to outlaw such optimisation for C or C++), the language must also allow this execution. But this execution has a cycle in the union of reads-from and dependency, so we cannot simply exclude all those.
% Then one might hope for some other adaptation of the C/C++11 model, but the following example shows at least that there is no per-candidate-execution solution.
% Example LB+ctrldata+ctrl-single (language can and should forbid)
% r1=loadrlx(x) //reads 42 if (r1 == 42)
% storerlx (y,r1) r2=loadrlx (y) //reads 42 if (r2 == 42)
% a:RRLX x=42 sb,dd,cd
% rf
% b:WRLX y=42
% c:RRLX y=42 sb,cd
% rf
% d:WRLX x=42
% rf rf
% b:WRLX y=42 d:WRLX x=42
%   storerlx (x,42)
