\section{Examples}

\subsection{Sequential memory accesses}

In the semantics of memory, there are two very different ways memory
can be accessed: sequentially or concurrently. These are modelled
differently, since hardware and compilers give very different
guarantees about their behaviour.
In this section, we discuss the sequential semantics, and leave
the concurrent semantics to \S\ref{sec:concurrent-memory}.

Consider the program \verb`(x := 0; y := x+1;)`.  One execution of
this program is where the write to $y$ uses the sequential value of
$x$, which is $0$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
To see how this execution is modelled, we first
expand out the syntax sugar to get the program \verb`(x := 0; r := x; y := r+1; skip)`.
Now $\sem{\SKIP}$ is just $\{\emptyset\}$, and
$\sem{y \GETS r+1\SEMI \SKIP}$ is:
\[
   \bigcup_v\; (r+1=v \mid \DW yv) \prefix \sem{\SKIP}[v/y]
\]
which includes the case where $v$ is $1$:
\[
   (r+1=1 \mid \DW y1) \prefix \sem{\SKIP}[1/y]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{r+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
Now $\sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ is:
\[
   \sem{y \GETS r+1\SEMI \SKIP}[x/r] \cup
   \bigcup_v\; (\DR xv) \prefix \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
This has two cases, the sequential case
(which does not introduce a read action)
and the concurrent case (which does).
For the moment, we are interested in the sequential case, which is:
\[
   \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{x+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
Finally $\sem{x \GETS 0\SEMI r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ is:
\[
   \bigcup_v\; (0=v \mid \DW xv) \prefix \sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}[v/x]
\]
which includes the case where $v$ is $0$:
\[
   (0=0 \mid \DW x0) \prefix \sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}[0/x]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{0=0 \mid \DW{x}{0}}{}
  \event{wy1}{0+1=1 \mid \DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
all of whose preconditions are tautologies, so this has the expected behaviour:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
Note that $\DW x0$ does not read anything, and so there is no 
requirement of order between $(\DW x0)$ and $(\DW y1)$.

This example demonstrates how preconditions
capture the sequential semantics of memory.
In an execution containing an event with label
$(\aForm \mid \aAct)$, one way the precondition $\aForm$
can be discharged is by a write $\aLoc\GETS\aExp$,
which performs a substitution $[\aExp/\aLoc]$.
This is a variant of the usual Hoare semantics for
assignment, where if $\aCmd$ has preconditon $\aForm$
then $\aLoc\GETS\aExp\SEMI\aCmd$ has precondition
$\aForm[\aExp/\aLoc]$.

\subsection{Concurrent memory accesses}
\label{sec:concurrent-memory}

\subsection{No dependencies on writes}

Consider an example with two independent writes
\verb|(x := 1; y := 2;)|.
This has the semantics:
\[
  \bigcup_\aVal\; (1=\aVal \mid \DW x\aVal) \prefix \left(
    \bigcup_\bVal\; (2=\bVal \mid \DW y\aVal) \prefix \left(
      \{\emptyset\}
    \right)[2/y]
  \right)[1/x]
\]
which is the same as:
\[
  \bigcup_\aVal\; (1=\aVal \mid \DW x\aVal) \prefix
    \bigcup_\bVal\; (2=\bVal \mid \DW y\aVal) \prefix
      \{\emptyset\}
\]
which includes the case where $\aVal=1$ and $\bVal=2$:
\[
  (1=1 \mid \DW x1) \prefix
    (2=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
One of the executions this contains is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wx1}{wy2}
\end{tikzpicture}\]
but it also contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
and:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wy2}{wx1}
\end{tikzpicture}\]
since there is no requirement that
$(\DW{x}{1}) \le (\DW{y}{2})$.

Thus, the semantics of \verb|(x := 1; y := 2;)|
is the same as the semantics of \verb|(y := 2; x := 1;)|.

\subsection{Dependencies on reads}

Whereas write prefixing introduces no new dependencies,
read prefixing can. For example the program
\verb|(r := x; y := r+1;)| has semantics:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR x\aVal) \prefix \left(
    \bigcup_\bVal\; (r+1=\bVal \mid \DW y\aVal) \prefix \left(
      \{\emptyset\}
    \right)[r+1/y]
  \right)[x/r]
\]
which is the same as:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR x\aVal) \prefix
    \bigcup_\bVal\; (x+1=\bVal \mid \DW y\aVal) \prefix
      \{\emptyset\}
\]
which includes the case where $\aVal=1$ and $\bVal=2$:
\[
  (\TRUE \mid \DR x1) \prefix
    (x+1=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
Now, since $\TRUE$ implies $(x+1=2)[1/x]$, this contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
but since $\TRUE$ does not imply $(x+1=2)$,
we have the requirement that $(\DR{x}{1}) \le (\DW{y}{2})$.

This is in contrast to the program 
\verb|(r := x; y := r+2-r;)|, which has
semantics:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR x\aVal) \prefix
    \bigcup_\bVal\; (x+2-x=\bVal \mid \DW y\aVal) \prefix
      \{\emptyset\}
\]
Again, we consider the case where $\aVal=1$ and $\bVal=2$:
\[
  (\TRUE \mid \DR x1) \prefix
    (x+2-x=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
Now, since $\TRUE$ implies $(x+2-x=2)[1/x]$, this contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
but also $\TRUE$ implies $(x+2-x=2)$
(at least for arithmetic modulo $n$)
and so this also contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
\end{tikzpicture}\]
and:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{wy2}{rx1}
\end{tikzpicture}\]
Thus, the semantics of \verb|(r := x; y := x+2-x;)|
is the same as the semantics of \verb|(y := 2; r := x;)|.

\subsection{Dependencies on conditionals}

Conditionals introduce control dependencies, for example consider the program:
\begin{verbatim}
  r := z; if (r) { x := 1; } else { y := 2; }
\end{verbatim}
This has semantics:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR z\aVal) \prefix
    (z \neq 0 \mid \sem{\texttt{x := 1}}) \sqcup (z=0 \mid \sem{\texttt{y := 2}})
\]
Now $\sem{\texttt{x := 1}}$ contains any pomset of the form:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aForm \mid \DW{x}{1}}{}
\end{tikzpicture}\]
in particular it contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
and similarly $\sem{\texttt{y := 2}}$ contains any pomset of the form:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy2}{r=0 \mid \DW{y}{2}}{}
\end{tikzpicture}\]
and so $\sem{\texttt{if (r) \{ x := 1; \} else \{ y := 2; \}}}$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
  \event{wy2}{r=0 \mid \DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
Now, prefixing with $(\DR z\aVal)$ performs substitutions, for example
when $\aVal$ is $0$ we have:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=of rz0}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=30,in=150]{rz0}{wy2}
\end{tikzpicture}\]
and when $\aVal$ is $1$ we have:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]

\subsection{Relaxed memory}

The model includes concurrent memory accesses, which can introduce concurrent
reads-from. For example, the program:
\begin{verbatim}
  x := 1; || r := x;
\end{verbatim}
has an execution in which the write to $x$ does not justify the read from $x$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rxv}{\DR{x}{v}}{right=2.5 em of wx1}
\end{tikzpicture}\]
but also has an execution in which the write to $x$ does justify the read from $x$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
  \rf{wx1}{rx1}
\end{tikzpicture}\]
Since we are allowing events to be partially ordered, this gives a simple
model of relaxed memory, for example an independent read independent write
(IRIW) example is:
\begin{verbatim}
  x := 0; x := x+1; || y := 0; y := y+1; || if (x) { r := y; } || if (y) { s := x; }
\end{verbatim}
which includes the execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{right=2.5em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of ry0}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \rf[out=30,in=150]{wx1}{rx1}
  \rf[out=30,in=150]{wy0}{ry0}
  \rf[out=340,in=200]{wy1}{ry1}
  \rf[out=340,in=200]{wx0}{rx0}
  \po{wx0}{wx1}
  \po{wy0}{wy1}
  \po{rx1}{ry0}
  \po{ry1}{rx0}
\end{tikzpicture}\]
This model does not introduce thin-air reads (TAR),
for example the TAR pit is:
\begin{verbatim}
  x := y; || y := x;
\end{verbatim}
but an attempt to produce a value from thin air fails,
for the usual reason of producing a cycle in $\le$:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry42}{\DR{y}{42}}{}
  \event{wx42}{\DW{x}{42}}{below=of ry42}
  \event{rx42}{\DR{x}{42}}{right=2.5em of ry42}
  \event{wy42}{\DW{y}{42}}{below=of rx42}
  \po{ry42}{wx42}
  \po{rx42}{wy42}
  \rf{wx42}{rx42}
  \rf{wy42}{ry42}
\end{tikzpicture}\]
This cycle can be broken if one of the writes does not depend on the read, for example:
\begin{verbatim}
  x := y; || r := x; y := r+1-r;
\end{verbatim}
has execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{y}{1}}{}
  \event{wx1}{\DW{x}{1}}{below=of ry1}
  \event{rx1}{\DR{x}{1}}{right=2.5em of ry1}
  \event{wy1}{\DW{y}{1}}{below=of rx1}
  \po{ry1}{wx1}
  \rf{wx1}{rx1}
  \rf{wy1}{ry1}
\end{tikzpicture}\]
Note that $(\DR x1) \not\le (\DW y1)$, so this does not introduce a cycle.

This model of relaxed memory is simple, and does not model many features
such as coherence, non-release-acquire access, or memory fences, but it is
good enough for the examples in this paper. In particular, we use the fact that
relaxed memory is sensitive to data dependency to give a Spectre attack which
does not depend on timing in \S\ref{sec:info-flow-attack}.

\subsection{Speculative evaluation}

So far, the treatment of dependency has been fairly standard, we have included
aborted events in the semantics of programs, but they have not had any impact.
We shall now see that this is not always the case, that the execution of a conditional
can depend on the branch not taken.

Consider the program:
\begin{verbatim}
  r := z; if (r) { x := 1; } else { x := 1; }
\end{verbatim}
Many optimizers will consider it to be the same as:
\begin{verbatim}
  r := z; x := 1;
\end{verbatim}
and so there should not be a dependency between $(\DR z\aVal)$ and $(\DW x1)$.
The semantics of this program is:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR z\aVal) \prefix
    (z \neq 0 \mid \sem{\texttt{x := 1}}) \sqcup (z=0 \mid \sem{\texttt{x := 1}})
\]
so, as in the previous section, we have executions such as:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1a}{\DW{x}{1}}{right=of rz1}
  \nonevent{wx1b}{\DW{x}{1}}{right=of wx1a}
  \po{rz1}{wx1a}
  \po[out=30,in=150]{rz1}{wx1b}
\end{tikzpicture}\]
but we also have the execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
\end{tikzpicture}\]
To see why, consider $\aPSS_1 \sqcup \aPSS_2$ where:
\[
  \aPSS_1 = (z \neq 0 \mid \sem{\texttt{x := 1}}) \quad
  \aPSS_2 = (z=0 \mid \sem{\texttt{x := 1}})
\]
Now $\aPSS_1$ contains the pomset $\aPS_1$ where:
\[
  \Event_1 = \{0\} \qquad
  0 \le_1 0 \qquad
  \labelling_1(0) = (z \neq 0 \mid \DW x1)
\]
Similarly $\aPSS_2$ contains the pomset $\aPS_2$ where:
\[
  \Event_1 = \{0\} \qquad
  0 \le_1 0 \qquad
  \labelling_1(0) = (z = 0 \mid \DW x1)
\]
In particular, $\Event_1$ and $\Event_2$ overlap. One of the inhabitants
of $\aPSS_1 \sqcup \aPSS_2$ is $\aPS_0$ where:
\[
  \Event_0 = \{0\} \qquad
  0 \le_0 0 \qquad
  \labelling_0(0) = (\TRUE \mid \DW x1)
\]
which is the execution we are interested in.

We can now see the counterintuitive behavior of speculation,
there are programs such as
\verb|r := z; if (r) { x := 1; } else { x := 1; }| with
executions in which  $(\DW x1)$ is independent of $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
\end{tikzpicture}\]
while programs such as
\verb|r := z; if (r) { x := 1; } else { y := 2; }|
only have executions in which $(\DW x1)$ is dependent on $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]
so these programs have different dependency relations, depending
on conditional branches that were not taken. In \S\ref{sec:info-flow-attack}
we shall see that this has security implications, since relaxed
memory can observe dependency. The attack is similar to Spectre, so
we shall take a detour to see how Spectre can be modeled in this
setting.

\subsection{Spectre}

We give a simplified model of Spectre attacks, ignoring the details of
timing.  In this model, we extend programs with the ability to tell
whether a memory location has been touched (in practice this is
implemented using timing attacks on the cache). For example,
we can write a \verb|SPECTRE| program as:
\begin{verbatim}
    var a;
    if (isCapability(0)) { a[SECRET] := 1; }
    else if (touched a[0]) { x := 0; }
    else if (touched a[1]) { x := 1; }
\end{verbatim}
This is a low-security program, which is attempting to discover the
value of a high-security variable \verb|SECRET|. The low-security program
is allowed to attempt to escalate its privileges by providing a capability
which demonstrates that they are entitled to run high-security code:
\begin{verbatim}
    if (isCapability(c)) { ... escalated code ... }
    else { ... fallback code ... }
\end{verbatim}
In this case, the \verb|isCapability(0)| is false, so the fallback code
is executed. Unfortunately, the escalated code is speculatively
evaluated, which allows information to leak by testing for which
memory locations have been touched.

We model the \verb|touched| test by introducing a new read action
\textcolor{red}{(Why a read?)}
$(\DT{\aLoc})$ and defining:
\begin{eqnarray*}
  \sem{\IF \TOUCHED\aLoc\THEN \aCmd \ELSE \bCmd} & = & ((\DT\aLoc) \prefix \sem{\aCmd}) \sqcup \sem{\bCmd}
\end{eqnarray*}
The additional requirement we need to add for $\aLoc$-closure is:
\begin{itemize}
\item if $\labelling(\aEv)=(\aForm \mid \DT{\aLoc})$
  then there is $\bEv\not>\aEv$ with $\labelling(\bEv)=(\bForm \mid \DR{\aLoc}{\aVal})$
  or $\labelling(\bEv)=(\bForm \mid \DW{\aLoc}{\aVal})$.
\end{itemize}
For example, one execution of \verb|SPECTRE| is:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{rs}{\DR{\SEC}{1}}{}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
Putting this in parallel with a high-security write to \verb|SECRET| gives:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{1}}{}
  \nonevent{rs}{\DR{\SEC}{1}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
but due the requirement of \verb|a|-closure we do \emph{not} have:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{0}}{}
  \nonevent{rs}{\DR{\SEC}{0}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{0}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
Thus, the attacker has managed to leak the value of a high-security
location to a low-security one.

This shows how a (very abstract, untimed) model of Spectre attacks
using speculative evaluation can be modeled.

\subsection{Information flow attacks on relaxed memory}
\label{sec:info-flow-attack}

Consider an attacker program, again using security checks to
try to learn a \verb|SECRET|. Whereas \verb|SPECTRE| uses
hardware capabilities, which have to be modeled by adding
extra capabilities to the language, this new attacker works
by exploiting relaxed memory which can result in
unexpected information flows. The attacker program is:
\begin{verbatim}
  var x := 0; var y := 0;
  (
    y := x;
  ) || (
    r := y;
    if (isCapability(r)) { x := SECRET; }
    else { x := 1; z := r; }
  )
\end{verbatim}
In the case where \verb|SECRET| is $2$, this has many executions,
one of which is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry0}{\DR{y}{0}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \event{wz0}{\DW{z}{0}}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wz0}
  \po{rx1}{wy1}
  \po{ry0}{wx1}
  \po[out=25,in=150]{ry0}{wz0}
  \po[out=30,in=150]{ry0}{wx2}
  \rf[out=30,in=150]{wy0}{ry0}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
but there are no executions which exhibit
$(\DW{z}{1})$, since any attempt to do so
produces a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wz1}
  \po{rx1}{wy1}
  \po{ry1}{wx1}
  \po[out=25,in=150]{ry1}{wz1}
  \po[out=30,in=150]{ry1}{wx2}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
In the case where \verb|SECRET| is $1$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wz1}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
Note that in this case, there is no dependency from
$(\DR{y}{1})$ to $(\DW{x}{1})$, which is what makes this
execution possible. Thus, if the attacker sees
an execution with $(\DW{z}{1})$, they can conclude
that \verb|SECRET| is $1$, which is an information flow
attack.

This attack is not just an artifact of the model,
since the same behavior can be exhibited by
compiler optimizations. Consider the program fragment:
\begin{verbatim}
  r := y;
  if (isCapability(r)) { x := SECRET; }
  else { x := 1; z := r; }
\end{verbatim}
Now, in the case where \verb|SECRET| is a constant \verb|1|,
the compiler can inline it:
\begin{verbatim}
  r := y;
  if (isCapability(r)) { x := 1; }
  else { x := 1; z := r; }
\end{verbatim}
lift the assignment to \verb|x| out of the \verb|if| statement:
\begin{verbatim}
  r := y; x := 1;
  if (isCapability(r)) { }
  else { z := r; }
\end{verbatim}
and then perform independent read/write reordering:
\begin{verbatim}
  x := 1; r := y;
  if (isCapability(r)) { }
  else { z := r; }
\end{verbatim}
After these optimizations, a sequentially consistent execution
exhibits $(\DW{z}{1})$.

\subsection{Fences and release/acquire synchronization}

We assume a subsets of release actions %$\Rel\subseteq\Act$
and acquire actions. % $\Acq\subseteq\Act$.
Reads, writes and touches in neither release nor acquire.

We say that the action $(\DR\aLoc\aVal)$ reads $\aLoc$ from $\aVal$.
Likewise, $(\DR\aLoc\aVal)$ writes $\aLoc$ to $\aVal$.  The touch action
$(\DT\aLoc)$ neither reads nor writes.  These notions lift to events; for example, $\aEv$
reads $\aLoc$ from $\aVal$ if $\labelling{\aEv}$ reads $\aLoc$ from $\aVal$.

Define $\freads(\aEv) = \freads(\aAct)$ when $\labelling(\aEv) = (\aForm \mid \aAct)$.
Likewise $\fwrites(\aEv)$.
\begin{definition}
  An \emph{rf-pomset} is a pomset together with a relation
  $\mathord{\RF} \subseteq \mathord{<}$.
\end{definition}
\begin{definition}
  An rf-pomset is $\aLoc$-closed if
  for $\aEv\in\Event$ with $\labelling(\aEv)=(\aForm \mid \aAct)$:
  \begin{itemize}
  \item $\aForm$ is independent of $\aLoc$, and
  \item if $\aEv$ reads $\aLoc$ at $\aVal$, then there is some
    $(\bEv,\aEv) \in \RF$ such that
    \begin{itemize}
    \item $\bEv$ writes $\aLoc$ at $\aVal$ and
    \item there is no $\bEv < \cEv < \aEv$ such that $\cEv$ writes $\aLoc$.
    \end{itemize}
  \end{itemize}
\end{definition}

Now the general definition of prefixing:

Let $(\phi \mid \aAct) \prefix \aPSS$ be the set $\aPSS'$ where
$\aPS'\in\aPSS'$ whenever there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{0\}$,
\item $\RF' = \RF$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item $\labelling'(0) = (\bForm \mid \aAct)$, where $\bForm$ implies $\aForm$, 
% \item if $\labelling(\aEv) = (\bForm \mid \bAct)$ and $\aAct$ sees nothing
%   then $\labelling'(\aEv) = (\bForm' \mid \bAct)$ and $\bForm'$ implies $\bForm$, and
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then
  $\labelling'(\aEv) = (\bForm' \mid \bAct)$ and either $\bForm'$ implies
  $\bForm$ or
  $0 \le' \aEv$ and $\bForm'$ implies $\bForm[\vec{\aVal}/\vec{\aLoc}]$,
  where $\aAct$ sees $\vec{\aLoc}$ at $\vec{\aVal}$,
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ and $\bAct$ is a release then $0
  \le' \aEv$, and
\item if $\aAct$ is an acquire then $0 \le' \aEv$.  
\end{itemize}
The last two conditions are new.  The rest are the same as before, combining
read and write.   



Publication example:
\begin{alltt}
    var x; var f; x:=0; f:=0; fence; (x:=1; \REL{f}:=1;  ||  r:=\ACQ{f}; s:=x;)
\end{alltt}
We disallow the execution where \texttt{r==1} and \texttt{s!=1}

We model fences and release/acquire synchronization by introducing the
following actions:
\begin{itemize}
\item $(\DF)$ is both a release and an acquire action
\item $(\DWRel{\aLoc}{\aVal})$ is a release action, which writes $\aLoc$ at $\aVal$.
\item $(\DRAcq{\aLoc}{\aVal})$ is an acquire action, which reads $\aLoc$ at $\aVal$.
\end{itemize}
% \begin{itemize}
% \item Let $(\phi \mid \DWRel\aLoc\aVal) \prefix \aPSS$ be defined as
%   $(\phi \mid \DW\aLoc\aVal) \prefix \aPSS$.  
% \item Let $(\phi \mid \DRAcq\aLoc\aVal) \prefix \aPSS$ be defined as
%   $(\phi \mid \DR\aLoc\aVal) \prefix \aPSS$, requiring additionally that
%   $0 \le' \aEv$.
% Let $(\phi \mid \DF) \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
% there is $\aPS\in\aPSS$ such that:
% \begin{itemize}
% \item $\Event' = \Event \cup \{0\}$,
% \item $\RF' = \RF$,
% \item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
% \item $0 \le' \aEv$, and
% \item $\labelling'(0) = (\aForm, \DF\aLoc\aVal)$, where $\bForm$ implies $\aForm$, and
% \item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) = (\bForm \mid \aAct)$.
% \end{itemize}
% \end{itemize}
\begin{eqnarray*}
  \sem{\FENCE\SEMI \aCmd} & = & (\TRUE \mid \DF) \prefix \sem{\aCmd} \\
  \sem{\REL\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; (\aExp=\aVal \mid \DWRel\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc] \\
  \sem{\aReg\GETS\ACQ\aLoc\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; (\TRUE \mid \DRAcq\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] 
\end{eqnarray*}
There are no additional requirements for $\aLoc$-closure is.

\subsection{Transactions}

We present a model of weakly isolated transactions.  To get strong isolation,
we need to make $\DB$ record the reads, symmetrically to $\DC{}{}$; we also need
to require in parallel composition that any order in-to/out-of a
transactional event be lifted to the corresponding $\DB$/$\DC{}{}$

\begin{alltt}
  var x; var f; x:=0; f:=0; fence; 
     x:=1; (begin; f:=1; f:=2; end;) || (begin; r:=f; end; s:=x;)
\end{alltt}
$\END\SEMI \aCmd$ is sugar for $\IFCOMMITTHEN \aCmd \ELSE \aCmd$.

\begin{itemize}
\item $(\DB)$ is an acquire action
\item %$(\DCn{\aLoc}{\aVal})$
  $(\DC{\vec\aLoc}{\vec\aVal})$
  is a release action which writes $\vec\aLoc$ at $\vec\aVal$
\end{itemize}

\begin{eqnarray*}
  \sem{\BEGIN\SEMI \aCmd}
  & = & (\TRUE \mid \DB) \prefix \sem{\aCmd}
  \\
  \sem{\IFCOMMITTHEN \aCmd \ELSE \bCmd}
  & = & \textstyle\bigcup_{\aForm\,\text{implies}\,\vec\aLoc=\vec\aVal}\;
        ((\aForm \mid \DC{\vec\aLoc}{\vec\aVal}) \prefix (\aForm \mid \sem{\aCmd}))
        \sqcup  (\lnot\aForm \mid \sem{\bCmd})
\end{eqnarray*}

\begin{definition}
  An rf-pomset is transaction-closed if the $\DB$ and $\DC{}{}$ actions with
  satisfiable preconditions are totally ordered by $<$.
\end{definition}

For example, the semantics of
\begin{alltt}
  x:=1; begin; x:=2; end; y:=x;
\end{alltt}
includes
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{b}{\DB}{right=of wx1}
  \event{wx2}{\DW{x}{2}}{right=of b}
  \event{c}{\DC{x}{2}}{right=of wx2}
  \event{wy2}{\DW{y}{2}}{right=of c}
  \nonevent{wy1}{\DW{y}{1}}{below=of wy2}
  \po{b}{wx2}
  \po[bend right]{b}{wy1}
  \po[bend left]{b}{wy2}
  \po{wx2}{c}
  \po[bend left]{wx1}{c}
  %\po{rz0}{wy2}
\end{tikzpicture}\]
and
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{b}{\DB}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of b}
  \nonevent{c}{\DC{x}{2}}{right=of wx2}
  \nonevent{wy2}{\DW{y}{2}}{right=of c}
  \event{wy1}{\DW{y}{1}}{below=of wy2}
  \po{b}{wx2}
  \po[bend right]{b}{wy1}
  \po[bend left]{b}{wy2}
  \po{wx2}{c}
  \po[bend left]{wx1}{c}
  %\po{rz0}{wy2}
\end{tikzpicture}\]


% Note: we could also include a transaction factory, and close the factory.
% \begin{alltt}
%   TransactionFactory T; var x; var f; x:=0; f:=0; fence; 
%      x:=1; (begin T; f:=1; f:=2; end T;) || (begin T; r:=f; end T; s:=x;)
% \end{alltt}


% Local Variables:
% TeX-master: "paper"
% End:
