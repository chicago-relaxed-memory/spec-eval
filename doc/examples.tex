\section{Examples}
\label{sec:examples}

In this section, we shall start off by giving some basic examples,
and then show how three different information flow attacks can be
modeled. We cover Spectre in \S\ref{sec:spectre}, new attacks
on compiler optimizations in \S\ref{sec:info-flow-attack}--\ref{sec:dse},
and attacks on transactions in \S\ref{sec:transactions}.

\subsection{Sequential memory accesses}
\label{sec:sequential-memory}

In the semantics of memory, there are two very different ways memory
can be accessed: sequentially or concurrently. These are modeled
differently, since hardware and compilers give very different
guarantees about their behavior.
In this section, we discuss the sequential semantics, and leave
the concurrent semantics to \S\ref{sec:concurrent-memory}.

Consider the program $(\aLoc\GETS0\SEMI \bLoc\GETS\aLoc+1)$.  One execution of
this program is where the write to $y$ uses the sequential value of
$x$, which is $0$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
To see how this execution is modeled, we first
expand out the syntax sugar to get the program
$(\aLoc\GETS0\SEMI \aReg\GETS\aLoc\SEMI \bLoc\GETS\aReg+1\SEMI\SKIP)$
Now $\sem{\SKIP}$ is just $\{\emptyset\}$, and
$\sem{y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (r+1=1) \guard (\DW y1) \prefix \sem{\SKIP}[1/y]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{r+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
expressing that this program can write $1$ to $y$,
as long as the precondition $(r+1=1)$ is satisfied.
Now $\sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$
has two cases, the sequential case
(which does not introduce a read action)
and the concurrent case (which does).
For the moment, we are interested in the sequential case:
\[
   \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{x+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
In this pomset, the precondition is $(x+1=1)$, which specifies a property
of the thread-local value of $x$.
Finally $\sem{x \GETS 0\SEMI r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (0=0) \guard (\DW x0) \prefix \sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}[0/x]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{0=0 \mid \DW{x}{0}}{}
  \event{wy1}{0=0\land0+1=1 \mid \DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
all of whose preconditions are tautologies, so this has the expected behavior:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
There is no dependency between $(\DW x0)$ and $(\DW y1)$,
since $(0=0\land0+1=1)$ is independent of $\aLoc$.

This example demonstrates how preconditions
capture the sequential semantics of memory.
In an execution containing an event with label
$(\aForm \mid \aAct)$, one way the precondition $\aForm$
can be discharged is by an assignment $\aLoc\GETS\aExp$,
which performs a substitution $[\aExp/\aLoc]$.
This is a variant of the Hoare semantics of
assignment \cite{Hoare:1969:ABC:363235.363259}, where if $\aCmd$ has precondition $\aForm$
then $\aLoc\GETS\aExp\SEMI\aCmd$ has precondition
$\aForm[\aExp/\aLoc]$.

\subsection{Concurrent memory accesses}
\label{sec:concurrent-memory}

We now turn to the case of concurrent accesses to memory.
Consider the program %a concurrent version of the program from \S\ref{sec:sequential-memory}:
$(\aLoc\GETS1 \PAR \bLoc\GETS\aLoc+1)$.
In executions of this program, it is possible for the second thread to 
perform a concurrent read of $x$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
To see how this execution is modeled, we first
expand out the syntax sugar to get the program
$(\aLoc\GETS1\SEMI\SKIP \PAR \aReg\GETS\aLoc\SEMI \bLoc\GETS\aReg+1\SEMI\SKIP)$.
As before, $\sem{y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (r+1=2) \guard (\DW y2) \prefix \sem{\SKIP}[2/y]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy2}{r+1=2 \mid \DW{y}{2}}{}
\end{tikzpicture}\]
As before, $\sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ has two cases.
We are now interested in the concurrent case, which includes:
\[
   (\DR x1) \prefix \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
Note that $(\DR x1)$ reads $1$ from $x$, and while
$(x+1=2)[1/x]$ is a tautology,
$(x+1=2)$ is not,
and so there is a dependency
$(\DR x1) < (\DW y2)$.

Now, $\sem{x \GETS 1\SEMI \SKIP}$ includes the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
\end{tikzpicture}\]
and so $\sem{x \GETS 1\SEMI \SKIP \PAR r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
as expected, including a reads-from dependency
$(\DW x1) < (\DR x1)$.

This example demonstrates how read and write events
capture the concurrent semantics of memory.
In an execution containing an event with label
$(\DR \aLoc\aVal)$, if the execution is
$\aLoc$-closed, then there must be an event
it reads from, for example one labelled
$(\DW \aLoc\aVal)$.

\subsection{Control dependencies}
\label{sec:control-dep}

Conditionals introduce control dependencies, for example consider the program:
\[
  \aReg\GETS\cLoc\SEMI
  \IF(\aReg)\THEN \aLoc\GETS1 \ELSE \bLoc\GETS2 \FI
\]
This includes executions in which the false branch is taken:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=of rz0}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=30,in=150]{rz0}{wy2}
\end{tikzpicture}\]
and ones where the true branch is taken:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]
In both cases, we record the actions in the branch that was
not taken. This is a novel feature of this model, and is
intended to capture speculative evaluation. In \S\ref{sec:spectre}
we will show how this model captures Spectre-like information
flow attacks, once the attacker is provided with the ability to
observe such speculations.

To see how these executions are modeled, consider the semantics of
$\sem{x\GETS 1\SEMI\SKIP}$, which contains any pomset of the form:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aForm \mid \DW{x}{1}}{}
\end{tikzpicture}\]
in particular it contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
Similarly $\sem{y\GETS 2\SEMI\SKIP}$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy2}{r=0 \mid \DW{y}{2}}{}
\end{tikzpicture}\]
and so $\sem{\IF(r)\THEN x\GETS 1\SEMI\SKIP \ELSE y\GETS 2\SEMI\SKIP \FI}$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
  \event{wy2}{r=0 \mid \DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
Now, the semantics of concurrent read performs substitutions, for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{0\neq0 \mid \DW{x}{1}}{right=of rz0}
  \event{wy2}{0=0 \mid \DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=25,in=155]{rz0}{wy2}
\end{tikzpicture}\]
which gives the required pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=of rz0}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=30,in=150]{rz0}{wy2}
\end{tikzpicture}\]
Note that the precondition $r=0$ is dependent on $r$,
and so there is a dependency $(\DR z0) < (\DW y2)$,
modeling the control dependency introduced by the conditional.

\subsection{Control independencies}

In most models of control dependencies, the dependency relation
is syntactic, based on whether the action occurs inside syntactically
inside a conditional. In contrast, the notion in this model is
semantic: if an action can occur on both sides of a conditional,
there is no control dependency. Consider a variant of the example
from \S\ref{sec:control-dep}:
\[
  \aReg\GETS\cLoc\SEMI
  \IF(\aReg)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS1 \FI
\]
This has the expected execution in which the control
dependencies exist:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{nwx1}{\DW{x}{1}}{right=of rz0}
  \event{wx1}{\DW{x}{1}}{right=of nwx1}
  \po{rz0}{nwx1}
  \po[out=30,in=150]{rz0}{wx1}
\end{tikzpicture}\]
but it also has an execution in which the two writes
of $1$ to $x$ are merged, resulting in no dependency:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz0}
\end{tikzpicture}\]
To see how this arises,
consider the definition of $\sem{\IF(r)\THEN x\GETS1\SEMI\SKIP \ELSE x\GETS1\SEMI\SKIP \FI}$:
\[\begin{array}{rl}
   \aPSS_1 \parallel \aPSS_2 \quad\mbox{where}\quad&
   \aPSS_1 = (r\neq 0) \guard \sem{x\GETS1\SEMI\SKIP} \\&
   \aPSS_2 = (r=0) \guard \sem{x\GETS1\SEMI\SKIP}
\end{array}\]
Now, one pomset in $\aPSS_1$ is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
that is $\aPS_1$ where:
\[
  \Event_1 = \{\aEv\} \quad
  \labelling_1(\aEv) = (r\neq 0, \DW x1)
\]
and similarly, one pomset in $\aPSS_2$ is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r=0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
that is $\aPS_2$ where:
\[
  \Event_2 = \{\aEv\} \quad
  \labelling_2(\aEv) = (r= 0, \DW x1)
\]
Crucially, in the definition of $\aPSS_1 \parallel \aPSS_2$
there is \emph{no} requirement that $\Event_1$ and $\Event_2$ are disjoint,
and in this case they overlap at $\aEv$. As a result, one pomset in
$\aPSS_1\parallel\aPSS_2$ is $\aPS_0$ where:
\[
  \Event_0 = \{\aEv\} \quad
  \labelling_0(\aEv) = (r\neq0 \lor r=0, \DW x1)
\]
that is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
\end{tikzpicture}\]
Note that this pomset has no precondition dependent on $r$,
since $(r\neq0 \lor r=0)$ does not depend on $r$, which is why
we end up with an execution without a control dependency:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz0}
\end{tikzpicture}\]
This semantics captures compiler optimizations which may, for example,
merge code executed on both branches of a conditional, or hoist
constant assignments out of loops.

We can now see the counterintuitive behavior of conditionals
in the presence of control dependencies.
There are programs such as
\(
  (\IF(\cLoc)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS1 \FI)
\)
with executions in which  $(\DW x1)$ is independent of $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
\end{tikzpicture}\]
while programs such as
\(
  (\IF(\cLoc)\THEN \aLoc\GETS1 \ELSE \bLoc\GETS2 \FI)
\)
only have executions in which $(\DW x1)$ is dependent on $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]
These programs have executions with different dependency relations, depending only
on conditional branches that were \emph{not} taken. In \S\ref{sec:info-flow-attack}
we shall see that this has security implications, since relaxed
memory can observe dependency. The attack is similar to Spectre, so
we shall take a detour to see how Spectre can be modeled in this
setting.

\subsection{Spectre}
\label{sec:spectre}

We give a simplified model of Spectre attacks, ignoring the details of
cache timing.  In this model, we extend programs with the ability to tell
whether a memory location has been touched (in practice this is
implemented using timing attacks on the cache). For example,
we can model Spectre by:
\[\begin{array}{l}
  \VAR a\SEMI \IF(\CANREAD(\SEC))\THEN a[\SEC]\GETS1
  \brELIF(\TOUCHED a[0])\THEN x\GETS0
  \brELIF(\TOUCHED a[1])\THEN x\GETS1 \FI
\end{array}\]
This is a low-security program, which is attempting to discover the
value of a high-security variable $\SEC$. The low-security program
is allowed to attempt to escalate its privileges by checking that it is
allowed to read a high-security variable:
\[\begin{array}{l}
  \IF(\CANREAD(\SEC))\THEN \mbox{code allowed to read $\SEC$}
  \brELSE \mbox{code not allowed to read $\SEC$} \FI
\end{array}\]
In this case, $\CANREAD(\SEC)$ is false, so the fallback code
is executed. Unfortunately, the escalated code is speculatively
evaluated, which allows information to leak by testing for which
memory locations have been touched.

We model the $\TOUCHED$ test by introducing a new action
$(\DT{\aLoc})$, and defining:
\[\begin{array}{l}
  \sem{\IF (\TOUCHED\aLoc) \THEN \aCmd \ELSE \bCmd \FI} \\[\jot]\quad =  ((\DT\aLoc) \prefix \sem{\aCmd}) \cup \sem{\bCmd}
\end{array}\]
Implementations of $\TOUCHED$ use cache timing, but their success can be modeled
without needing to be precise about such microarchitectural details:
\begin{itemize}
\item if $\labelling(\aEv)=(\aForm \mid \DT{\aLoc})$
  then there is $\bEv\gtN\aEv$
  where $\bEv$ reads or writes $\aLoc$.
\end{itemize}
Note that there is no requirement that $\bEv$ be satisfiable,
and indeed Spectre has the execution:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{rs}{\DR{\SEC}{1}}{}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \po{rs}{wa}
  \wk{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
but (assuming a successful implementation of $\TOUCHED$) \emph{not}:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{rs}{\DR{\SEC}{0}}{}
  \nonevent{wa}{\DW{a[0]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \po{rs}{wa}
  \wk{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
Thus, the attacker has managed to leak the value of a high-security
location to a low-security one: if $(\DW x1)$ is observed, the \verb|SECRET|
must have been 1.

This shows how our model of speculation can express
the way in which Spectre-like attacks bypass dynamic security checks,
without giving a treatment of microarchitecture.

\subsection{Relaxed memory}
\label{sec:relaxed-memory}

In \S\ref{sec:info-flow-attack} we present an information flow attack
on relaxed memory, similar to Spectre in that it relies on speculative
evaluation. Unlike Spectre it does not depend on timing attacks,
but instead is based on the sensitivity of relaxed memory to data
dependencies. % For this reason, we present a simple model of relaxed
% memory, which is strong enough to capture this attack.

Our model includes concurrent memory accesses, which can introduce concurrent
reads-from. 
Since we are allowing events to be partially ordered, this gives a simple
model of relaxed memory.  For example an independent read independent write
(IRIW) example is:
\[\begin{array}{l}
  x\GETS0\SEMI x\GETS x+1
  \PAR
  y\GETS0\SEMI y\GETS y+1
\\{}
  \PAR
  r_1\GETS x\SEMI r_2\GETS y
  \PAR
  s_1\GETS y\SEMI s_2\GETS x
\end{array}\]
which includes the execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{right=2.5em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{ry1}{\DR{y}{1}}{below=4ex of wx0}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of rx0}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \rf{wx1}{rx1}
  \rf{wy0}{ry0}
  \rf[out=210,in=30]{wy1}{ry1}
  \rf{wx0}{rx0}
  \wk{rx0}{wx1}
  \wk{ry0}{wy1}
\end{tikzpicture}\]
This model does not introduce thin-air reads (TAR).
For example the TAR pit
\((
  x\GETS y \PAR y \GETS x
)\)
fails to produce a value for $x$ from thin air
since this produces a cycle in $\le$, as shown on the left below:
\begin{align*}
\begin{tikzpicture}[node distance=1em]
  \event{ry42}{\DR{y}{42}}{}
  \event{wx42}{\DW{x}{42}}{below=of ry42}
  \event{rx42}{\DR{x}{42}}{right=2.5em of ry42}
  \event{wy42}{\DW{y}{42}}{below=of rx42}
  \po{ry42}{wx42}
  \po{rx42}{wy42}
  \rf{wx42}{rx42}
  \rf{wy42}{ry42}
\end{tikzpicture}
&&
\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{y}{1}}{}
  \event{wx1}{\DW{x}{1}}{below=of ry1}
  \event{rx1}{\DR{x}{1}}{right=2.5em of ry1}
  \event{wy1}{\DW{y}{1}}{below=of rx1}
  \po{ry1}{wx1}
  \rf{wx1}{rx1}
  \rf{wy1}{ry1}
\end{tikzpicture}
\end{align*}
This cycle can be broken by removing a dependency. For example
\((
  x\GETS y \PAR r\GETS x\SEMI y \GETS r+1-r
)\)
has the execution on the right above.
% \[\begin{tikzpicture}[node distance=1em]
%   \event{ry1}{\DR{y}{1}}{}
%   \event{wx1}{\DW{x}{1}}{below=of ry1}
%   \event{rx1}{\DR{x}{1}}{right=2.5em of ry1}
%   \event{wy1}{\DW{y}{1}}{below=of rx1}
%   \po{ry1}{wx1}
%   \rf{wx1}{rx1}
%   \rf{wy1}{ry1}
% \end{tikzpicture}\]
Note that $(\DR x1) \not\le (\DW y1)$, so this does not introduce a cycle.

Although it is not the primary focus of this paper, our model may be an
attractive model of relaxed memory.  Many prior models either permit
thin-air executions that our model forbids or forbid desirable executions
that our model permits.
%% In \S\ref{sec:logic}, we develop a logic which allows us to prove that our
%% semantics forbids thin air examples that are permitted by prior speculative
%% models
%% \cite{Manson:2005:JMM:1047659.1040336,DBLP:conf/esop/JagadeesanPR10,DBLP:conf/popl/KangHLVD17}.
Our model passes all of the causality test cases
\cite{PughWebsite}.
%% Significantly, this
%% includes test case 9, which is forbidden by \cite{DBLP:conf/lics/JeffreyR16},
%% one of the few models that disallows the thin air example from
%% \S\ref{sec:logic}.  We present this test case in the appendix, where we also
%% discuss the thread inlining examples from
%% \cite{Manson:2005:JMM:1047659.1040336}.

\citet{DBLP:conf/esop/BattyMNPS15} showed that the thin-air problem has
no per-candidate-execution solution for C++.  This result does not apply to
our model, which has a different notion of dependency.
% as the semantics of a conditional can depend on the semantics
% of both branches.

\subsection{Information flow attacks on relaxed memory}
\label{sec:info-flow-attack}

Consider an attacker program, again using dynamic security checks to
try to learn a \verb|SECRET|. Whereas \verb|SPECTRE| uses
hardware capabilities, which have to be modeled by adding
extra capabilities to the language, this new attacker works
by exploiting relaxed memory which can result in
unexpected information flows. The attacker program is:
\[\begin{array}[t]{@{}l}
  \VAR x\GETS0\SEMI \VAR y\GETS0\SEMI\\\quad
    y\GETS x
  \PAR\begin{array}[t]{@{}l}
    \IF(y\EQ0)\THEN x\GETS1
    \brELIF(\CANREAD(\SEC))\THEN x\GETS\SEC
    \brELSE x\GETS1\SEMI z\GETS1 \FI
\end{array}\end{array}\]
In the case where $\SEC$ is $2$, this has many executions,
one of which is:
\[\begin{tikzpicture}[node distance=1em]
  \event{ix}{\DW{x}{0}}{}
  \event{iy}{\DW{y}{0}}{right=of ix}
  \event{rx0}{\DR{x}{0}}{below=of wx0}
  \event{wy0}{\DW{y}{0}}{right=of rx0}
  \event{ry0}{\DR{y}{0}}{below=of wy0}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \nonevent{wx2}{\DW{x}{2}}{right=of wx1}
  \nonevent{wz1}{\DW{z}{1}}{right=of wx2}
  \po{rx0}{wy0}
  \po{ry0}{wx1}
  \po[out=30,in=150]{ry0}{wz1}
  \po[out=25,in=155]{ry0}{wx2}
  \rf{ix}{rx0}
  \rf{wy0}{ry0}
  \wk{iy}{wy0}
\end{tikzpicture}\]
but there are no executions which exhibit
$(\DW{z}{1})$, since any attempt to do so
produces a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{ix}{\DW{x}{0}}{}
  \event{iy}{\DW{y}{0}}{right=of ix}
  \event{rx1}{\DR{x}{1}}{below=of ix}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{below=of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \nonevent{wx2}{\DW{x}{2}}{right=of wx1}
  \event{wz1}{\DW{z}{1}}{right=of wx2}
  \po{rx1}{wy1}
  \po{ry1}{wx1}
  \po[out=30,in=150]{ry1}{wz1}
  \po[out=25,in=155]{ry1}{wx2}
  \rf[in=-90,out=-150]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=-20,in=90]{ix}{wx1}
  \wk[out=-20,in=120]{ix}{wx2}
  \wk{iy}{wy1}
\end{tikzpicture}\]\vskip-\bigskipamount\noindent
In the case where \verb|SECRET| is $1$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{ix}{\DW{x}{0}}{}
  \event{iy}{\DW{y}{0}}{right=of ix}
  \event{rx1}{\DR{x}{1}}{below=of ix}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{below=of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wz1}
  \rf[in=-90,out=-150]{wx1}{rx1}
  \rf{wy1}{ry1}
  \wk[out=-20,in=90]{ix}{wx1}
  \wk[out=-20,in=120]{ix}{wx2}
  \wk{iy}{wy1}
\end{tikzpicture}\]\vskip-\bigskipamount\noindent
Note that in this case, there is no dependency from
$(\DR{y}{1})$ to $(\DW{x}{1})$.  This lack of dependency makes the
execution possible. Thus, if the attacker sees
an execution with $(\DW{z}{1})$, they can conclude
that \verb|SECRET| is $1$, which is an information flow
attack.

This attack is not just an artifact of the model,
since the same behavior can be exhibited by
compiler optimizations. Consider the program fragment:
\[\begin{array}{l}
    \IF(y = 0)\THEN x\GETS1
    \brELIF(\CANREAD(\SEC))\THEN x\GETS\SEC
    \brELSE x\GETS1\SEMI z\GETS1 \FI
\end{array}\]
In the case where \verb|SECRET| is a constant \verb|1|,
the compiler can inline it
and lift the assignment to $x$ out of the $\IF$ statement:
\[\begin{array}{l}
    x\GETS1\SEMI
    \IF(y = 0)\THEN
    \brELIF(\CANREAD(\SEC))\THEN
    \brELSE z\GETS1 \FI
\end{array}\]
After these optimizations, a sequentially consistent execution
exhibits $(\DW{z}{1})$. We discuss the practicality of this attack
further in \S\ref{sec:experiments}.

\subsection{Dead store elimination}
\label{sec:dse}

A common compiler optimization is \emph{dead store elimination},
in which writes are omitted if they will be overwritten by a subsequent
write later in the same thread. We can model eliminated writes
by ones with an unsatisfiable precondition. For example,
one execution of $(x \GETS 1\SEMI x \GETS 2) \PAR (r \GETS x)$ is:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{wx1}{\DW{x}{1}}{}
  \event{wx2}{\DW{x}{2}}{right=of wx1}
  \event{rx2}{\DR{x}{2}}{right=2.5em of wx2}
  \wk{wx1}{wx2}
  \rf{wx2}{rx2}
\end{tikzpicture}\]
Recall that for any satisfiable $\aEv$, if $\aEv$ reads $\aLoc$ from $\bLoc$
then $\bEv$ is satisfiable. This means that, although we can eliminate
$(\DW{x}{1})$ we cannot eliminate $(\DW{x}{2})$.

One heuristic that a compiler might adopt is to only eliminate
writes that are guaranteed to be followed by another write
to the same variable. This can be formalized by saying that
a write event $\bEv$ is eliminable if
there is a tautology $\aEv \ltN \bEv$
which writes to the same location.
A model of dead store elimination is one where,
in every pomset, every eliminable event is unsatisfiable.
This model includes the example above.

Note that if dead store
elimination is \emph{always} performed, then there is an information
flow attack similar to the one in \S\ref{sec:info-flow-attack}. Consider
the program:
\[\begin{array}[t]{@{}l}
    y\GETS x
  \PAR\begin{array}[t]{@{}l}
    x\GETS 1\SEMI\\
    \IF(\CANREAD(\SEC))\THEN \IF(\SEC)\THEN x\GETS 2\FI
    \brELSE x\GETS 2\FI
\end{array}\end{array}\]
In the case that \verb|SECRET| is $0$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{wx1}{\DW{x}{1}}{right=2.5em of wy1}
  \event{wx2}{\aForm \mid \DW{x}{2}}{right=of wx1}
  \rf[out=160,in=20]{wx1}{rx1}
  \po{rx1}{wy1}
  \wk{wx1}{wx2}
\end{tikzpicture}\]
where $\aForm$ is ($\lnot$\verb|canRead(SECRET)|),
which is not a tautology, and so the $(\DW{x}{1})$ event is not eliminated.
In the case that \verb|SECRET| is not $0$, the matching execution
is:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx2}{\DR{x}{2}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx2}
  \nonevent{wx1}{\DW{x}{1}}{right=2.5em of wy2}
  \event{wx2}{\DW{x}{2}}{right=of wx1}
  \rf[out=160,in=20]{wx2}{rx2}
  \po{rx2}{wy2}
  \wk{wx1}{wx2}
\end{tikzpicture}\]
Now the $(\DW{x}{2})$ event is a guaranteed write, so the $(\DW{x}{1})$
is eliminated, and so cannot be read.
In the case that the attacker can rely on dead store
elimination taking place, this is an information flow: if the attacker observes
$x$ to be $1$, then they know \verb|SECRET| is $0$. We return to this attack
in \S\ref{sec:experiments}.


% Local Variables:
% TeX-master: "paper"
% End:
