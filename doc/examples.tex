\section{Examples}
\label{sec:examples}

\subsection{Sequential memory accesses}
\label{sec:sequential-memory}

In the semantics of memory, there are two very different ways memory
can be accessed: sequentially or concurrently. These are modelled
differently, since hardware and compilers give very different
guarantees about their behaviour.
In this section, we discuss the sequential semantics, and leave
the concurrent semantics to \S\ref{sec:concurrent-memory}.

Consider the program $(\aLoc\GETS0\SEMI \bLoc\GETS\aLoc+1)$.  One execution of
this program is where the write to $y$ uses the sequential value of
$x$, which is $0$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
To see how this execution is modelled, we first
expand out the syntax sugar to get the program
$(\aLoc\GETS0\SEMI \aReg\GETS\aLoc\SEMI \bLoc\GETS\aReg+1\SEMI\SKIP)$
Now $\sem{\SKIP}$ is just $\{\emptyset\}$, and
$\sem{y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (r+1=1 \mid \DW y1) \prefix \sem{\SKIP}[1/y]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{r+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
expressing that this program can write $1$ to $y$,
as long as the precondition $(r+1=1)$ is satisfied.
Now $\sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$
has two cases, the sequential case
(which does not introduce a read action)
and the concurrent case (which does).
For the moment, we are interested in the sequential case, which is:
\[
   \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{x+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
In this pomset, the precondition is $(x+1=1)$, which specifies a property
of the thread-local value of $x$.
Finally $\sem{x \GETS 0\SEMI r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (0=0 \mid \DW x0) \prefix \sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}[0/x]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{0=0 \mid \DW{x}{0}}{}
  \event{wy1}{0+1=1 \mid \DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
all of whose preconditions are tautologies, so this has the expected behaviour:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
Note that there is no
requirement of order between $(\DW x0)$ and $(\DW y1)$.

This example demonstrates how preconditions
capture the sequential semantics of memory.
In an execution containing an event with label
$(\aForm \mid \aAct)$, one way the precondition $\aForm$
can be discharged is by an assignment $\aLoc\GETS\aExp$,
which performs a substitution $[\aExp/\aLoc]$.
This is a variant of the Hoare semantics for
assignment, where if $\aCmd$ has preconditon $\aForm$
then $\aLoc\GETS\aExp\SEMI\aCmd$ has precondition
$\aForm[\aExp/\aLoc]$.

\subsection{Concurrent memory accesses}
\label{sec:concurrent-memory}

We now turn to the case of concurrent accesses to memory.
Consider a concurrent version of the program from \S\ref{sec:sequential-memory}:
$(\aLoc\GETS1 \PAR \bLoc\GETS\aLoc+1)$.
One execution of this program is where the write to $y$
performs a concurrent read of $x$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
To see how this execution is modelled, we first
expand out the syntax sugar to get the program
$(\aLoc\GETS1\SEMI\SKIP \PAR \aReg\GETS\aLoc\SEMI \bLoc\GETS\aReg+1\SEMI\SKIP)$.
As before, $\sem{y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (r+1=2 \mid \DW y2) \prefix \sem{\SKIP}[2/y]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy2}{r+1=2 \mid \DW{y}{2}}{}
\end{tikzpicture}\]
As before, $\sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ has two cases.
We are now interested in the concurrent case, which includes:
\[
   (\DR x1) \prefix \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
Note that $(\DR x1)$ reads $1$ from $x$, and while
$(x+1=2)[1/x]$ is a tautlogy,
$(x+1=2)$ is not,
and so there is a dependency
$(\DR x1) < (\DW y2)$.

Now, $\sem{x \GETS 1\SEMI \SKIP}$ includes the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
\end{tikzpicture}\]
and so $\sem{x \GETS 1\SEMI \SKIP \PAR r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
as expected, including a reads-from dependency
$(\DW x1) < (\DR x1)$.

This example demonstrates how read and write events
capture the concurrent semantics of memory.
In an execution containing an event with label
$(\DR \aLoc\aVal)$, if the execution is
$\aLoc$-closed, then there must be an event
it reads from, for example one labelled
$(\DW \aLoc\aVal)$.

\subsection{Independent writes}

Consider an example with two independent writes
$(\aLoc\GETS1\SEMI \bLoc\GETS2)$.
This has semantics including:
\[
  (1=1 \mid \DW x1) \prefix
    (2=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
One of the executions this contains is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wx1}{wy2}
\end{tikzpicture}\]
but it also contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
and:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wy2}{wx1}
\end{tikzpicture}\]
since there is no requirement that
$(\DW{x}{1}) < (\DW{y}{2})$.

Thus, the semantics of $(\aLoc\GETS1\SEMI \bLoc\GETS2)$
is the same as the semantics of $(\bLoc\GETS2\SEMI \aLoc\GETS1)$.

\subsection{Independent reads and writes}

Whereas write prefixing introduces weak dependencies on events which write
to the same location, read prefixing introduces strong dependencies on
preconditions which depend on the location being read. For example
in \S\ref{sec:concurrent-memory} we saw that the program
$(\bLoc\GETS\aLoc+1)$ includes the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
but since $(x+1=2)$ depends on $x$,
we have the requirement that $(\DR{x}{1}) \le (\DW{y}{2})$.

This is in contrast to the program 
$(\aReg\GETS\aLoc\SEMI \bLoc\GETS\aReg+2-\aReg)$.
Since $(x+2-x=2)$ is independent of $x$
(at least for integer arithmetic)
this contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
\end{tikzpicture}\]
and so the semantics of $(\aReg\GETS\aLoc\SEMI \bLoc\GETS\aReg+2-\aReg)$
is the same as the semantics of $(\bLoc\GETS2\SEMI \aReg\GETS\aLoc)$.

Note this this example shows that we are not just dealing
with a syntactic notion of dependency, which is common
in hardware models of memory. In syntactic dependency,
since $r$ occurs free in $(y\GETS r+2-r)$, there would be
a dependency between $(r\GETS x)$ and $(y\GETS r+2-r)$.
In contrast, this model is based on logical implication,
which can be interpreted semantically.

\subsection{Control dependencies}
\label{sec:control-dep}

Conditionals introduce control dependencies, for example consider the program:
\[
  \aReg\GETS\cLoc\SEMI
  \IF(\aReg)\THEN \aLoc\GETS1 \ELSE \bLoc\GETS2 \FI
\]
This includes executions in which the false branch is taken:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=of rz0}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=30,in=150]{rz0}{wy2}
\end{tikzpicture}\]
and ones where the true branch is taken:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]
In both cases, we record the actions in the branch that was
not taken. This is a novel feature of this model, and is
intended to capture speculative evaluation. In \S\ref{sec:spectre}
we will show how this model captures Spectre-like information
flow attacks, once the attacker is provided with the ability to
observe such speculations.

To see how these executions are modelled, consider the semantics of
$\sem{x\GETS 1\SEMI\SKIP}$, which contains any pomset of the form:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aForm \mid \DW{x}{1}}{}
\end{tikzpicture}\]
in particular it contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
Similarly $\sem{y\GETS 2\SEMI\SKIP}$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy2}{r=0 \mid \DW{y}{2}}{}
\end{tikzpicture}\]
and so $\sem{\IF(r)\THEN x\GETS 1\SEMI\SKIP \ELSE y\GETS 2\SEMI\SKIP \FI}$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
  \event{wy2}{r=0 \mid \DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
Now, the semantics of concurrent read performs substitutions, for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{0\neq0 \mid \DW{x}{1}}{right=of rz0}
  \event{wy2}{0=0 \mid \DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=25,in=155]{rz0}{wy2}
\end{tikzpicture}\]
which gives the required pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=of rz0}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=30,in=150]{rz0}{wy2}
\end{tikzpicture}\]
Note that the precondition $r=0$ is dependent on $r$,
and so there is a dependency $(\DR z0) < (\DW y2)$,
modelling the control dependency introduced by the conditional.

\subsection{Control independencies}

In most models of control dependencies, the dependency relation
is syntactic, based on whether the action occurs inside syntactically
inside a conditional. In contrast, the notion in this model is
semantic: if an action can occur on both sides of a conditional,
there is no control dependency. Consider a variant of the example
from \S\ref{sec:control-dep}:
\[
  \aReg\GETS\cLoc\SEMI
  \IF(\aReg)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS1 \FI
\]
This has the expected execution in which the control
dependencies exist:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{nwx1}{\DW{x}{1}}{right=of rz0}
  \event{wx1}{\DW{x}{1}}{right=of nwx1}
  \po{rz0}{nwx1}
  \po[out=30,in=150]{rz0}{wx1}
\end{tikzpicture}\]
but it also has an execution in which the two writes
of $1$ to $x$ are merged, resulting in no dependency:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz0}
\end{tikzpicture}\]
To see how this arises,
consider the definition of $\sem{\IF(r)\THEN x\GETS1\SEMI\SKIP \ELSE x\GETS1\SEMI\SKIP \FI}$:
\[
   \aPSS_1 \parallel \aPSS_2 \quad\mbox{where}\quad
   \aPSS_1 = (r\neq 0 \mid \sem{x\GETS1\SEMI\SKIP})  \quad\mbox{and}\quad
   \aPSS_2 = (r=0 \mid \sem{x\GETS1\SEMI\SKIP})
\]
Now, one pomset in $\aPSS_1$ is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
that is $\aPS_1$ where:
\[
  \Event_1 = \{\aEv\} \quad
  \labelling_1(\aEv) = (r\neq 0, \DW x1)
\]
and similarly, one pomset in $\aPSS_2$ is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r=0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
that is $\aPS_2$ where:
\[
  \Event_2 = \{\aEv\} \quad
  \labelling_2(\aEv) = (r= 0, \DW x1)
\]
Crucuially, in the definition of $\aPSS_1 \parallel \aPSS_2$
there is \emph{no} requirement that $\Event_1$ and $\Event_2$ are disjoint,
and in this case they overlap at $\aEv$. As a result, one pomset in
$\aPSS_1\sqcup\aPSS_2$ is $\aPS_0$ where:
\[
  \Event_0 = \{\aEv\} \quad
  \labelling_0(\aEv) = (r\neq0 \lor r=0, \DW x1)
\]
that is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
\end{tikzpicture}\]
Note that this pomset has no precondition dependent on $r$,
since $(r\neq0 \lor r=0)$ does not depend on $r$, which is why
we end up with an execution without a control dependency:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz0}
\end{tikzpicture}\]
This semantics captures compiler optimizations which may, for example
merge code executed on both branches of a conditional, or hoist
constant assignments out of loops.

We can now see the counterintuitive behavior of conditionals
in the presence of control dependencies.
There are programs such as
\(
  \IF(\cLoc)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS1 \FI
\)
executions in which  $(\DW x1)$ is independent of $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
\end{tikzpicture}\]
while programs such as
\(
  \IF(\cLoc)\THEN \aLoc\GETS1 \ELSE \bLoc\GETS2 \FI
\)
only have executions in which $(\DW x1)$ is dependent on $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]
so these programs have different dependency relations, depending
on conditional branches that were not taken. In \S\ref{sec:info-flow-attack}
we shall see that this has security implications, since relaxed
memory can observe dependency. The attack is similar to Spectre, so
we shall take a detour to see how Spectre can be modeled in this
setting.

\subsection{Spectre}
\label{sec:spectre}

We give a simplified model of Spectre attacks, ignoring the details of
timing.  In this model, we extend programs with the ability to tell
whether a memory location has been touched (in practice this is
implemented using timing attacks on the cache). For example,
we can model Spectre by:
\[\begin{array}{l}
  \VAR a\SEMI \IF(\CANREAD(\SEC))\THEN a[\SEC]\GETS1
  \brELIF(\TOUCHED a[0])\THEN x\GETS0
  \brELIF(\TOUCHED a[1])\THEN x\GETS1 \FI
\end{array}\]
This is a low-security program, which is attempting to discover the
value of a high-security variable $\SEC$. The low-security program
is allowed to attempt to escalate its privileges by checking that it is
allowed to read a high-security variable:
\[
  \IF(\CANREAD(\SEC))\THEN \cdots\mbox{code allowed to read $\SEC$}\cdots
  \ELSE \cdots \FI
\]
In this case, $\CANREAD(\SEC)$ is false, so the fallback code
is executed. Unfortunately, the escalated code is speculatively
evaluated, which allows information to leak by testing for which
memory locations have been touched.

We model the $\TOUCHED$ test by introducing a new action
$(\DT{\aLoc})$ and defining:
\begin{eqnarray*}
  \sem{\IF (\TOUCHED\aLoc) \THEN \aCmd \ELSE \bCmd \FI} & = & ((\DT\aLoc) \prefix \sem{\aCmd}) \cup \sem{\bCmd}
\end{eqnarray*}
The additional requirement we need to add for $\aLoc$-closure is:
\begin{itemize}
\item if $\labelling(\aEv)=(\aForm \mid \DT{\aLoc})$
  then there is $\bEv<\aEv$
  where $\bEv$ reads or writes $\aLoc$.
\end{itemize}
Note that there is no requirement that $\bEv$ be satisfiable,
and indeed Spectre has the execution:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{rs}{\DR{\SEC}{1}}{}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \po{rs}{wa}
  \po{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
Putting this in parallel with a high-security write to \verb|SECRET| gives:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{1}}{}
  \nonevent{rs}{\DR{\SEC}{1}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
but due the requirement of $a$-closure we do \emph{not} have:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{0}}{}
  \nonevent{rs}{\DR{\SEC}{0}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[0]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
Thus, the attacker has managed to leak the value of a high-security
location to a low-security one.

This shows how our model of speculation can express
(very abstract, untimed) Spectre attacks.

\subsection{Relaxed memory}
\label{sec:relaxed-memory}

In \S\ref{sec:info-flow-attack} we present an information flow attack
on relaxed memory, similar to Spectre in that it relies on speculative
evaluation. Unlike Spectre it does not depend on timing attacks,
but instead is based on the sensitivity of relaxed memory to data
dependencies. For this reason, we present a simple model of relaxed
memory, which is strong enough to capture this attack.
The model includes concurrent memory accesses, which can introduce concurrent
reads-from. 
Since we are allowing events to be partially ordered, this gives a simple
model of relaxed memory, for example an independent read independent write
(IRIW) example is:
\begin{verbatim}
  x := 0; x := x+1; || y := 0; y := y+1; || if (x) { r := y; } || if (y) { s := x; }
\end{verbatim}
which includes the execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{right=2.5em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of ry0}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \rf[out=20,in=160]{wx1}{rx1}
  \rf[out=20,in=160]{wy0}{ry0}
  \rf[out=340,in=200]{wy1}{ry1}
  \rf[out=340,in=200]{wx0}{rx0}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \po{rx1}{ry0}
  \po{ry1}{rx0}
\end{tikzpicture}\]
This model does not introduce thin-air reads (TAR),
for example the TAR pit program is:
\begin{verbatim}
  x := y; || y := x;
\end{verbatim}
but an attempt to produce a value from thin air fails,
for the usual reason of producing a cycle in $\le$, as shown on the left below.
\begin{align*}
\begin{tikzpicture}[node distance=1em]
  \event{ry42}{\DR{y}{42}}{}
  \event{wx42}{\DW{x}{42}}{below=of ry42}
  \event{rx42}{\DR{x}{42}}{right=2.5em of ry42}
  \event{wy42}{\DW{y}{42}}{below=of rx42}
  \po{ry42}{wx42}
  \po{rx42}{wy42}
  \rf{wx42}{rx42}
  \rf{wy42}{ry42}
\end{tikzpicture}
&&
\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{y}{1}}{}
  \event{wx1}{\DW{x}{1}}{below=of ry1}
  \event{rx1}{\DR{x}{1}}{right=2.5em of ry1}
  \event{wy1}{\DW{y}{1}}{below=of rx1}
  \po{ry1}{wx1}
  \rf{wx1}{rx1}
  \rf{wy1}{ry1}
\end{tikzpicture}
\end{align*}
This cycle can be broken if one of the writes does not depend on the read, for example:
\begin{verbatim}
  x := y; || r := x; y := r+1-r;
\end{verbatim}
has the execution on the right above.
% \[\begin{tikzpicture}[node distance=1em]
%   \event{ry1}{\DR{y}{1}}{}
%   \event{wx1}{\DW{x}{1}}{below=of ry1}
%   \event{rx1}{\DR{x}{1}}{right=2.5em of ry1}
%   \event{wy1}{\DW{y}{1}}{below=of rx1}
%   \po{ry1}{wx1}
%   \rf{wx1}{rx1}
%   \rf{wy1}{ry1}
% \end{tikzpicture}\]
Note that $(\DR x1) \not\le (\DW y1)$, so this does not introduce a cycle.

Although it is not the primary focus of this paper, our model may be an
attractive model of relaxed memory.  Many prior models either permit
thin-air executions that our model forbids or forbid desirable executions
that our model permits.

In \S\ref{sec:logic}, we develop a logic which allows us to prove that our
semantics forbids thin air examples that are permitted by prior speculative
models
\cite{Manson:2005:JMM:1047659.1040336,DBLP:conf/esop/JagadeesanPR10,DBLP:conf/popl/KangHLVD17}.

Our model passes all of the expressible causality test cases
\cite{PughWebsite} (two test cases require loops).  Significantly, this
includes test case 9, which is forbidden by \cite{DBLP:conf/lics/JeffreyR16},
one of the few models that disallows the thin air example from
\S\ref{sec:logic}.  We present this test case in the appendix, where we also
discuss the thread inlining examples from
\cite{Manson:2005:JMM:1047659.1040336}.

In \cite{DBLP:conf/esop/BattyMNPS15},
\citeauthor{DBLP:conf/esop/BattyMNPS15} showed that the thin-air problem has
no per-candidate-execution solution for C++.  This result does not apply to
our model, which tracks dependencies more precisely than C++.

\subsection{Information flow attacks on relaxed memory}
\label{sec:info-flow-attack}

Consider an attacker program, again using security checks to
try to learn a \verb|SECRET|. Whereas \verb|SPECTRE| uses
hardware capabilities, which have to be modeled by adding
extra capabilities to the language, this new attacker works
by exploiting relaxed memory which can result in
unexpected information flows. The attacker program is:
\begin{verbatim}
  (
    x := 0; y := x;
  ) || (
    if (y == 0) { x := 1; }
    else if (canRead(SECRET)) { x := SECRET; }
    else { x := 1; z := 1; }
  )
\end{verbatim}
In the case where \verb|SECRET| is $2$, this has many executions,
one of which is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{ry0}{\DR{y}{0}}{right=2.5 em of wy0}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \nonevent{wx2}{\DW{x}{2}}{right=of wx1}
  \nonevent{wz1}{\DW{z}{1}}{right=of wx2}
  \po{ry0}{wx1}
  \po[out=30,in=150]{ry0}{wz1}
  \po[out=25,in=150]{ry0}{wx2}
  \rf{wy0}{ry0}
\end{tikzpicture}\]
but there are no executions which exhibit
$(\DW{z}{1})$, since any attempt to do so
produces a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{rx1}{\DR{x}{1}}{right=of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wx1}
  \event{wz1}{\DW{z}{1}}{right=of wx2}
  \po{rx1}{wy1}
  \po{ry1}{wx1}
  \po[out=30,in=150]{ry1}{wz1}
  \po[out=25,in=150]{ry1}{wx2}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
In the case where \verb|SECRET| is $1$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{rx1}{\DR{x}{1}}{right=of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wz1}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
Note that in this case, there is no dependency from
$(\DR{y}{1})$ to $(\DW{x}{1})$, which is what makes this
execution possible. Thus, if the attacker sees
an execution with $(\DW{z}{1})$, they can conclude
that \verb|SECRET| is $1$, which is an information flow
attack.

This attack is not just an artifact of the model,
since the same behavior can be exhibited by
compiler optimizations. Consider the program fragment:
\begin{verbatim}
  if (y == 0) { x := 1; }
  else if (canRead(SECRET)) { x := SECRET; }
  else { x := 1; z := 1; }
\end{verbatim}
Now, in the case where \verb|SECRET| is a constant \verb|1|,
the compiler can inline it:
\begin{verbatim}
  if (y == 0) { x := 1; }
  else if (canRead(SECRET)) { x := 1; }
  else { x := 1; z := 1; }
\end{verbatim}
and lift the assignment to \verb|x| out of the \verb|if| statement:
\begin{verbatim}
  x := 1;
  if (y == 0) { }
  else if (canRead(SECRET)) { }
  else { z := 1; }
\end{verbatim}
After these optimizations, a sequentially consistent execution
exhibits $(\DW{z}{1})$. We discuss the practicality of this attack
further in \S\ref{sec:experiments}.

This approach can be generalized to detect information flows in arbitrary
code.  If we replace the code fragment above with:
\begin{verbatim}
  if (y == 0) { x:=P(0); } else { x:=P(1); z:=1; }
\end{verbatim}
then $(\DW{z}{1})$ is possible only if \texttt{P} is independent of its
input.  The conditional is able to capture multiple executions, as in
\cite{Capizzi:2008:PIL:1468162.1468220,Devriese:2010:NTS:1849417.1849969}.

\subsection{Dead store elimination}
\label{sec:dse}

A common compiler optimization is \emph{dead store elimination},
in which writes are omitted if they will be overwritten by a subsequent
write later in the same thread. We can model eliminated writes
by ones with an unsatisfiable precondition. For example,
one execution of \verb`(x := 1; x := 2 || r := x)` is:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{wx1}{\DW{x}{1}}{}
  \event{wx2}{\DW{x}{2}}{right=of wx1}
  \event{rx2}{\DR{x}{2}}{right=2.5em of wx2}
  \wk{wx1}{wx2}
  \rf{wx2}{rx2}
\end{tikzpicture}\]
Recall that for any satisfiable $\aEv$, if $\aEv$ reads $\aLoc$ from $\bLoc$
then $\bEv$ is a tautology. This means that, although we can eliminate
$(\DW{x}{1})$ we cannot eliminate $(\DW{x}{2})$.

One heuristic that a compiler might adopt is to only eliminate
writes that are guaranteed to be followed by another write
to the same variable. This can be formalized by saying that
$\bEv$ is eliminatable if there is a $\aEv \ltN \bEv$ such
that $\aEv$ is a tautology and $\bEv$ writes to every location
$\aEv$ writes to. A model of dead store elimination is one where,
in every pomset, every eliminatable event is unsatisfiable.
This simple model includes the examples above.

Note that if dead store
elimination is \emph{always} performed, then there is an information
flow attack similar to the one in \S\ref{sec:info-flow-attack}. Consider
the program:
\begin{verbatim}
  (
    r := x;
  ) || (
    x := 1;
    if (canRead(SECRET)) { if (SECRET) { x := 2; } }
    else { x := 2; }
  )
\end{verbatim}
In the case that \verb|SECRET| is $0$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=2.5em of rx1}
  \event{wx2}{\aForm \mid \DW{x}{2}}{right=of wx1}
  \rf{wx1}{rx1}
  \wk{wx1}{wx2}
\end{tikzpicture}\]
where $\aForm$ is ($\lnot$\verb|canRead(SECRET)|),
which is not a tautology, and so the $(\DW{x}{1})$ event is not eliminated.
In the case that \verb|SECRET| is not $0$, the matching execution
is:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx2}{\DR{x}{2}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=2.5em of rx2}
  \event{wx2}{\DW{x}{2}}{right=of wx1}
  \rf[out=160,in=20]{wx2}{rx2}
  \wk{wx1}{wx2}
\end{tikzpicture}\]
Now the $(\DW{x}{2})$ event is a guaranteed write, so the $(\DW{x}{1})$
is eliminated, and so cannot be read.
In the case that the attacker can rely on dead store
elimination taking place, this is an information flow: if the attacker observes
$x$ to be $1$, then they know \verb|SECRET| is $0$. We return to this attack
in \S\ref{sec:experiments}.


% Local Variables:
% TeX-master: "paper"
% End:
