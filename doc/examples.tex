\section{Examples}

\subsection{Spectre}

We give a simplified model of Spectre attacks, ignoring the details of
timing.  In this model, we extend programs with the ability to tell
whether a memory location has been touched (in practice this is
implemented using timing attacks on the cache). For example,
we can write a \verb|SPECTRE| program as:
\begin{verbatim}
    var a;
    if (isCapability(0)) { a[SECRET] := 1; }
    else if (touched a[0]) { x := 0; }
    else if (touched a[1]) { x := 1; }
\end{verbatim}
This is a low-security program, which is attempting to discover the
value of a high-security variable \verb|SECRET|. The low-security program
is allowed to attempt to escalate its privileges by providing a capability
which demonstrates that they are entitled to run high-security code:
\begin{verbatim}
    if (isCapability(c)) { ... escalated code ... }
    else { ... fallback code ... }
\end{verbatim}
In this case, the \verb|isCapability(0)| is false, so the fallback code
is executed. Unfortunately, the escalated code is speculatively
evaluated, which allows information to leak by testing for which
memory locations have been touched.

We model the \verb|touched| test by introducing a new read action
$(\DT{\aLoc})$ and defining:
\begin{eqnarray*}
  \sem{\IF \TOUCHED\aLoc\THEN C \ELSE D} & = & ((\DT\aLoc) \prefix \sem{C}) \sqcup \sem{D}
\end{eqnarray*}
The additional requirement we need to add for $\aLoc$-closure is:
\begin{itemize}
\item if $\labelling(\aEv)=(\aForm \mid \DT{\aLoc})$
  then there is $\bEv\not>\aEv$ with $\labelling(\bEv)=(\bForm \mid \DR{\aLoc}{\aVal})$
  or $\labelling(\bEv)=(\bForm \mid \DW{\aLoc}{\aVal})$.
\end{itemize}
For example, one execution of \verb|SPECTRE| is:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{rs}{\DR{\SEC}{1}}{}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
Putting this in parallel with a high-security write to \verb|SECRET| gives:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{1}}{}
  \nonevent{rs}{\DR{\SEC}{1}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
but due the requirement of \verb|a|-closure we do \emph{not} have:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{0}}{}
  \nonevent{rs}{\DR{\SEC}{0}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{0}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
Thus, the attacker has managed to leak the value of a high-security
location to a low-security one.

This shows how a (very abstract, untimed) model of Spectre attacks
using speculative evaluation can be modelled.

\subsection{Information flow attacks on relaxed memory}

Consider an attacker program, again using security checks to
try to learn a \verb|SECRET|. Whereas \verb|SPECTRE| uses
hardware capabilities, which have to be modelled by adding
extra capabilities to the language, this new attacker works
by exploiting relaxed memory which can result in
unexpected information flows. The attacker program is:
\begin{verbatim}
  var x := 0; var y := 0;
  (
    y := x;
  ) || (
    r := y;
    if (isCapability(r)) { x := SECRET; }
    else { x := 1; z := r; }
  )
\end{verbatim}
In the case where \verb|SECRET| is $2$, this has many executions,
one of which is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry0}{\DR{y}{0}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \event{wz0}{\DW{z}{0}}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wz0}
  \po{rx1}{wy1}
  \po{ry0}{wx1}
  \po[out=25,in=150]{ry0}{wz0}
  \po[out=30,in=150]{ry0}{wx2}
  \rf[out=30,in=150]{wy0}{ry0}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
but there are no executions which exhibit
$(\DW{z}{1})$, since any attempt to do so
produces a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wz1}
  \po{rx1}{wy1}
  \po{ry1}{wx1}
  \po[out=25,in=150]{ry1}{wz1}
  \po[out=30,in=150]{ry1}{wx2}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
In the case where \verb|SECRET| is $1$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wz1}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
Note that in this case, there is no dependency from
$(\DR{y}{1})$ to $(\DW{x}{1})$, which is what makes this
execution possible. Thus, if the attacker sees
an execution with $(\DW{z}{1})$, they can conclude
that \verb|SECRET| is $1$, which is an information flow
attack.

This attack is not just an artefact of the model,
since the same behaviour can be exhibited by
compiler optimizations. Consider the program fragment:
\begin{verbatim}
  r := y;
  if (isCapability(r)) { x := SECRET; }
  else { x := 1; z := r; }
\end{verbatim}
Now, in the case where \verb|SECRET| is a constant \verb|1|,
the compiler can inline it:
\begin{verbatim}
  r := y;
  if (isCapability(r)) { x := 1; }
  else { x := 1; z := r; }
\end{verbatim}
lift the assignment to \verb|x| out of the \verb|if| statement:
\begin{verbatim}
  r := y; x := 1;
  if (isCapability(r)) { }
  else { z := r; }
\end{verbatim}
and then perform independent read/write reordering:
\begin{verbatim}
  x := 1; r := y;
  if (isCapability(r)) { }
  else { z := r; }
\end{verbatim}
After these optimizations, a sequentially consistent execution
exhibits $(\DW{z}{1})$.
