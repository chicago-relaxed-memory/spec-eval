\section{Examples}
\label{sec:examples}

\subsection{Sequential memory accesses}
\label{sec:sequential-memory}

In the semantics of memory, there are two very different ways memory
can be accessed: sequentially or concurrently. These are modelled
differently, since hardware and compilers give very different
guarantees about their behaviour.
In this section, we discuss the sequential semantics, and leave
the concurrent semantics to \S\ref{sec:concurrent-memory}.

Consider the program \verb`(x := 0; y := x+1;)`.  One execution of
this program is where the write to $y$ uses the sequential value of
$x$, which is $0$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
To see how this execution is modelled, we first
expand out the syntax sugar to get the program \verb`(x := 0; r := x; y := r+1; skip)`.
Now $\sem{\SKIP}$ is just $\{\emptyset\}$, and
$\sem{y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (r+1=1 \mid \DW y1) \prefix \sem{\SKIP}[1/y]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{r+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
expressing that this program can write $1$ to $y$,
as long as the precondition $(r+1=1)$ is satisfied.
Now $\sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$
has two cases, the sequential case
(which does not introduce a read action)
and the concurrent case (which does).
For the moment, we are interested in the sequential case, which is:
\[
   \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy1}{x+1=1 \mid \DW{y}{1}}{}
\end{tikzpicture}\]
In this pomset, the precondition is $(x+1=1)$, which specifies a property
of the thread-local value of $x$.
Finally $\sem{x \GETS 0\SEMI r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (0=0 \mid \DW x0) \prefix \sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}[0/x]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{0=0 \mid \DW{x}{0}}{}
  \event{wy1}{0+1=1 \mid \DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
all of whose preconditions are tautologies, so this has the expected behaviour:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
Note that there is no
requirement of order between $(\DW x0)$ and $(\DW y1)$.

This example demonstrates how preconditions
capture the sequential semantics of memory.
In an execution containing an event with label
$(\aForm \mid \aAct)$, one way the precondition $\aForm$
can be discharged is by a write $\aLoc\GETS\aExp$,
which performs a substitution $[\aExp/\aLoc]$.
This is a variant of the usual Hoare semantics for
assignment, where if $\aCmd$ has preconditon $\aForm$
then $\aLoc\GETS\aExp\SEMI\aCmd$ has precondition
$\aForm[\aExp/\aLoc]$.

\subsection{Concurrent memory accesses}
\label{sec:concurrent-memory}

We now turn to the case of concurrent accesses to memory.
Consider a concurrent version of the program from \S\ref{sec:sequential-memory}:
\verb`(x := 1; || y := x+1;)`.
One execution of this program is where the write to $y$
performs a concurrent read of $x$:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
To see how this execution is modelled, we first
expand out the syntax sugar to get the program \verb`(x := 1; skip || r := x; y := r+1; skip)`.
As before, $\sem{y \GETS r+1\SEMI \SKIP}$ includes:
\[
   (r+1=2 \mid \DW y2) \prefix \sem{\SKIP}[2/y]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy2}{r+1=2 \mid \DW{y}{2}}{}
\end{tikzpicture}\]
Now $\sem{r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ has two cases, the sequential case
(which does not introduce a read action)
and the concurrent case (which does).
We are now interested in the concurrent case, which includes:
\[
   (\DR x1) \prefix \sem{y \GETS r+1\SEMI \SKIP}[x/r]
\]
which contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
Note that $(\DR x1)$ reads $1$ from $x$, and while
$(x+1=2)[1/x]$ is a tautlogy
$(x+1=2)$ is \emph{not} independent of $x$
and so there is an ordering
$(\DR x1) < (\DW y2)$
modelling the data dependency of the write of $y$ on the read of $x$.

Now, $\sem{x \GETS 1\SEMI \SKIP}$ includes the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
\end{tikzpicture}\]
and so $\sem{x \GETS 1\SEMI \SKIP \PAR r \GETS x\SEMI y \GETS r+1\SEMI \SKIP}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
as expected, including an reads-from dependency between the concurrent write of $x$
and the matching read.

This example demonstrates how read and write events
capture the concurrent semantics of memory.
In an execution containing an event with label
$(\DR \aLoc\aVal)$, if the execution is
$\aLoc$-closed, then there must be an event
it reads from, for example one labelled
$(\DW \aLoc\aVal)$.

\subsection{Independent writes}

Consider an example with two independent writes
\verb|(x := 1; y := 2;)|.
This has the semantics which includes:
\[
  (1=1 \mid \DW x1) \prefix
    (2=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
One of the executions this contains is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wx1}{wy2}
\end{tikzpicture}\]
but it also contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
and:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wy2}{wx1}
\end{tikzpicture}\]
since there is no requirement that
$(\DW{x}{1}) \le (\DW{y}{2})$.

Thus, the semantics of \verb|(x := 1; y := 2;)|
is the same as the semantics of \verb|(y := 2; x := 1;)|.

\subsection{Independent reads and writes}

Whereas write prefixing introduces weak dependencies on events which write
the the same location, read prefixing introduces strong dependencies on
preconditions which depend on the location being read. For example
in \S\ref{sec:concurrent-memory} we saw that the program
\verb|(r := x; y := r+1;)| includes the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
but since $(x+1=2)$ depends on $x$,
we have the requirement that $(\DR{x}{1}) \le (\DW{y}{2})$.

This is in contrast to the program 
\verb|(r := x; y := r+2-r;)|.
Since $(x+2-x=2)$ is independent of $x$
(at least for integer arithmetic)
this contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
\end{tikzpicture}\]
and we can show the semantics of \verb|(r := x; y := r+2-r;)|
is the same as the semantics of \verb|(y := 2; r := x;)|.

Note this this example shows that we are not just dealing
with a syntactic notion of dependency, which is common
in hardware models of memory. In syntactic dependency,
since $r$ occurs free in $(y\GETS r+2-r)$, there would be
a dependency between $(r\GETS x)$ and $(y\GETS r+2-r)$.
In contrast, this model is based on logical implication,
which can be interpreted semantically.

\subsection{Control dependencies}
\label{sec:control-dep}

Conditionals introduce control dependencies, for example consider the program:
\begin{verbatim}
  r := z; if (r) { x := 1; } else { y := 2; }
\end{verbatim}
This includes executions in which the false branch is taken:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=of rz0}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=30,in=150]{rz0}{wy2}
\end{tikzpicture}\]
and ones where the true branch is taken:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]
In both cases, we record the actions in the branch that was
not taken. This is a novel feature of this model, and is
intended to capture speculative evaluation. In \S\ref{sec:spectre}
we will show how this model captures Spectre-like information
flow attacks, once the attacker is provided with the ability to
observe such speculations.

To see how these executions are modelled, consider the semantics of
$\sem{x\GETS 1\SEMI\SKIP}$, which contains any pomset of the form:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aForm \mid \DW{x}{1}}{}
\end{tikzpicture}\]
in particular it contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
Similarly $\sem{y\GETS 2\SEMI\SKIP}$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wy2}{r=0 \mid \DW{y}{2}}{}
\end{tikzpicture}\]
and so $\sem{\IF(r)\THEN x\GETS 1\SEMI\SKIP \ELSE y\GETS 2\SEMI\SKIP \FI}$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
  \event{wy2}{r=0 \mid \DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
Now, the semantics of concurrent read performs substitutions, for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{0\neq0 \mid \DW{x}{1}}{right=of rz0}
  \event{wy2}{0=0 \mid \DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=25,in=155]{rz0}{wy2}
\end{tikzpicture}\]
which gives the required pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{wx1}{\DW{x}{1}}{right=of rz0}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz0}{wx1}
  \po[out=30,in=150]{rz0}{wy2}
\end{tikzpicture}\]
Note that the precondition $r=0$ is dependent on $r$,
and so there is a dependency $(\DR z0) < (\DW y2)$,
modelling the control dependency introduced by the conditional.

\subsection{Control independencies}

In most models of control dependencies, the dependency relation
is syntactic, based on whether the action occurs inside syntactically
inside a conditional. In contrast, the notion in this model is
semantic: if an action can occur on both sides of a conditional,
there is no control dependency. Consider a variant of the example
from \S\ref{sec:control-dep}:
\begin{verbatim}
  r := z; if (r) { x := 1; } else { x := 1; }
\end{verbatim}
This has the expected execution in which the control
dependencies exist:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \nonevent{nwx1}{\DW{x}{1}}{right=of rz0}
  \event{wx1}{\DW{x}{1}}{right=of nwx1}
  \po{rz0}{nwx1}
  \po[out=30,in=150]{rz0}{wx1}
\end{tikzpicture}\]
but it also has an execution in which the two writes
of $1$ to $x$ are merged, resulting in no dependency:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz0}
\end{tikzpicture}\]
To see how this arises in the model,
consider the definition of $\sem{\IF(r)\THEN x\GETS1\SEMI\SKIP \ELSE x\GETS1\SEMI\SKIP \FI}$:
\[
   \aPSS_1 \sqcup \aPSS_2 \quad\mbox{where}\quad
   \aPSS_1 = (r\neq 0 \mid \sem{x\GETS1\SEMI\SKIP})  \quad\mbox{and}\quad
   \aPSS_2 = (r=0 \mid \sem{x\GETS1\SEMI\SKIP})
\]
Now, one pomset in $\aPSS_1$ is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r\neq0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
that is $\aPS_1$ where:
\[
  \Event_1 = \{\aEv\} \quad
  \labelling_1(\aEv) = (r\neq 0, \DW x1)
\]
and similarly, one pomset in $\aPSS_2$ is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{r=0 \mid \DW{x}{1}}{}
\end{tikzpicture}\]
that is $\aPS_2$ where:
\[
  \Event_2 = \{\aEv\} \quad
  \labelling_2(\aEv) = (r= 0, \DW x1)
\]
Crucuially, in the definition of $\aPSS_1 \sqcup \aPSS_2$
there is \emph{no} requirement that $\Event_1$ and $\Event_2$ are disjoint,
and in this case they overlap at $\aEv$. As a result, one pomset in
$\aPSS_1\sqcup\aPSS_2$ is $\aPS_0$ where:
\[
  \Event_0 = \{\aEv\} \quad
  \labelling_0(\aEv) = (r\neq0 \lor r=0, \DW x1)
\]
that is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
\end{tikzpicture}\]
Note that this pomset has no precondition dependent on $r$,
since $(r\neq0 \lor r=0)$ does not depend on $r$, which is why
we end up with an execution without a control dependency:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{z}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz0}
\end{tikzpicture}\]
This semantics captures compiler optimizations which may, for example
merge code executed on both branches of a conditional, or hoist
constant assignments out of loops.

We can now see the counterintuitive behavior of conditionals
in the presence of control dependencies.
There are programs such as
\verb|(r := z; if (r) { x := 1; } else { x := 1; })| with
executions in which  $(\DW x1)$ is independent of $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
\end{tikzpicture}\]
while programs such as
\verb|(r := z; if (r) { x := 1; } else { y := 2; })|
only have executions in which $(\DW x1)$ is dependent on $(\DR z1)$:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{z}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=of rz1}
  \nonevent{wy2}{\DW{y}{2}}{right=of wx1}
  \po{rz1}{wx1}
  \po[out=30,in=150]{rz1}{wy2}
\end{tikzpicture}\]
so these programs have different dependency relations, depending
on conditional branches that were not taken. In \S\ref{sec:info-flow-attack}
we shall see that this has security implications, since relaxed
memory can observe dependency. The attack is similar to Spectre, so
we shall take a detour to see how Spectre can be modeled in this
setting.

\subsection{Spectre}
\label{sec:spectre}

We give a simplified model of Spectre attacks, ignoring the details of
timing.  In this model, we extend programs with the ability to tell
whether a memory location has been touched (in practice this is
implemented using timing attacks on the cache). For example,
we can write a \verb|SPECTRE| program as:
\begin{verbatim}
    var a;
    if (canRead(SECRET)) { a[SECRET] := 1; }
    else if (touched a[0]) { x := 0; }
    else if (touched a[1]) { x := 1; }
\end{verbatim}
This is a low-security program, which is attempting to discover the
value of a high-security variable \verb|SECRET|. The low-security program
is allowed to attempt to escalate its privileges by checking that it is
allowed to read a high-security variable:
\begin{verbatim}
    if (canRead(x)) { ... code allowed to read x ... }
    else { ... fallback code ... }
\end{verbatim}
In this case, the \verb|canRead(SECRET)| is false, so the fallback code
is executed. Unfortunately, the escalated code is speculatively
evaluated, which allows information to leak by testing for which
memory locations have been touched.

We model the \verb|touched| test by introducing a new action
$(\DT{\aLoc})$ and defining:
\begin{eqnarray*}
  \sem{\IF \TOUCHED\aLoc\THEN \aCmd \ELSE \bCmd \FI} & = & ((\DT\aLoc) \prefix \sem{\aCmd}) \cup \sem{\bCmd}
\end{eqnarray*}
The additional requirement we need to add for $\aLoc$-closure is:
\begin{itemize}
\item if $\labelling(\aEv)=(\aForm \mid \DT{\aLoc})$
  then there is $\bEv<\aEv$
  where $\bEv$ reads or writes $\aLoc$.
\end{itemize}
Note that there is no requirement that $\bEv$ be satisfiable,
and indeed \verb|SPECTRE| has the execution:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{rs}{\DR{\SEC}{1}}{}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \po{rs}{wa}
  \po{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
Putting this in parallel with a high-security write to \verb|SECRET| gives:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{1}}{}
  \nonevent{rs}{\DR{\SEC}{1}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
but due the requirement of \verb|a|-closure we do \emph{not} have:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{0}}{}
  \nonevent{rs}{\DR{\SEC}{0}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[0]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{wa}{ta}
  \po{ta}{wx}
\end{tikzpicture}\]
Thus, the attacker has managed to leak the value of a high-security
location to a low-security one.

This shows how our model of speculative evaluation can express
(very abstract, untimed) Spectre attacks.

\subsection{Relaxed memory}

In \S\ref{sec:info-flow-attack} we present an information flow attack
on relaxed memory, similar to Spectre in that it relies on speculative
evalutation. Unlike Spectre it does not depend on timing attacks,
but instead is based on the sensitivity of relaxed memory to data
dependencies. For this reason, we present a simple model of relaxed
memory, which is strong enough to capture this attack.
The model includes concurrent memory accesses, which can introduce concurrent
reads-from. 
Since we are allowing events to be partially ordered, this gives a simple
model of relaxed memory, for example an independent read independent write
(IRIW) example is:
\begin{verbatim}
  x := 0; x := x+1; || y := 0; y := y+1; || if (x) { r := y; } || if (y) { s := x; }
\end{verbatim}
which includes the execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wy0}{\DW{y}{0}}{right=2.5em of wx1}
  \event{wy1}{\DW{y}{1}}{right=of wy0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy1}
  \event{ry0}{\DR{y}{0}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of ry0}
  \event{rx0}{\DR{x}{0}}{right=of ry1}
  \rf[out=30,in=150]{wx1}{rx1}
  \rf[out=30,in=150]{wy0}{ry0}
  \rf[out=340,in=200]{wy1}{ry1}
  \rf[out=340,in=200]{wx0}{rx0}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \po{rx1}{ry0}
  \po{ry1}{rx0}
\end{tikzpicture}\]
This model does not introduce thin-air reads (TAR),
for example the TAR pit program is:
\begin{verbatim}
  x := y; || y := x;
\end{verbatim}
but an attempt to produce a value from thin air fails,
for the usual reason of producing a cycle in $\le$:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry42}{\DR{y}{42}}{}
  \event{wx42}{\DW{x}{42}}{below=of ry42}
  \event{rx42}{\DR{x}{42}}{right=2.5em of ry42}
  \event{wy42}{\DW{y}{42}}{below=of rx42}
  \po{ry42}{wx42}
  \po{rx42}{wy42}
  \rf{wx42}{rx42}
  \rf{wy42}{ry42}
\end{tikzpicture}\]
This cycle can be broken if one of the writes does not depend on the read, for example:
\begin{verbatim}
  x := y; || r := x; y := r+1-r;
\end{verbatim}
has execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{y}{1}}{}
  \event{wx1}{\DW{x}{1}}{below=of ry1}
  \event{rx1}{\DR{x}{1}}{right=2.5em of ry1}
  \event{wy1}{\DW{y}{1}}{below=of rx1}
  \po{ry1}{wx1}
  \rf{wx1}{rx1}
  \rf{wy1}{ry1}
\end{tikzpicture}\]
Note that $(\DR x1) \not\le (\DW y1)$, so this does not introduce a cycle.

\subsection{Information flow attacks on relaxed memory}
\label{sec:info-flow-attack}

Consider an attacker program, again using security checks to
try to learn a \verb|SECRET|. Whereas \verb|SPECTRE| uses
hardware capabilities, which have to be modeled by adding
extra capabilities to the language, this new attacker works
by exploiting relaxed memory which can result in
unexpected information flows. The attacker program is:
\begin{verbatim}
  (
    x := 0; y := x;
  ) || (
    if (y == 0) { x := 1; }
    else if (canRead(SECRET)) { x := SECRET; }
    else { x := 1; z := 1; }
  )
\end{verbatim}
In the case where \verb|SECRET| is $2$, this has many executions,
one of which is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{ry0}{\DR{y}{0}}{right=2.5 em of wy0}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \nonevent{wx2}{\DW{x}{2}}{right=of wx1}
  \nonevent{wz1}{\DW{z}{1}}{right=of wx2}
  \po{ry0}{wx1}
  \po[out=30,in=150]{ry0}{wz1}
  \po[out=25,in=150]{ry0}{wx2}
  \rf{wy0}{ry0}
\end{tikzpicture}\]
but there are no executions which exhibit
$(\DW{z}{1})$, since any attempt to do so
produces a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{rx1}{\DR{x}{1}}{right=of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wx1}
  \event{wz1}{\DW{z}{1}}{right=of wx2}
  \po{rx1}{wy1}
  \po{ry1}{wx1}
  \po[out=30,in=150]{ry1}{wz1}
  \po[out=25,in=150]{ry1}{wx2}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
In the case where \verb|SECRET| is $1$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{rx1}{\DR{x}{1}}{right=of wx0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wz1}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
Note that in this case, there is no dependency from
$(\DR{y}{1})$ to $(\DW{x}{1})$, which is what makes this
execution possible. Thus, if the attacker sees
an execution with $(\DW{z}{1})$, they can conclude
that \verb|SECRET| is $1$, which is an information flow
attack.

This attack is not just an artifact of the model,
since the same behavior can be exhibited by
compiler optimizations. Consider the program fragment:
\begin{verbatim}
  if (y == 0) { x := 1; }
  else if (canRead(SECRET)) { x := SECRET; }
  else { x := 1; z := 1; }
\end{verbatim}
Now, in the case where \verb|SECRET| is a constant \verb|1|,
the compiler can inline it:
\begin{verbatim}
  if (y == 0) { x := 1; }
  else if (canRead(SECRET)) { x := 1; }
  else { x := 1; z := 1; }
\end{verbatim}
and lift the assignment to \verb|x| out of the \verb|if| statement:
\begin{verbatim}
  x := 1;
  if (y == 0) { }
  else if (canRead(SECRET)) { }
  else { z := 1; }
\end{verbatim}
After these optimizations, a sequentially consistent execution
exhibits $(\DW{z}{1})$. We discuss the practicality of this attack
further in \S\ref{sec:experiments}.

\subsection{Dead store elimination}
\label{sec:dse}

A common compiler optimization is \emph{dead store elimination},
in which writes are omitted if they will be overwritten by a subsequent
write later in the same thread. For example, in the program
\verb|(x := 1; x := 2)|, the first write to \verb|x| can be eliminated,
since the second is guaranteed:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{wx1}{\DW{x}{1}}{}
  \event{wx2}{\DW{x}{2}}{right=of wx1}
  \wk{wx1}{wx2}
\end{tikzpicture}\]
but in the program \verb|(x := 1; if (r) { x := 2; })| the first
write cannot be eliminated, since the second might not happen:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wx2}{r \mid \DW{x}{2}}{right=of wx1}
\end{tikzpicture}\]
A simple model of dead store elimination changes the semantics of
write to only introduce a write event if there is no subsequent guaranteed
write of the same variable. We can do this by giving a looser interpretation
of prefixing: in the definition of $(\phi \mid \aAct) \prefix \aPSS$,
replace the requirement:
\begin{itemize}
\item $\labelling'(0) = (\bForm, \aAct)$, where $\bForm$ implies $\aForm$,
\end{itemize}
by:
\begin{itemize}
\item either:
  \begin{itemize}
  \item $\labelling'(0) = (\bForm, \aAct)$, where $\bForm$ implies $\aForm$, or
  \item $\labelling(0) = (\bForm, \bAct)$, where $\aForm$ implies $\bForm$,
    and every location $\aAct$ writes to is also written to by $\bAct$.
  \end{itemize}
\end{itemize}
This simple model includes the examples above. Note that if dead store
elimination is \emph{always} performed, then there is an information
flow attack similar to the one in \S\ref{sec:info-flow-attack}. Consider
the program:
\begin{verbatim}
  (
    r := x;
  ) || (
    x := 1;
    if (canRead(SECRET)) { if (SECRET) { x := 2; } }
    else { x := 2; }
  )
\end{verbatim}
In the case that \verb|SECRET| is $0$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wx1}{\DW{x}{1}}{right=2.5em of rx1}
  \event{wx2}{\aForm \mid \DW{x}{2}}{right=of wx1}
  \rf{wx1}{rx1}
\end{tikzpicture}\]
where $\aForm$ is ($\lnot$\verb|canRead(SECRET)|),
which is not a tautology, and so the $(\DW{x}{1})$ event is not omitted.
In the case that \verb|SECRET| is not $0$, the matching execution
is:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx2}{\DR{x}{2}}{}
  \event{wx2}{\DW{x}{2}}{right=2.5em of rx2}
  \rf{wx2}{rx2}
\end{tikzpicture}\]
Now the $(\DW{x}{2})$ event is a guaranteed write, so the $(\DW{x}{1})$
is omitted. In the case that the attacker can rely on dead store
elimination taking place, this is an information flow: if the attacker observes
$x$ to be $1$, then they know \verb|SECRET| is $0$. We return to this attack
in \S\ref{sec:experiments}.

\subsection{Thread inlining}

One property one could ask of a model of shared memory is thread
inlining: any execution of $\sem{P\SEMI Q}$ is an execution of $\sem{P
  \PAR Q}$. This is \emph{not} a goal of our model, and indeed is not
satisfied, due to the different semantics of concurrent and sequential
memory accesses. We demonstrate this by considering an example from
the Java Memory Model~\cite{jmm}, which shows that Java does not
satisfy thread inlining either.

The lack of thread inlining is related to the different dependency
relations introduced by sequential and concurrent access.
Recall from \S\ref{sec:sequential-memory} that the program
\verb`(x := 0; y := x+1;)` has execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy1}{\DW{y}{1}}{right=of wx0}
\end{tikzpicture}\]
but that \verb`(x := 1; || y := x+1;)` has:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{rx1}{\DR{x}{1}}{right=2.5em of wx1}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
That is in the sequential case there is no depenency from the
write of $x$ to the write of $y$, but in the concurrent case there
is such a dependecy.

This can be used to construct a counter-example to thread inlining, based on~\cite[Ex~11]{jmm}:
\begin{verbatim}
  x := 0; if (x == 1) { z := 1; } else { x := 1; } || y := x; || x := y;
\end{verbatim}
This has no execution containing $(\DW z1)$. Any attempt to build such an execution
results in a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{rx1b}{\DR{x}{1}}{right=2.5em of wx1a}
  \event{wy1}{\DW{y}{1}}{right=of rx1b}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{wx1b}{\DW{x}{1}}{right=of ry1}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
  \po{rx1b}{wy1}
  \po{ry1}{wx1b}
  \rf{wy1}{ry1}
  \rf[out=160, in=30]{wx1b}{rx1a}
  \rf[out=160, in=30]{wx1b}{rx1b}
\end{tikzpicture}\]
Inlining the thread \verb|(y := x)| gives~\cite[Ex~12]{jmm}:
\begin{verbatim}
  x := 0; if (x == 1) { z := 1; } else { x := 1; } y := x; || x := y;
\end{verbatim}
with execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \event{ry1}{\DR{y}{1}}{right=2.5em of wy1}
  \event{wx1b}{\DW{x}{1}}{right=of ry1}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
  \po{ry1}{wx1b}
  \rf{wy1}{ry1}
  \rf[out=160, in=30]{wx1b}{rx1a}
\end{tikzpicture}\]
To see why this execution exists, consider the program fragment:
\begin{verbatim}
  if (x == 1) { z := 1; } else { x := 1; } y := x;
\end{verbatim}
Removing the syntax sugar, this is:
\begin{verbatim}
  r1 := x; if (r1 == 1) {
    z := 1; r2 := x; y := r2; skip
  } else {
    x := 1; r3 := x; y := r3; skip
  }
\end{verbatim}
Now, $\sem{z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP}$
includes pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{r_1=1 \mid \DW{z}{1}}{}
  \event{wy1}{r_1=x=1 \mid \DW{y}{1}}{right=of wz1}
\end{tikzpicture}\]
and $\sem{x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP}$
includes pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1a}{r_1\neq 1 \mid \DW{x}{1}}{}
  \event{wy1}{r_1\neq 1 \mid \DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
so  $\sem{\IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{r_1=1 \mid \DW{z}{1}}{}
  \event{wx1a}{r_1\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{(r_1=x=1) \lor (r_1\neq1) \mid \DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
which means $\sem{\IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}[x/r_1]$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{x=1 \mid \DW{z}{1}}{}
  \event{wx1a}{x\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{(x=x=1) \lor (x\neq1)) \mid \DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
Now $(x=x=1) \lor (x\neq1)$ is a tautology, so this is just:
\[\begin{tikzpicture}[node distance=1em]
  \event{wz1}{x=1 \mid \DW{z}{1}}{}
  \event{wx1a}{x\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
\end{tikzpicture}\]
and so $\sem{r_1 \GETS x\SEMI \IF (r_1 = 1) \THEN z := 1\SEMI r_2 := x\SEMI y := r_2\SEMI \SKIP \ELSE x := 1\SEMI r_3 := x\SEMI y := r_3\SEMI \SKIP \FI}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{1=1 \mid \DW{z}{1}}{right=of rx1a}
  \event{wx1a}{1\neq1 \mid \DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
\end{tikzpicture}\]
which simplifies to:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1a}{\DR{x}{1}}{}
  \event{wz1}{\DW{z}{1}}{right=of rx1a}
  \nonevent{wx1a}{\DW{x}{1}}{right=of wz1}
  \event{wy1}{\DW{y}{1}}{right=of wx1a}
  \po{rx1a}{wz1}
  \po[out=25, in=150]{rx1a}{wx1a}
\end{tikzpicture}\]
as required. The rest of the example is straightforward, and shows that our semantics
agrees with the JMM in not supporting thread inlining.

\subsection{Word tearing}

\todo{Remove this section, since it's not needed for transactions?}

In \S\ref{sec:transactions}, we shall be considering transactional memory,
and in \S\ref{sec:transactions} show that we can model a simplified version
of an information flow attack on transactions. In order to model transactions,
we need to consider actions that can write many memory locations at once,
since this is part of the semantics of commitment. To lead up to this, we first
consider a simpler scenario of many-location writes and reads, which is word
tearing.

In word tearing, a program contains a write instruction with data larger
than the hardware word size, for example copying a byte array, or assigning
a 64-bit float on a 32-bit architecture. For example, consider the program:
\begin{verbatim}
  (x := [0, 0];) || (x := [1, 1];) || (r := x;)
\end{verbatim}
This has executions in which the read of $x$ only reads from one of the writes,
for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx00}{\DW{x}{[0,0]}}{}
  \event{wx11}{\DW{x}{[1,1]}}{right=2.5em of wx00}
  \event{rx00}{\DR{x}{[0,0]}}{right=2.5em of wx11}
  \rf[out=20, in=160]{wx00}{rx00}
\end{tikzpicture}\]
but also has executions in which the read of $x$ reads from both writes,
for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx00}{\DW{x}{[0,0]}}{}
  \event{wx11}{\DW{x}{[1,1]}}{right=2.5em of wx00}
  \event{rx01}{\DR{x}{[0,1]}}{right=2.5em of wx11}
  \rfx[out=20, in=160]{wx00}{x[0]}{rx01}
  \rfx[out=-20, in=-160]{wx11}{x[1]}{rx01}
\end{tikzpicture}\]
Word tearing can occur, for example, in Java extended floating point~\cite{jmm},
LLVM 64-bit instructions on 32-bit hardware~\cite{llvm}, or in
JavaScript SharedArrayBuffers~\cite{js-sab}.

% Local Variables:
% TeX-master: "paper"
% End:
