\section{Examples}

\subsection{Independent write reordering}

Consider an example with two independent writes
\verb|(x := 1; y := 2;)|.
This has the semantics:
\[
  \bigcup_\aVal\; (1=\aVal \mid \DW x\aVal) \prefix \left(
    \bigcup_\bVal\; (2=\bVal \mid \DW y\aVal) \prefix \left(
      \{\emptyset\}
    \right)[2/y]
  \right)[1/x]
\]
which is the same as:
\[
  \bigcup_\aVal\; (1=\aVal \mid \DW x\aVal) \prefix
    \bigcup_\bVal\; (2=\bVal \mid \DW y\aVal) \prefix
      \{\emptyset\}
\]
which includes the case where $\aVal=1$ and $\bVal=2$:
\[
  (1=1 \mid \DW x1) \prefix
    (2=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
One of the executions this contains is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wx1}{wy2}
\end{tikzpicture}\]
but it also contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
\end{tikzpicture}\]
and:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of wx1}
  \po{wy2}{wx1}
\end{tikzpicture}\]
since there is no requirement that
$(\DW{x}{1}) \le (\DW{y}{2})$.

Thus, the semantics of \verb|(x := 1; y := 2;)|
is the same as the semantics of \verb|(y := 2; x := 1;)|.

\subsection{Dependencies on reads}

Whereas write prefixing introduces no new dependencies,
read prefixing can. For example the program
\verb|(r := x; y := r+1;)| has semantics:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR x\aVal) \prefix \left(
    \bigcup_\bVal\; (r+1=\bVal \mid \DW y\aVal) \prefix \left(
      \{\emptyset\}
    \right)[r+1/y]
  \right)[x/r]
\]
which is the same as:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR x\aVal) \prefix
    \bigcup_\bVal\; (x+1=\bVal \mid \DW y\aVal) \prefix
      \{\emptyset\}
\]
which includes the case where $\aVal=1$ and $\bVal=2$:
\[
  (\TRUE \mid \DR x1) \prefix
    (x+1=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
Now, since $\TRUE$ implies $(x+1=2)[1/x]$, this contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
but since $\TRUE$ does not imply $(x+1=2)$,
we have the requirement that $(\DR{x}{1}) \le (\DW{y}{2})$.

This is in contrast to the program 
\verb|(r := x; y := r+2-r;)|, which has
semantics:
\[
  \bigcup_\aVal\; (\TRUE \mid \DR x\aVal) \prefix
    \bigcup_\bVal\; (x+2-x=\bVal \mid \DW y\aVal) \prefix
      \{\emptyset\}
\]
Again, we consider the case where $\aVal=1$ and $\bVal=2$:
\[
  (\TRUE \mid \DR x1) \prefix
    (x+2-x=2 \mid \DW y2) \prefix
      \{\emptyset\}
\]
Now, since $\TRUE$ implies $(x+2-x=2)[1/x]$, this contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
but also $\TRUE$ implies $(x+2-x=2)$
(at least for arithmetic modulo $n$)
and so this also contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
\end{tikzpicture}\]
and:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{x}{1}}{}
  \event{wy2}{\DW{y}{2}}{right=of rx1}
  \po{wy2}{rx1}
\end{tikzpicture}\]
Thus, the semantics of \verb|(r := x; y := x+2-x;)|
is the same as the semantics of \verb|(y := 2; r := x;)|.

\subsection{Spectre}

We give a simplified model of Spectre attacks, ignoring the details of
timing.  In this model, we extend programs with the ability to tell
whether a memory location has been touched (in practice this is
implemented using timing attacks on the cache). For example,
we can write a \verb|SPECTRE| program as:
\begin{verbatim}
    var a;
    if (isCapability(0)) { a[SECRET] := 1; }
    else if (touched a[0]) { x := 0; }
    else if (touched a[1]) { x := 1; }
\end{verbatim}
This is a low-security program, which is attempting to discover the
value of a high-security variable \verb|SECRET|. The low-security program
is allowed to attempt to escalate its privileges by providing a capability
which demonstrates that they are entitled to run high-security code:
\begin{verbatim}
    if (isCapability(c)) { ... escalated code ... }
    else { ... fallback code ... }
\end{verbatim}
In this case, the \verb|isCapability(0)| is false, so the fallback code
is executed. Unfortunately, the escalated code is speculatively
evaluated, which allows information to leak by testing for which
memory locations have been touched.

We model the \verb|touched| test by introducing a new read action
$(\DT{\aLoc})$ and defining:
\begin{eqnarray*}
  \sem{\IF \TOUCHED\aLoc\THEN C \ELSE D} & = & ((\DT\aLoc) \prefix \sem{C}) \sqcup \sem{D}
\end{eqnarray*}
The additional requirement we need to add for $\aLoc$-closure is:
\begin{itemize}
\item if $\labelling(\aEv)=(\aForm \mid \DT{\aLoc})$
  then there is $\bEv\not>\aEv$ with $\labelling(\bEv)=(\bForm \mid \DR{\aLoc}{\aVal})$
  or $\labelling(\bEv)=(\bForm \mid \DW{\aLoc}{\aVal})$.
\end{itemize}
For example, one execution of \verb|SPECTRE| is:
\[\begin{tikzpicture}[node distance=1em]
  \nonevent{rs}{\DR{\SEC}{1}}{}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
Putting this in parallel with a high-security write to \verb|SECRET| gives:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{1}}{}
  \nonevent{rs}{\DR{\SEC}{1}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{1}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
but due the requirement of \verb|a|-closure we do \emph{not} have:
\[\begin{tikzpicture}[node distance=1em]
  \event{ws}{\DW{\SEC}{0}}{}
  \nonevent{rs}{\DR{\SEC}{0}}{right=2.5em of ws}
  \nonevent{wa}{\DW{a[1]}{0}}{right=of rs}
  \event{ta}{\DT{a[1]}}{right=of wa}
  \event{wx}{\DW{x}{1}}{right=of ta}
  \rf{ws}{rs}
  \po{rs}{wa}
  \po{ta}{wx}
\end{tikzpicture}\]
Thus, the attacker has managed to leak the value of a high-security
location to a low-security one.

This shows how a (very abstract, untimed) model of Spectre attacks
using speculative evaluation can be modelled.

\subsection{Information flow attacks on relaxed memory}

Consider an attacker program, again using security checks to
try to learn a \verb|SECRET|. Whereas \verb|SPECTRE| uses
hardware capabilities, which have to be modelled by adding
extra capabilities to the language, this new attacker works
by exploiting relaxed memory which can result in
unexpected information flows. The attacker program is:
\begin{verbatim}
  var x := 0; var y := 0;
  (
    y := x;
  ) || (
    r := y;
    if (isCapability(r)) { x := SECRET; }
    else { x := 1; z := r; }
  )
\end{verbatim}
In the case where \verb|SECRET| is $2$, this has many executions,
one of which is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry0}{\DR{y}{0}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry0}
  \event{wz0}{\DW{z}{0}}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wz0}
  \po{rx1}{wy1}
  \po{ry0}{wx1}
  \po[out=25,in=150]{ry0}{wz0}
  \po[out=30,in=150]{ry0}{wx2}
  \rf[out=30,in=150]{wy0}{ry0}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
but there are no executions which exhibit
$(\DW{z}{1})$, since any attempt to do so
produces a cycle:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of wz1}
  \po{rx1}{wy1}
  \po{ry1}{wx1}
  \po[out=25,in=150]{ry1}{wz1}
  \po[out=30,in=150]{ry1}{wx2}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
In the case where \verb|SECRET| is $1$, there is an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wy0}{\DW{y}{0}}{right=of wx0}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wy0}
  \event{wy1}{\DW{y}{1}}{right=of rx1}
  \event{ry1}{\DR{y}{1}}{right=2.5 em of wy1}
  \event{wx1}{\DW{x}{1}}{right=of ry1}
  \event{wz1}{\DW{z}{1}}{right=of wx1}
  \po{rx1}{wy1}
  \po[out=30,in=150]{ry1}{wz1}
  \rf{wy1}{ry1}
  \rf[out=210,in=330]{wx1}{rx1}
\end{tikzpicture}\]
Note that in this case, there is no dependency from
$(\DR{y}{1})$ to $(\DW{x}{1})$, which is what makes this
execution possible. Thus, if the attacker sees
an execution with $(\DW{z}{1})$, they can conclude
that \verb|SECRET| is $1$, which is an information flow
attack.

This attack is not just an artefact of the model,
since the same behaviour can be exhibited by
compiler optimizations. Consider the program fragment:
\begin{verbatim}
  r := y;
  if (isCapability(r)) { x := SECRET; }
  else { x := 1; z := r; }
\end{verbatim}
Now, in the case where \verb|SECRET| is a constant \verb|1|,
the compiler can inline it:
\begin{verbatim}
  r := y;
  if (isCapability(r)) { x := 1; }
  else { x := 1; z := r; }
\end{verbatim}
lift the assignment to \verb|x| out of the \verb|if| statement:
\begin{verbatim}
  r := y; x := 1;
  if (isCapability(r)) { }
  else { z := r; }
\end{verbatim}
and then perform independent read/write reordering:
\begin{verbatim}
  x := 1; r := y;
  if (isCapability(r)) { }
  else { z := r; }
\end{verbatim}
After these optimizations, a sequentially consistent execution
exhibits $(\DW{z}{1})$.
