\section{Model}

The model used in this paper is one of sets of pomsets with event labels of the form
$(\aForm \mid \aAct)$, where $\aForm$ is the event's precondition
(such as $\aExp=\aVal$) and $\aAct$ is the event's action (such as $\DW\aLoc\aVal$).
For example the semantics of the program $(\aLoc\GETS\aExp)$ includes the case
where $\aExp$ is $\aVal$, which is written to $\aLoc$, and is captured
by the one-event pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wxv}{\aExp=\aVal \mid \DW{\aLoc}{\aVal}}{}
\end{tikzpicture}\]
For this reason, the model is parameterized by a logic, used to express the
preconditions of actions. We make few requirements of this logic, save that it
has includes equalities between expressions, is closed under substitution,
and supports a notion of implication (and in particular a notion of when
a formula is a tautology).

The semantics is defined compositionally. For example, the program $(\aLoc\GETS\bLoc+1)$
is shorthand for $(\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1)$, which contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
This pomset is build compositonally. First, $\sem{\aLoc\GETS\aReg+1}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\aReg=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
Next, we perform the substitution of $\aReg$ with $1$ in every precondition,
to get that $\sem{\aLoc\GETS\aReg+1}[1/\aReg]$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{1=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
and since $1=1$ is a tautology, we elide it:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
This substitution is performed in defining
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1}$, which contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
as required. There is an ordering $(\DR{\bLoc}{1}) < (\DR{\aLoc}{2})$
because the precondition $(\aReg=1)$ depends on $\aReg$. If the preconditon
was independent of $\aReg$ then there would be no ordering, for example
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1-\aReg}$ contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of ry1}
\end{tikzpicture}\]
since the precondition $(\aReg+1-\aReg=1)$ is independent of $\aReg$.

The main novelty of our semantics, since it is designed to model
speculative evaluation, is in modelling conditionals. In most
sets-of-pomsets semantics, a pomset in
$\sem{\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI}$ would either be
given by a pomset in $\sem{\aCmd}$ or a pomset in $\sem{\bCmd}$.
To model speculative evaluation, we need to allow a pomset
in $\sem{\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI}$ to be given by
both a pomset in $\sem{\aCmd}$ \emph{and} a pomset in $\sem{\bCmd}$.
For example, $\sem{\IF(\aExp)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS2 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
\end{tikzpicture}\]
that is we have recorded behaviour from both branches of execution.
Moreover, an action which is performed on both sides of the
conditional can be merged, producing only one event in the resulting pomset.
The precondition of the merged event is the disjunction of the preconditions
of the original events.
For example
$\sem{\IF(\aExp)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{(\aExp\neq0) \lor (\aExp=0) \mid \DW{\bLoc}{3}}{right=of wx2}
\end{tikzpicture}\]
and since $(\aExp\neq0) \lor (\aExp=0)$ is a tautology, this is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
\end{tikzpicture}\]
Combining this model of conditionals with the model of memory using substitutions
gives that
$\sem{\IF(\cLoc)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{\cLoc}{1}}{}
  \event{wx1}{1\neq0 \mid \DW{\aLoc}{1}}{right=of rz1}
  \event{wx2}{1=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz1}{wx1}
  \po[out=25,in=155]{rz1}{wx2}
\end{tikzpicture}\]
and since $(1\neq0)$ is a tautology and $(1=0)$ is unsatisfiable, this is:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{\cLoc}{1}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of rz1}
  \nonevent{wx2}{\DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz1}{wx1}
  \po[out=25,in=155]{rz1}{wx2}
\end{tikzpicture}\]
Similarly,
$\sem{\IF(\cLoc)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{\cLoc}{0}}{}
  \nonevent{wx1}{\DW{\aLoc}{1}}{right=of rz0}
  \event{wx2}{\DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz0}{wx1}
  \po[out=25,in=155]{rz0}{wx2}
\end{tikzpicture}\]
Note that this semantics captures control dependencies
such as $(\DR\cLoc0)<(\DW\aLoc1)$, independencies
such as $(\DR\cLoc0)\not<(\DW\bLoc3)$, and failed
speculations such as the crossed out $(\DW\aLoc1)$.

In summary, the features we need of the underlying data model are:
\begin{itemize}
\item \emph{actions}, which may read or write to memory locations, and
\item \emph{preconditions}, which form a logic closed under substitution.
\end{itemize}
from which we can define the operations used in defining the semantics of programs,
which include:
\begin{itemize}
\item \emph{prefixing} $(\aForm\mid\aAct)\prefix\aPSS$, which adds an event
  with precondition $\aForm$ and action $\aAct$ to pomsets in $\aPSS$,
\item \emph{substitution} $\aPSS[\aExp/\aLoc]$, which performs a substitution
  on every precondition in $\aPSS$, and
\item \emph{join} $\aPSS_1\sqcup\aPSS_2$, which unions pomsets from
  $\aPSS_1$ and $\aPSS_2$, allowing events to be merged.
\end{itemize}
We make data models precise in~\S\ref{sec:preliminaries},
define pomsets in \S\ref{sec:pomsets},
and operations on sets of pomsets in~\S\ref{sec:sets-of-pomsets},
which are used to give a compositional semantics for
a simple imperative language in~\S\ref{sec:semantics}.

\subsection{Data models}
\label{sec:preliminaries}

A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{memory locations} $\Loc$, ranged over by
  $\aLoc$ and $\bLoc$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\bVal$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$ and $\bExp$,
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$, and
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$,
\end{itemize}
such that:
\begin{itemize}
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
\item expressions are closed under substitution for registers, written $\aExp[\bExp/\aReg]$,
\item formulae include at least $\TRUE$, $\FALSE$, and equalities of the form $(\aExp=\bExp)$ and $(\aLoc=\bExp)$,
\item formulae are closed under negation, conjunction, disjunction,
\item formulae are closed under substitution for registers or locations, written $\aForm[\bExp/\aReg]$ or $\aForm[\bExp/\aLoc]$,
\item there is a relation $\vDash$ between formulae, and
\item there are partial functions $\rreads$ and $\rwrites: (\Act \times \Loc) \fun \Val$,
\end{itemize}
We shall say $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$ whenever
$\rreads(\aAct,\aLoc) = \aVal$, and
$\aAct$ \emph{writes} $\aVal$ \emph{to} $\aLoc$ whenever
$\rwrites(\aAct,\aLoc) = \aVal$.
We shall say $\aForm$ \emph{implies} $\bForm$ whenever $\aForm\vDash\bForm$,
$\aForm$ is a \emph{tautology} whenever $\TRUE\vDash\aForm$,
$\aForm$ is \emph{unsatisfiable} whenever $\aForm\vDash\FALSE$, and
$\aForm$ is \emph{independent of $\aLoc$} whenever $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$ for every $\aVal$.
In examples, the actions are of the form $(\DR{\aLoc}{\aVal})$, which reads $\aVal$ from $\aLoc$,
and $(\DW{\aLoc}{\aVal})$, which writes $\aVal$ to $\aLoc$.
Going forward, we assume a given data model, though some examples in
\S\ref{sec:examples} make use of particular $\Act$.

\subsection{Pomsets}
\label{sec:pomsets}

Recall the definition of a pomset from~\cite{pomsets}:
\begin{definition}
  A \emph{pomset} $(\Event, {\le}, \labelling)$ with alphabet $\Alphabet$
  is a partial order $(\Event, {\le})$ together with a function
  $\labelling: \Event \fun \Alphabet$.
\end{definition}
Going forward, we fix the alphabet $\Alphabet=(\Formulae\times\Act)$.
We will write $(\aForm \mid \aAct)$ for the pair $(\aForm,\aAct)$,
elide $\aForm$ when $\aForm$ is a tautology, and write $\NEVER\aAct$ 
when $\aForm$ is unsatisfiable.
We lift terminology from logical formulae and actions to events,
for example if $\labelling(\aEv)=(\aForm\mid\aAct)$ and
$\labelling(\bEv)=(\bForm\mid\bAct)$ then we say:
\begin{itemize}
\item $\aEv$ implies $\bEv$ whenever $\aForm$ implies $\bForm$,
\item $\aEv$ is a tautology whenever $\aForm$ is a tautlogy,
\item $\aEv$ is unsatisfiable whenever $\aForm$ is unsatisfiable,
\item $\aEv$ is independent of $\aLoc$ whenever $\aForm$ is independent of $\aLoc$,
\item $\aEv$ writes $\aVal$ to $\aLoc$ whenever $\aAct$ writes $\aVal$ to $\aLoc$, and
\item $\aEv$ reads $\aVal$ from $\aLoc$ whenever $\aAct$ reads $\aVal$ from $\aLoc$.
\end{itemize}
We visualize a pomset as a graph where the nodes are drawn from
$\Event$, each node $\aEv$ is labelled with $\labelling(\aEv)$,
and an edge $\bEv \rightarrow \aEv$ corresponds to an ordering
$\bEv\le\aEv$. For example:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \nonevent{wy0}{\DW{\bLoc}{0}}{below left=of rx1}
  \event{wy1}{\DW{\bLoc}{1}}{below right=of rx1}
  \po{rx1}{wy0}
  \po{rx1}{wy1}
\end{tikzpicture}\]
is a visualization of the pomset where:
\[
  0 \le 1 \quad
  0 \le 2 \quad
  \labelling(0) = (\TRUE, \DR{\aLoc}{1}) \quad
  \labelling(1) = (\FALSE, \DW{\bLoc}{0}) \quad
  \labelling(2) = (\TRUE, \DW{\bLoc}{1}) \quad
\]
Pomsets by themselves do not capture which
read events have a matching write. This is necessary for
a compositional concurrent semantics, for example a program
whose semantics includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rx0}{\DR{\aLoc}{0}}{right=5em of wx1}
  \event{wy0}{\DW{\bLoc}{0}}{below left=of rx0}
  \nonevent{wy1}{\DW{\bLoc}{1}}{below right=of rx0}
  \po{rx0}{wy0}
  \po{rx0}{wy1}
\end{tikzpicture}\]
may be put in parallel
with another program which writes $0$ to $\aLoc$.
If $\aLoc$ is scoped, though, such a program cannot exist,
so we need each read of $\aLoc$ to have a matching write.
This is captured by the \emph{reads-from} relation~\cite{???}, which we adapt to our setting.
\begin{definition}
  An \emph{rf-pomset} is a pomset together with a
  $\RF \subseteq (\Event\times\Loc\times\Event)$ such that for any $(\bEv,\aLoc,\aEv) \in \RF$:
  \begin{itemize}
  \item $\bEv < \aEv$,
  \item $\aEv$ implies $\bEv$,
  \item $\bEv$ writes $\aVal$ to $\aLoc$,
    and $\aEv$ reads $\aVal$ from $\aLoc$, and
  \item there is no $\bEv < \cEv < \aEv$ such that
    $\aEv$ implies $\cEv$ and
    $\cEv$ writes $\bVal$ to $\aLoc$.
  \end{itemize}
\end{definition}
We visualize rf-pomsets by drawing a dashed edge between nodes in $\RF$,
labelled with the memory location,
for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{x1}{\DR{\aLoc}{1}}{right=5em of wx1}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \rfx{wx1}{x}{x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
In most cases, the memory location is obvious from context,
so we elide it:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{x1}{\DR{\aLoc}{1}}{right=5em of wx1}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \rf{wx1}{x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
In the case where $\aLoc$ is scoped, every read of $\aLoc$, must have a matching write,
and there can be no preconditions dependent on $\aLoc$:
\begin{definition}
  An rf-pomset is $\aLoc$-closed if
  for every $\aEv\in\Event$:
  \begin{itemize}
  \item $\aEv$ is independent of $\aLoc$, and
  \item if $\aEv$ reads $\aVal$ from $\aLoc$, then there is a $\bEv$ with $(\bEv,\aLoc,\aEv) \in \RF$.
  \end{itemize}
\end{definition}

\subsection{Sets of pomsets}
\label{sec:sets-of-pomsets}

Our model of programs is going to be sets of rf-pomsets. In this section we define
the operations on pomsets which are used in giving the semantics. These
operations such as prefixing, choice, parallel composition, and so on, which are familiar
from models of concurrency such as~\cite{ccs,csp}, but adapted to the setting of speculative
evaluation.

\begin{definition}
Let $\aPS_0 \in (\aPSS_1 \sqcup \aPSS_2)$
whenever there are $\aPS_1 \in \aPSS_1$ and $\aPS_2 \in \aPSS_2$ such that:
\begin{itemize}
\item $\Event_0 = \Event_1 \cup \Event_2$,
\item $\RF_0 = \RF_1 \cup \RF_2$,
\item if $\aEv \le_1 \bEv$ or $\aEv \le_2 \bEv$ then $\aEv \le_0 \bEv$,
\item if $\labelling_0(\aEv) = (\aForm_0 \mid \aAct)$ then either:
  \begin{itemize}
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$
    and $\aForm_0$ implies $\aForm_1 \lor \aForm_2$,
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\aEv \not\in \Event_2$
    and $\aForm_0$ implies $\aForm_1$, or
  \item $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$ and $\aEv \not\in \Event_1$
    and $\aForm_0$ implies $\aForm_2$.
  \end{itemize}
\end{itemize}
\end{definition}
We use $\aPSS_1 \sqcup \aPSS_2$ in defining the semantics of conditionals.
It contains the union of pomsets from $\aPSS_1$ and $\aPSS_2$,
allowing overlap as long as they agree on actions. For example, if
$\aPSS_1$ and $\aPSS_2$ contain:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \mid \bAct}{right=of a}
  \po{a}{b}
\end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm_2 \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{b}{c}
\end{tikzpicture}\]
then $\aPSS_1 \sqcup \aPSS_2$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \lor \bForm_2 \mid \bAct}{right=of a}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{a}{b}
  \po{b}{c}
\end{tikzpicture}\]
\begin{definition}
Let $\aPSS_1 \parallel \aPSS_2$ be defined the same as $\aPSS_1 \sqcup \aPSS_2$ except that:
\begin{itemize}
\item $\RF_0 \supseteq \RF_1 \cup \RF_2$, and
 for any $\bEv, \aEv \in \Event_i$, if $(\bEv,\aEv)\in\RF_0$ then $(\bEv,\aEv)\in\RF_i$.
\end{itemize}
\end{definition}

\begin{definition}
Let $(\phi \mid \aAct) \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{0\}$,
\item $\RF' = \RF$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item $\labelling'(0) = (\bForm, \aAct)$, where $\bForm$ implies $\aForm$, and
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then:
  \begin{itemize}
  \item $\labelling'(\aEv) = (\bForm' \mid \bAct)$,
  \item $\bForm'$ implies $\bForm[\vec\aVal/\vec\aLoc]$, where $\aAct$ reads $\vec\aVal$ from $\vec\aLoc$, and
  \item if $\bForm$ is dependent on $\vec\aLoc$ or
    there is some location that both $\aAct$ and $\bAct$ write to,
    then $0 \le' \aEv$.
  \end{itemize}
\end{itemize}
\end{definition}

\begin{definition}
Let $\aPSS[\aExp/\aLV]$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event$,
\item $\RF' = \RF$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$, and
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) = (\bForm[\aExp/\aLV] \mid \aAct)$.
\end{itemize}
\end{definition}

\begin{definition}
Let $(\aForm \mid \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever:
\begin{itemize}
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\aForm$ implies $\bForm$.
\end{itemize}
\end{definition}

\begin{definition}
Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aPS$ is $\aLoc$-closed.
\end{definition}

\subsection{Semantics of programs}
\label{sec:semantics}

Define:
\begin{eqnarray*}
  \sem{\SKIP} & = & \{ \emptyset \} \\
  \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = & \bigcup_\aVal\; (\aExp=\aVal \mid \DW\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc] \\
  \sem{\aReg\GETS\aLoc\SEMI \aCmd} & = & \sem{\aCmd}[\aLoc/\aReg] \cup \bigcup_\aVal\; (\TRUE \mid \DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  \sem{\IF \aExp \THEN \aCmd \ELSE \bCmd} & = & (\aExp \neq 0 \mid \sem{\aCmd}) \sqcup (\aExp=0 \mid \sem{\bCmd}) \\
  \sem{\aCmd \PAR \bCmd} & = & \sem{\aCmd} \parallel \sem{\bCmd} \\
  \sem{\VAR\aLoc\SEMI \aCmd} & = & \nu \aLoc \st \sem{\aCmd}
\end{eqnarray*}
