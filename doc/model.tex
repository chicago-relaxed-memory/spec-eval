\section{Model}

The model used in this paper is one of pomsets with event labels of the form
$(\aForm \mid \aAct)$, where $\aForm$ is the event's precondition
(such as $\aExp=\aVal$) and $\aAct$ is the event's action (such as $\DW\aLoc\aVal$).
For example the semantics of the program $(\aLoc\GETS\aExp)$ includes the case
where $\aExp$ is $\aVal$, which is written to $\aLoc$, and is captured
by the one-event pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wxv}{\aExp=\aVal \mid \DW{\aLoc}{\aVal}}{}
\end{tikzpicture}\]
For this reason, the model is parameterized by a logic, used to express the
preconditions of actions. We make few requirements of this logic, save that it
has includes equalities between expressions, is closed under substitution,
and supports a notion of implication (and in particular a notion of when
a formula is a tautology).

The semantics is defined compositionally. For example, the program $(\aLoc\GETS\bLoc+1)$
is shorthand for $(\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1)$, which contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
This pomset is build compositonally. First, $\sem{\aLoc\GETS\aReg+1}$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\aReg=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
Next, we perform the substitution of $\aReg$ with $1$ to get that
$\sem{\aLoc\GETS\aReg+1}[1/\aReg]$
contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{1=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
and since $1=1$ is a tautology, we elide it:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
This substitution is performed in defining
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1}$, which contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
as required. There is an ordering $(\DR{\bLoc}{1}) < (\DR{\aLoc}{2})$
because the precondition $(\aReg=1)$ depends on $\aReg$. If the preconditon
was independent of $\aReg$ then there would be no ordering, for example
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1-\aReg}$, contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of ry1}
\end{tikzpicture}\]
since the precondition $(\aReg+1-\aReg=1)$ is independent of $\aReg$.

\subsection{Preliminaries}

We assume:
\begin{itemize}
\item a set of \emph{memory locations} $\Loc$, ranged over by
  $\aLoc$ and $\bLoc$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\bVal$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$ and $\bExp$,
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$, and
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$,
\end{itemize}
such that:
\begin{itemize}
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
\item expressions are closed under substitution, written $\aExp[\bExp/\aReg]$,
\item formulae include at least $\TRUE$, $\FALSE$, and equalities of the form $(\aExp=\bExp)$ and $(\aLoc=\bExp)$,
\item formulae are closed under negation, conjunction, disjunction,
\item formulae are closed under substitution, written $\aForm[\bExp/\aLV]$, and
\item there are relations $\rreads$ and $\rwrites \subseteq (\Act \times \Loc \times \Val)$,
\end{itemize}
where:
\begin{itemize}
\item the set of \emph{lvalues} is $\LVal=(\Loc\cup\Reg)$, ranged over by $\aLV$ and $\bLV$.
\end{itemize}
We shall say $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$ whenever
$(\aAct,\aLoc,\aVal) \in \rreads$, and
$\aAct$ \emph{writes} $\aVal$ \emph{to} $\aLoc$ whenever
$(\aAct,\aLoc,\aVal) \in \rwrites$.
In examples, the actions are of the form $(\DR{\aLoc}{\aVal})$, which reads $\aVal$ from $\aLoc$,
and $(\DW{\aLoc}{\aVal})$, which writes $\aVal$ to $\aLoc$.

\subsection{Pomsets}

\begin{definition}
  A \emph{pomset} $(\Event, {\le}, \labelling)$ with alphabet $\Alphabet$
  is a partial order $(\Event, {\le})$ together with a function
  $\labelling: \Event \fun \Alphabet$.
\end{definition}
Going forward, we fix the alphabet $\Alphabet=(\Formulae\times\Act)$.
We will write $(\aForm \mid \aAct)$ for the pair $(\aForm,\aAct)$,
$\aAct$ for $(\TRUE,\aAct)$ and $\NEVER\aAct$ for $(\FALSE,\aAct)$.

We visualize a pomset as a graph where the nodes are drawn from
$\Event$, each node $\aEv$ is labelled with $\labelling(\aEv)$,
and an edge $\bEv \rightarrow \aEv$ corresponds to an ordering
$\bEv\le\aEv$. For example:

\[\begin{tikzpicture}[node distance=1em]
  \event{x1}{\DR{\aLoc}{1}}{}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
is a visualization of the pomset where:
\[
  0 \le 1 \quad
  0 \le 2 \quad
  \labelling(0) = (\TRUE, \DR{\aLoc}{1}) \quad
  \labelling(1) = (\FALSE, \DW{\bLoc}{0}) \quad
  \labelling(2) = (\TRUE, \DW{\bLoc}{1}) \quad
\]
As we shall see, this is a possible execution of the
program:
\begin{verbatim}
    r := x; if (r) { y := 1; } else { y := 0; }
\end{verbatim}

\begin{definition}
  An \emph{rf-pomset} is a pomset together with a
  $\RF \subseteq (\Event\times\Loc\times\Event)$ such that for any $(\bEv,\aLoc,\aEv) \in \RF$: 
  \begin{itemize}
  \item $\bEv < \aEv$,
  \item $\labelling(\bEv)$ writes $\aVal$ to $\aLoc$,
    and $\labelling(\aEv)$ reads $\aVal$ from $\aLoc$, and
  \item there is no $\bEv < \cEv < \aEv$ such that
    $\labelling(\cEv)$ writes $\bVal$ to $\aLoc$.
  \end{itemize}
\end{definition}
We visualize rf-pomsets by drawing a dashed edge between nodes in $\RF$,
labelled with the memory location,
for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{x1}{\DR{\aLoc}{1}}{right=5em of wx1}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \rfx{wx1}{x}{x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
In most cases, the memory location is obvious from context,
so we elide it:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{x1}{\DR{\aLoc}{1}}{right=5em of wx1}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \rf{wx1}{x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
As we shall see, this is a possible execution of the
program:
\begin{verbatim}
    x := 1;  ||  r := x; if (r) { y := 1; } else { y := 0; }
\end{verbatim}
\begin{definition}
  An rf-pomset is $\aLoc$-closed if
  for $\aEv\in\Event$ with $\labelling(\aEv)=(\aForm \mid \aAct)$:
  \begin{itemize}
  \item $\aForm$ is independent of $\aLoc$, and
  \item if $\aAct$ reads $\aVal$ from $\aLoc$, then there is a $\bEv$ with $(\bEv,\aLoc,\aEv) \in \RF$.
  \end{itemize}
\end{definition}

\subsection{Sets of pomsets}

Let $\aPSS_1 \sqcup \aPSS_2$ be the set $\aPSS_0$ where $\aPS_0 \in \aPSS_0$
whenever there are $\aPS_1 \in \aPSS_1$ and  $\aPS_2 \in \aPSS_2$ such that:
\begin{itemize}
\item $\Event_0 = \Event_1 \cup \Event_2$,
\item $\RF_0 = \RF_1 \cup \RF_2$,
\item if $\aEv \le_1 \bEv$ or $\aEv \le_2 \bEv$ then $\aEv \le_0 \bEv$,
\item if $\labelling_0(\aEv) = (\aForm_0 \mid \aAct)$ then either:
  \begin{itemize}
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$
    and $\aForm_0$ implies $\aForm_1 \lor \aForm_2$,
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\aEv \not\in \Event_2$
    and $\aForm_0$ implies $\aForm_1$, or
  \item $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$ and $\aEv \not\in \Event_1$
    and $\aForm_0$ implies $\aForm_2$.
  \end{itemize}
\end{itemize}
Let $\aPSS_1 \parallel \aPSS_2$ be defined the same as $\aPSS_1 \sqcup \aPSS_2$ except that:
\begin{itemize}
\item $\RF_0 \supseteq \RF_1 \cup \RF_2$, and
 for any $\bEv, \aEv \in \Event_i$, if $(\bEv,\aEv)\in\RF_0$ then $(\bEv,\aEv)\in\RF_i$.
\end{itemize}
Let $(\phi \mid \aAct) \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{0\}$,
\item $\RF' = \RF$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item $\labelling'(0) = (\bForm, \aAct)$, where $\bForm$ implies $\aForm$, and
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then:
  \begin{itemize}
  \item $\labelling'(\aEv) = (\bForm' \mid \bAct)$,
  \item $\bForm'$ implies $\bForm[\vec\aVal/\vec\aLoc]$, where $\aAct$ reads $\vec\aVal$ from $\vec\aLoc$, and
  \item $0 \le' \aEv$ or $\bForm'$ implies $\bForm$.
  \end{itemize}
\end{itemize}
Let $\aPSS[\aExp/\aLV]$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event$,
\item $\RF' = \RF$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$, and
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) = (\bForm[\aExp/\aLV] \mid \aAct)$.
\end{itemize}
Let $(\aForm \mid \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever:
\begin{itemize}
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\aForm$ implies $\bForm$.
\end{itemize}
Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aPS$ is $\aLoc$-closed.

\subsection{Semantics of programs}

Define:
\begin{eqnarray*}
  \sem{\SKIP} & = & \{ \emptyset \} \\
  \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = & \bigcup_\aVal\; (\aExp=\aVal \mid \DW\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc] \\
  \sem{\aReg\GETS\aLoc\SEMI \aCmd} & = & \sem{\aCmd}[\aLoc/\aReg] \cup \bigcup_\aVal\; (\TRUE \mid \DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  \sem{\IF \aExp \THEN \aCmd \ELSE \bCmd} & = & (\aExp \neq 0 \mid \sem{\aCmd}) \sqcup (\aExp=0 \mid \sem{\bCmd}) \\
  \sem{\aCmd \PAR \bCmd} & = & \sem{\aCmd} \parallel \sem{\bCmd} \\
  \sem{\VAR\aLoc\SEMI \aCmd} & = & \nu \aLoc \st \sem{\aCmd}
\end{eqnarray*}
