\section{Model}
\label{sec:model}

The model used in this paper is one of sets of pomsets with event labels of the form
$(\aForm \mid \aAct)$, where $\aForm$ is the event's precondition
(such as $\aExp=\aVal$) and $\aAct$ is the event's action (such as $\DW\aLoc\aVal$).
For example the semantics of the program $(\aLoc\GETS\aExp)$ includes the case
where $\aExp$ is $\aVal$, which is written to $\aLoc$, and is captured
by the one-event pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wxv}{\aExp=\aVal \mid \DW{\aLoc}{\aVal}}{}
\end{tikzpicture}\]
We make few requirements of the logic of preconditions, save that it
has includes equalities between expressions, is closed under substitution,
and supports a notion of implication.

For example, the set of pomsets $\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1}$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
The semantics is defined compositionally. First, $\sem{\aLoc\GETS\aReg+1}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\aReg=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
Next, we perform the substitution of $\aReg$ with $1$ in every precondition,
to get that $\sem{\aLoc\GETS\aReg+1}[1/\aReg]$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{1=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
and since $(1=1)$ is a tautology, we elide it:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
This substitution is performed in defining
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1}$, which contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
as required. There is an ordering $(\DR{\bLoc}{1}) < (\DW{\aLoc}{2})$
because the precondition $(\aReg=1)$ depends on $\aReg$. If the precondition
was independent of $\aReg$ then there would be no ordering, for example
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1-\aReg}$ contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of ry1}
\end{tikzpicture}\]
since the precondition $(\aReg+1-\aReg=1)$ is independent of $\aReg$.

The main novelty of our semantics, since it is designed to model
speculative evaluation, is in modeling conditionals. In most
sets-of-pomsets semantics, a pomset in
$\sem{\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI}$ would either be
given by a pomset in $\sem{\aCmd}$ or a pomset in $\sem{\bCmd}$.
To model speculative evaluation, we need to allow a pomset
in $\sem{\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI}$ to be given by
both a pomset in $\sem{\aCmd}$ \emph{and} a pomset in $\sem{\bCmd}$.
For example, $\sem{\IF(\aExp)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS2 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
\end{tikzpicture}\]
that is we have recorded behavior from both branches of execution.
Moreover, an action which is performed on both sides of the
conditional can be merged, producing only one event in the resulting pomset.
The precondition of the merged event is the disjunction of the preconditions
of the original events.
For example
$\sem{\IF(\aExp)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{(\aExp\neq0) \lor (\aExp=0) \mid \DW{\bLoc}{3}}{right=of wx2}
\end{tikzpicture}\]
and since $(\aExp\neq0) \lor (\aExp=0)$ is a tautology, this is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
\end{tikzpicture}\]
Combining this model of conditionals with the model of memory using substitutions
gives that
$\sem{\IF(\cLoc)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{\cLoc}{1}}{}
  \event{wx1}{1\neq0 \mid \DW{\aLoc}{1}}{right=of rz1}
  \event{wx2}{1=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz1}{wx1}
  \po[out=25,in=155]{rz1}{wx2}
\end{tikzpicture}\]
and since $(1\neq0)$ is a tautology and $(1=0)$ is unsatisfiable, this is:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{\cLoc}{1}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of rz1}
  \nonevent{wx2}{\DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz1}{wx1}
  \po[out=25,in=155]{rz1}{wx2}
\end{tikzpicture}\]
Similarly,
$\sem{\IF(\cLoc)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{\cLoc}{0}}{}
  \nonevent{wx1}{\DW{\aLoc}{1}}{right=of rz0}
  \event{wx2}{\DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz0}{wx1}
  \po[out=25,in=155]{rz0}{wx2}
\end{tikzpicture}\]
Note that this semantics captures control dependencies
such as $(\DR\cLoc0)<(\DW\aLoc1)$, independencies
such as $(\DR\cLoc0)\not<(\DW\bLoc3)$, and failed
speculations such as the crossed out $(\DW\aLoc1)$.

In summary, the features we need of the underlying data model are:
\begin{itemize}
\item \emph{actions}, which may read or write to memory locations, and
\item \emph{preconditions}, which form a logic closed under substitution,
\end{itemize}
from which we can define the operations used in defining the semantics of programs,
which include:
\begin{itemize}
\item \emph{prefixing} $\aAct\prefix\aPSS$, which adds an event
  with precondition $\aForm$ and action $\aAct$ to pomsets in $\aPSS$,
\item \emph{substitution} $\aPSS[\aExp/\aLoc]$, which performs a substitution
  on every precondition in $\aPSS$, and
\item \emph{concurrency} $\aPSS_1\parallel\aPSS_2$, which unions pomsets from
  $\aPSS_1$ and $\aPSS_2$, allowing events to be merged.
\end{itemize}
We make data models precise in~\S\ref{sec:preliminaries},
define pomsets in \S\ref{sec:pomsets},
and operations on sets of pomsets in~\S\ref{sec:sets-of-pomsets},
which are used to give a compositional semantics for
a simple imperative language.

\subsection{Data models}
\label{sec:preliminaries}

A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{memory locations} $\Loc$, ranged over by
  $\aLoc$ and $\bLoc$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\bVal$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$ and $\bExp$,
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$, and
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$,
\end{itemize}
such that:
\begin{itemize}
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
\item expressions are closed under substitutions of the form $\aExp[\bExp/\aReg]$,
\item formulae include at least $\TRUE$, $\FALSE$, and equalities of the form $(\aExp=\bExp)$ and $(\aLoc=\bExp)$,
\item formulae are closed under negation, conjunction, disjunction,
\item formulae are closed under substitutions of the form $\aForm[\aLoc/\aReg]$ or $\aForm[\bExp/\aLoc]$,
\item there is a relation $\vDash$ between formulae, and
\item there are partial functions $\rreads$ and $\rwrites: \Act \fun (\Loc \times \Val)$.
\end{itemize}
We shall say $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$ whenever
$\rreads(\aAct) = (\aLoc,\aVal)$, and
$\aAct$ \emph{writes} $\aVal$ \emph{to} $\aLoc$ whenever
$\rwrites(\aAct) = (\aLoc,\aVal)$.
We shall say $\aForm$ \emph{implies} $\bForm$ whenever $\aForm\vDash\bForm$,
$\aForm$ is a \emph{tautology} whenever $\TRUE\vDash\aForm$,
$\aForm$ is \emph{unsatisfiable} whenever $\aForm\vDash\FALSE$, and
$\aForm$ is \emph{independent of $\aLoc$} whenever $\aForm \vDash \aForm[\aVal/\aLoc] \vDash \aForm$ for every $\aVal$.
In examples, the actions are of the form $(\DR{\aLoc}{\aVal})$, which reads $\aVal$ from $\aLoc$,
and $(\DW{\aLoc}{\aVal})$, which writes $\aVal$ to $\aLoc$.
Going forward, we assume a given data model, though some examples in
\S\ref{sec:examples} make use of particular actions.

\subsection{3-valued pomsets}
\label{sec:pomsets}

Recall the definition of a pomset from~\cite{GISCHER1988199}:
\begin{definition}
  A \emph{pomset} $(\Event, {\le}, \labelling)$ with alphabet $\Alphabet$
  is a partial order $(\Event, {\le})$ together with
  $\labelling: \Event \fun \Alphabet$.
\end{definition}
Going forward, we fix the alphabet $\Alphabet=(\Formulae\times\Act)$.
We will write $(\aForm \mid \aAct)$ for the pair $(\aForm,\aAct)$,
elide $\aForm$ when $\aForm$ is a tautology, and write $\aAct$ crossed-out ($\NEVER\aAct$)
when $\aForm$ is unsatisfiable.
We lift terminology from logical formulae and actions to events,
for example if $\labelling(\aEv)=(\aForm\mid\aAct)$ and
then we say
$\aEv$ is unsatisfiable whenever $\aForm$ is unsatisfiable,
$\aEv$ writes $\aVal$ to $\aLoc$ whenever $\aAct$ writes $\aVal$ to $\aLoc$, and
so forth.
We visualize a pomset as a graph where the nodes are drawn from
$\Event$, each node $\aEv$ is labelled with $\labelling(\aEv)$,
and an edge $\bEv \rightarrow \aEv$ corresponds to an ordering
$\bEv\le\aEv$. For example:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \nonevent{wy0}{\DW{\bLoc}{0}}{right=of rx1}
  \event{wy1}{\DW{\bLoc}{1}}{right=of wy0}
  \po{rx1}{wy0}
  \po[out=30,in=150]{rx1}{wy1}
\end{tikzpicture}\]
is a visualization of the pomset where:
\[
  0 \le 1 \quad
  0 \le 2 \quad
  \labelling(0) = (\TRUE, \DR{\aLoc}{1}) \quad
  \labelling(1) = (\FALSE, \DW{\bLoc}{0}) \quad
  \labelling(2) = (\TRUE, \DW{\bLoc}{1}) \quad
\]
We are building a compositional semantics of shared memory
concurrency, which means we require a notion of when
a read has a matching write. This is a property we require
of closed programs, but \emph{not} of open programs.
For example a program whose semantics includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{rx0}{\DR{\aLoc}{0}}{right=2.5em of wx1}
  \event{wy0}{\DW{\bLoc}{0}}{right=of rx0}
  \nonevent{wy1}{\DW{\bLoc}{1}}{right=of wy0}
  \po{rx0}{wy0}
  \po[out=30,in=150]{rx0}{wy1}
\end{tikzpicture}\]
may be put in parallel
with another program which writes $0$ to $\aLoc$.
If the program is closed with respect to $\aLoc$ though, such an execution cannot exist,
so we need each read of $\aLoc$ to have a matching write.
This is captured by defining when $\aEv$ \emph{reads $\aLoc$ from} $\bEv$~\cite{alglave}.
A preliminary definition (which, as we shall see, needs to be strengthened) is:
\begin{itemize}
\item $\bEv < \aEv$,
\item if $\aEv$ is satisfiable, then $\bEv$ is a tautology,
\item $\bEv$ writes $\aVal$ to $\aLoc$,
  and $\aEv$ reads $\aVal$ from $\aLoc$, and
\item there is no $\bEv < \cEv < \aEv$ such that
  $\cEv$ writes to $\aLoc$.
\end{itemize}
% In diagrams, for readability we often highlight the reads-from edges,
% for example:
%% We visualize rf-pomsets by drawing a dashed edge between nodes in $\RF$,
%% labelled with the memory location,
%% for example:
%% \[\begin{tikzpicture}[node distance=1em]
%%   \event{wx1}{\DW{\aLoc}{1}}{}
%%   \event{x1}{\DR{\aLoc}{1}}{right=5em of wx1}
%%   \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
%%   \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
%%   \rfx{wx1}{x}{x1}
%%   \po{x1}{y0}
%%   \po{x1}{y1}
%% \end{tikzpicture}\]
%% In most cases, the memory location is obvious from context,
%% so we elide it:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx1}{\DW{\aLoc}{1}}{}
%   \event{x1}{\DR{\aLoc}{1}}{right=2.5em of wx1}
%   \nonevent{y0}{\DW{\bLoc}{0}}{right=of x1}
%   \event{y1}{\DW{\bLoc}{1}}{right=of y0}
%   \rf{wx1}{x1}
%   \po{x1}{y0}
%   \po[out=30,in=150]{x1}{y1}
% \end{tikzpicture}\]
Unfortunately by itself, this is not enough. The problem is the final
clause saying that there does not exist an $\aLoc$-\emph{blocking}
event $\cEv$ between $\bEv$ and $\aEv$. Unfortunately, concurrency can
turn events that were not $\aLoc$-blockers into an $\aLoc$-blocker,
\emph{even if the new thread does not mention $\aLoc$.}
We give an example to show this in \S\ref{sec:blockers}.

There are a number of ways this can be addressed; for example,
in models such as~\cite{Batty:2011:MCC:1926385.1926394} the reads-from relation is taken
as a primitive. In this paper, we propose \emph{3-valued pomsets}
as a solution. These are pomsets in which, in addition to positive statements
$(\bEv < \aEv)$ (interpreted as $\aEv$ depends on $\bEv$),
we also have negative statements $(\bEv \ltN \aEv)$
(interpreted as $\aEv$ cannot depend on $\bEv$).

\begin{definition}
  A \emph{3-valued poset} $(\Event,{\le},{\ltN})$ is a poset $(\Event,{\le})$
  together with ${\ltN} \subseteq (\Event\times\Event)$ such that:
  \begin{itemize}
  \item if $\bEv \le \aEv$ then $\aEv \ltN \bEv$,
  \item if $\bEv \le \aEv$ and $\bEv \ltN \aEv$ then $\bEv = \aEv$,
  \item if $\cEv \ge \bEv \ltN \aEv$ or $\cEv \ltN \bEv \ge \aEv$ then $\cEv \ltN \aEv$.
  \end{itemize}
\end{definition}

\begin{definition}
  A \emph{3-valued pomset} $(\Event, {\le}, {\ltN}, \labelling)$
  is a 3-valued poset $(\Event, {\le}, {\ltN})$ and
  a pomset $(\Event, {\le}, \labelling)$.
\end{definition}

In diagrams, we visualize $(\aEv \ltN \bEv)$ as a dashed
arrow from $\bEv$ to $\aEv$ (note the change of direction).
We refer to edges introduced by $(\bEv < \aEv)$ as
\emph{strong edges} and by $(\aEv \ltN \bEv)$
as \emph{weak edges}.
For readability, we often highlight the reads-from edges as well.
% for example:
For example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{\aLoc}{0}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of wx0}
  \event{rx1}{\DR{\aLoc}{1}}{right=of wx1}
  \event{wx2}{\DW{\aLoc}{2}}{right=of rx1}
  \rf{wx1}{rx1}
  \wk{wx0}{wx1}
  \wk{rx1}{wx2}
\end{tikzpicture}\]
Structures similar to 3-valued pomsets have come up in many guises, for example
rough sets~\cite{Pawlak1982} or ultrametrics over
$\{0,{}^1\!/_2,1\}$. They correspond to axioms A1--A3 of Lamport's
\emph{system executions}~\cite{DBLP:journals/dc/Lamport86}.
They are the notion of pomset given by interpreting
$\bEv\le\aEv$ in a 3-valued logic~\cite{Urquhart1986}. 

We strengthen the definition of reads-from to require not just that
no blocker exists, but that any candidate blocker must either
have $\bEv \ltN \cEv$ or $\cEv \ltN \aEv$. This ensures that any
further concurrency cannot turn a non-blocker into a blocker.
\begin{definition}\label{def:rf}
  In a 3-valued pomset, $\aEv$ \emph{can read $\aLoc$ from} $\bEv$ whenever: 
  \begin{itemize}
  \item $\bEv < \aEv$,
  \item if $\aEv$ is satisfiable, then $\bEv$ is a tautology,
  \item $\bEv$ writes $\aVal$ to $\aLoc$,
    and $\aEv$ reads $\aVal$ from $\aLoc$, and
  \item if $\cEv$ writes to $\aLoc$
    then either $\bEv \ltN \cEv$ or $\cEv \ltN \aEv$.
  \end{itemize}
\end{definition}

\begin{definition}
  A 3-valued pomset is $\aLoc$-closed if,
  for every $\aEv\in\Event$:
  \begin{itemize}
  \item $\aEv$ is independent of $\aLoc$, and
  \item if $\aEv$ reads from $\aLoc$, then there is a $\bEv$ such that $\aEv$ can read $\aLoc$ from $\bEv$.
  \end{itemize}
\end{definition}

The definitions as they stand allow cycles in weak edges. This is necessary for examples such
as $(\aLoc\GETS\bLoc-1\SEMI \aLoc\GETS1 \PAR \bLoc\GETS\aLoc-1\SEMI\bLoc\GETS1)$
which has execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx0}{\DW{\aLoc}{0}}{right=of ry1}
  \event{wx1}{\DW{\aLoc}{1}}{right=of wx0}
  \event{rx1}{\DR{\aLoc}{1}}{right=2.5em of wx1}
  \event{wy0}{\DW{\bLoc}{0}}{right=of rx1}
  \event{wy1}{\DW{\bLoc}{1}}{right=of wy0}
  \wk{wx0}{wx1}
  \wk{wy0}{wy1}
  \po{ry1}{wx0}
  \po{rx1}{wy0}
  \rf{wx1}{rx1}
  \rf[in=20,out=160]{wy1}{ry1}
\end{tikzpicture}\]
However, in order to model release/acquire fencing, we need to ban
executions such as:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{\aLoc}{0}}{}
  \event{wx1}{\DW{\aLoc}{1}}{below=7ex of wx0}
  \event{wy1}{\DWRel{\bLoc}{1}}{below right=of wx0}
  \event{ry1}{\DRAcq{\bLoc}{1}}{right=2.5em of wy1}
  \event{rx0}{\DR{\aLoc}{0}}{above right=of ry1}
  \event{rx1}{\DR{\aLoc}{1}}{below=7ex of rx0}
  \wk[out=-75,in=75]{wx0}{wx1}
  \wk[out=105,in=-105]{wx1}{wx0}
  \po{wx0}{wy1}
  \po{wx1}{wy1}
  \po{ry1}{rx0}
  \po{ry1}{rx1}
  \rf{wy1}{ry1}
  \rf{wx0}{rx0}
  \rf{wx1}{rx1}
\end{tikzpicture}\]
The problem here is the weak cycle between $(\DW\aLoc0)$ and $(\DW\aLoc1)$,
which according to Definition~\ref{def:rf}, allows both $(\DR\aLoc0)$ and
$(\DR\aLoc1)$, even though one of them must be a stale value. This can be addressed by
requiring $\ltN$ to form a \emph{per-location} partial order. This is a form
of partial coherence, and can be strengthened to total coherence by requiring
$\ltN$ to be a per-location total order.

\begin{definition}
  A 3-valued pomset is \emph{partially} (resp.~\emph{totally}) $\aLoc$-\emph{coherent}
  if, when restricted to events which write to $\aLoc$,
  $\ltN$ forms a partial (resp.~total) order.
\end{definition}

\subsection{Sets of 3-valued pomsets}
\label{sec:sets-of-pomsets}

Our model of programs is going to be sets of 3-valued pomsets. In this section
we define the operations on pomsets which are used in giving the semantics.
These are operations such as prefixing, parallel composition, restriction, and
so on; they are familiar from models of concurrency such as~\cite{Brookes:1984:TCS:828.833}, but
adapted here to the setting of speculative evaluation.

\begin{definition}
Let $\aPS_0 \in (\aPSS_1 \parallel \aPSS_2)$
whenever there are $\aPS_1 \in \aPSS_1$ and $\aPS_2 \in \aPSS_2$ such that:
\begin{itemize}
\item $\Event_0 = \Event_1 \cup \Event_2$,
\item if $\aEv \le_1 \bEv$ or $\aEv \le_2 \bEv$ then $\aEv \le_0 \bEv$,
\item if $\aEv \ltN_1 \bEv$ or $\aEv \ltN_2 \bEv$ then $\aEv \ltN_0 \bEv$,
\item if $\labelling_0(\aEv) = (\aForm_0 \mid \aAct)$ then either:
  \begin{itemize}
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$
    and $\aForm_0$ implies $\aForm_1 \lor \aForm_2$,
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\aEv \not\in \Event_2$
    and $\aForm_0$ implies $\aForm_1$, or
  \item $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$ and $\aEv \not\in \Event_1$
    and $\aForm_0$ implies $\aForm_2$.
  \end{itemize}
\end{itemize}
\end{definition}
We use $\aPSS_1 \parallel \aPSS_2$ in defining the semantics of conditionals
and concurrency.
It contains the union of pomsets from $\aPSS_1$ and $\aPSS_2$,
allowing overlap as long as they agree on actions. For example, if
$\aPSS_1$ and $\aPSS_2$ contain:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \mid \bAct}{right=of a}
  \po{a}{b}
\end{tikzpicture}\qquad\qquad\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm_2 \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \wk{b}{c}
\end{tikzpicture}\]
then $\aPSS_1 \parallel \aPSS_2$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm_1 \lor \bForm_2 \mid \bAct}{right=of a}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{a}{b}
  \wk{b}{c}
\end{tikzpicture}\]

\begin{definition}
  \label{def:prefix}
Let $\aAct \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{\cEv\}$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item if $\bEv \ltN \aEv$ then $\bEv \ltN' \aEv$,
\item $\labelling'(\cEv) = (\aForm, \aAct)$, and
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then:
  \begin{itemize}
  \item $\labelling'(\aEv) = (\bForm' \mid \bAct)$,
  \item $\bForm'$ implies \(\left\{\begin{array}{l@{~}ll}
    \bForm[\aVal/\aLoc]                     & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$ and $\cEv<'\aEv$} & \textsc{[dependent read]} \\
    \bForm[\aVal/\aLoc] \text{ and } \bForm & \mbox{if $\aAct$ reads $\aVal$ from $\aLoc$}                  & \textsc{[independent read]} \\
    \bForm                                  & \mbox{otherwise}                                              & \textsc{[non-read]} \\
  \end{array}\right.\)
  \item if $\aAct$ and $\bAct$ both write to $\bLoc$,
    then $\cEv \gtN' \aEv$.
  \end{itemize}
\end{itemize}
\end{definition}
Prefixing is used to define the semantics of reads and writes, and
adds a new event $\cEv$ with action $\aAct$. The tricky parts of the
definition are the named cases, which place requirements on read
dependencies.  If $\aAct$ reads $\aVal$ from $\aLoc$, we have to
decide whether $\aEv$ depends on $\cEv$ for some $\aEv$ with old
precondition $\bForm$ and new precondition $\bForm'$. The first case
\textsc{[dependent read]} is that the dependency exists, in which case
$\bForm'$ just has to imply $\bForm[\aVal/\aLoc]$. The more interesting 
case is \textsc{[independent read]}, in which case $\bForm'$ has to imply
$\bForm[\aVal/\aLoc]$ and $\bForm$. This corresponds to a case where
$\aEv$ can be performed with or without $\cEv$.
In particular, if $\bForm$ is independent of $\aLoc$ then we can pick
$\bForm'$ to be $\bForm$, and the independent read case will apply.
For example,
if $\aAct$ and $\bAct$ write to the same location, $\aAct$ reads $\aVal$ from $\aLoc$, $\bForm$ is independent of $\aLoc$,
and
$\aPSS$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{b}{\bForm \mid \bAct}{}
  \event{c}{\cForm \mid \cAct}{right=of b}
  \po{b}{c}
\end{tikzpicture}\]
then $\aAct\prefix\aPSS$ contains:
\[\begin{tikzpicture}[node distance=1em]
  \event{a}{\aForm \mid \aAct}{}
  \event{b}{\bForm \mid \bAct}{right=of a}
  \event{c}{\cForm[\vec\aVal/\vec\aLoc] \mid \cAct}{right=of b}
  \po[out=25,in=155]{a}{c}
  \wk{a}{b}
  \po{b}{c}
\end{tikzpicture}\]

\begin{definition}
Let $\aPSS[\aExp/\aLoc]$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$, and
\item if $\bEv \ltN \aEv$ then $\bEv \ltN' \aEv$, and
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) = (\bForm[\aExp/\aLoc] \mid \aAct)$.
\end{itemize}
and similarly for $\aPSS[\aLoc/\aReg]$.
\end{definition}

\begin{definition}
Let $(\aForm \mid \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever:
\begin{itemize}
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\aForm$ implies $\bForm$.
\end{itemize}
\end{definition}

\begin{definition}
Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aPS$ is $\aLoc$-closed and partially $\aLoc$-coherent.
\end{definition}

We can use the operations defined above to give the
semantics of a simple concurrent imperative programming language.

\begin{definition}
  \label{def:programs}
\begin{eqnarray*}
  \sem{\SKIP} & = & \{ \emptyset \} \\
  \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = & \textstyle\bigcup_\aVal\; (\aExp=\aVal \mid (\DW\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc]) \\
  \sem{\aReg\GETS\aLoc\SEMI \aCmd} & = & \sem{\aCmd}[\aLoc/\aReg] \cup \textstyle\bigcup_\aVal\; (\DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  \sem{\IF (\aExp) \THEN \aCmd \ELSE \bCmd \FI} & = & (\aExp \neq 0 \mid \sem{\aCmd}) \parallel (\aExp=0 \mid \sem{\bCmd}) \\
  \sem{\aCmd \PAR \bCmd} & = & \sem{\aCmd} \parallel \sem{\bCmd} \\
  \sem{\VAR\aLoc\SEMI \aCmd} & = & \nu \aLoc \st \sem{\aCmd}
\end{eqnarray*}
\end{definition}

A write generates a write event that may be visible
to other threads.  A read may see a
thread-local value, or it may generate a read event that must be justified by
another thread.  In the latter case, occurrences of $\aReg$ are replaced with
$\aLoc$ (rather than $\aVal$) to ensure that dependencies are tracked
properly.  The subsequent substitution of $\aVal$ for $\aLoc$ occurs in
definition~\ref{def:prefix} of prefixing.

We have completed the formal definition of our model of speculative
evaluation, and now turn to examples of this model in use.
