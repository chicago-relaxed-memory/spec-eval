\section{Model}

The model used in this paper is one of sets of pomsets with event labels of the form
$(\aForm \mid \aAct)$, where $\aForm$ is the event's precondition
(such as $\aExp=\aVal$) and $\aAct$ is the event's action (such as $\DW\aLoc\aVal$).
For example the semantics of the program $(\aLoc\GETS\aExp)$ includes the case
where $\aExp$ is $\aVal$, which is written to $\aLoc$, and is captured
by the one-event pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wxv}{\aExp=\aVal \mid \DW{\aLoc}{\aVal}}{}
\end{tikzpicture}\]
For this reason, the model is parameterized by a logic, used to express the
preconditions of actions. We make few requirements of this logic, save that it
has includes equalities between expressions, is closed under substitution,
and supports a notion of implication (and in particular a notion of when
a formula is a tautology).

The semantics is defined compositionally. For example, the program $(\aLoc\GETS\bLoc+1)$
is shorthand for $(\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1)$, which contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
This pomset is build compositonally. First, $\sem{\aLoc\GETS\aReg+1}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\aReg=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
Next, we perform the substitution of $\aReg$ with $1$ in every precondition,
to get that $\sem{\aLoc\GETS\aReg+1}[1/\aReg]$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{1=1 \mid \DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
and since $1=1$ is a tautology, we elide it:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
\end{tikzpicture}\]
This substitution is performed in defining
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1}$, which contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx2}{\DW{\aLoc}{2}}{right=of ry1}
  \po{ry1}{wx2}
\end{tikzpicture}\]
as required. There is an ordering $(\DR{\bLoc}{1}) < (\DR{\aLoc}{2})$
because the precondition $(\aReg=1)$ depends on $\aReg$. If the preconditon
was independent of $\aReg$ then there would be no ordering, for example
$\sem{\aReg\GETS\bLoc\SEMI \aLoc\GETS\aReg+1-\aReg}$, contains
the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{ry1}{\DR{\bLoc}{1}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of ry1}
\end{tikzpicture}\]
since the precondition $(\aReg+1-\aReg=1)$ is independent of $\aReg$.

The main novelty of our semantics, since it is designed to model
speculative evaluation, is in modelling conditionals. In most
sets-of-pomsets semantics, a pomset in
$\sem{\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI}$ would either be
given by a pomset in $\sem{\aCmd}$ or a pomset in $\sem{\bCmd}$.
To model speculative evaluation, we need to allow a pomset
in $\sem{\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI}$ to be given by
both a pomset in $\sem{\aCmd}$ \emph{and} a pomset in $\sem{\bCmd}$.
For example, $\sem{\IF(\aExp)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS2 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
\end{tikzpicture}\]
that is we have recorded behaviour from both branches of execution.
Moreover, an action which is performed on both sides of the
conditional can be merged, producing only one event in the resulting pomset.
The precondition of the merged event is the disjunction of the preconditions
of the original events.
For example
$\sem{\IF(\aExp)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{(\aExp\neq0) \lor (\aExp=0) \mid \DW{\bLoc}{3}}{right=of wx2}
\end{tikzpicture}\]
and since $(\aExp\neq0) \lor (\aExp=0)$ is a tautology, this is:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\aExp\neq0 \mid \DW{\aLoc}{1}}{}
  \event{wx2}{\aExp=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
\end{tikzpicture}\]
Combining this model of conditionals with the model of memory using substitutions
gives that
$\sem{\IF(\cLoc)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{\cLoc}{1}}{}
  \event{wx1}{1\neq0 \mid \DW{\aLoc}{1}}{right=of rz1}
  \event{wx2}{1=0    \mid \DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz1}{wx1}
  \po[out=25,in=155]{rz1}{wx2}
\end{tikzpicture}\]
and since $(1\neq0)$ is a tautology and $(1=0)$ is unsatisfiable, this is:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz1}{\DR{\cLoc}{1}}{}
  \event{wx1}{\DW{\aLoc}{1}}{right=of rz1}
  \nonevent{wx2}{\DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz1}{wx1}
  \po[out=25,in=155]{rz1}{wx2}
\end{tikzpicture}\]
Similarly,
$\sem{\IF(\cLoc)\THEN \aLoc\GETS1\SEMI \bLoc\GETS3 \ELSE \aLoc\GETS2\SEMI \bLoc\GETS3 \FI}$
contains the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rz0}{\DR{\cLoc}{0}}{}
  \nonevent{wx1}{\DW{\aLoc}{1}}{right=of rz0}
  \event{wx2}{\DW{\aLoc}{2}}{right=of wx1}
  \event{wy3}{\DW{\bLoc}{3}}{right=of wx2}
  \po{rz0}{wx1}
  \po[out=25,in=155]{rz0}{wx2}
\end{tikzpicture}\]
Note that this semantics captures control dependencies
such as $(\DR\cLoc0)<(\DW\aLoc1)$, independencies
such as $(\DR\cLoc0)\not<(\DW\bLoc3)$, and failed
speculations such as the crossed out $(\DW\aLoc1)$.

In summary, the features we need of the underlying data model is:
\begin{itemize}
\item \emph{actions}, which may read or write to memory locations, and
\item \emph{preconditions}, which form a logic closed under substitution.
\end{itemize}
from which we can define the operations used in defining the semantics of programs,
which include:
\begin{itemize}
\item \emph{prefixing} $(\aForm\mid\aAct)\prefix\aPSS$, which adds an event
  with precondition $\aForm$ and action $\aAct$ to pomsets in $\aPSS$,
\item \emph{substitution} $\aPSS[\aExp/\aLoc]$, which performs a substitution
  on evrey precondition in $\aPSS$, and
\item \emph{join} $\aPSS_1\sqcup\aPSS_2$, which unions pomsets from
  $\aPSS_1$ and $\aPSS_2$, allowing events to be merged.
\end{itemize}
We make data models precise in \S\ref{sec:preliminaries},
define pomsets in \S\ref{sec:pomsets},
and operations on sets of pomsets in \S\ref{sec:sets-of-pomsets},
which are used to give a compositional semantics for
a simple imperative concurrent language in \S\ref{sec:semantics}.

\subsection{Data models}
\label{sec:preliminaries}

A \emph{data model} consists of:
\begin{itemize}
\item a set of \emph{memory locations} $\Loc$, ranged over by
  $\aLoc$ and $\bLoc$,
\item a set of \emph{registers} $\Reg$, ranged over by
  $\aReg$ and $\bReg$,
\item a set of \emph{values} $\Val$, ranged over by
  $\aVal$ and $\bVal$,
\item a set of \emph{expressions} $\Exp$, ranged over by
  $\aExp$ and $\bExp$,
\item a set of \emph{logical formulae} $\Formulae$, ranged over by
  $\aForm$ and $\bForm$, and
\item a set of \emph{actions} $\Act$, ranged over by $\aAct$ and $\bAct$,
\end{itemize}
such that:
\begin{itemize}
\item values include at least the constants $0$ and $1$,
\item expressions include at least registers and values,
\item expressions are closed under substitution for registers, written $\aExp[\bExp/\aReg]$,
\item formulae are closed under substitution for registers or locations, written $\aForm[\bExp/\aReg]$ or $\aForm[\bExp/\aLoc]$,
\item formulae include at least $\TRUE$, $\FALSE$, and equalities of the form $(\aExp=\bExp)$ and $(\aLoc=\bExp)$,
\item formulae are closed under negation, conjunction, disjunction, and
\item there are relations $\rreads$ and $\rwrites \subseteq (\Act \times \Loc \times \Val)$,
\end{itemize}
We shall say $\aAct$ \emph{reads} $\aVal$ \emph{from} $\aLoc$ whenever
$(\aAct,\aLoc,\aVal) \in \rreads$, and
$\aAct$ \emph{writes} $\aVal$ \emph{to} $\aLoc$ whenever
$(\aAct,\aLoc,\aVal) \in \rwrites$.
In examples, the actions are of the form $(\DR{\aLoc}{\aVal})$, which reads $\aVal$ from $\aLoc$,
and $(\DW{\aLoc}{\aVal})$, which writes $\aVal$ to $\aLoc$.
Going forward, we assume a given data model, though some of our examples in
\S\ref{sec:examples} make use of particular data models.

\subsection{Pomsets}
\label{sec:pomsets}

\begin{definition}
  A \emph{pomset} $(\Event, {\le}, \labelling)$ with alphabet $\Alphabet$
  is a partial order $(\Event, {\le})$ together with a function
  $\labelling: \Event \fun \Alphabet$.
\end{definition}
Going forward, we fix the alphabet $\Alphabet=(\Formulae\times\Act)$.
We will write $(\aForm \mid \aAct)$ for the pair $(\aForm,\aAct)$,
$\aAct$ for $(\TRUE,\aAct)$ and $\NEVER\aAct$ for $(\FALSE,\aAct)$.

We visualize a pomset as a graph where the nodes are drawn from
$\Event$, each node $\aEv$ is labelled with $\labelling(\aEv)$,
and an edge $\bEv \rightarrow \aEv$ corresponds to an ordering
$\bEv\le\aEv$. For example:

\[\begin{tikzpicture}[node distance=1em]
  \event{x1}{\DR{\aLoc}{1}}{}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
is a visualization of the pomset where:
\[
  0 \le 1 \quad
  0 \le 2 \quad
  \labelling(0) = (\TRUE, \DR{\aLoc}{1}) \quad
  \labelling(1) = (\FALSE, \DW{\bLoc}{0}) \quad
  \labelling(2) = (\TRUE, \DW{\bLoc}{1}) \quad
\]
As we shall see, this is a possible execution of the
program:
\begin{verbatim}
    r := x; if (r) { y := 1; } else { y := 0; }
\end{verbatim}

\begin{definition}
  An \emph{rf-pomset} is a pomset together with a
  $\RF \subseteq (\Event\times\Loc\times\Event)$ such that for any $(\bEv,\aLoc,\aEv) \in \RF$:
  \begin{itemize}
  \item $\bEv < \aEv$,
  \item $\labelling(\bEv)$ writes $\aVal$ to $\aLoc$,
    and $\labelling(\aEv)$ reads $\aVal$ from $\aLoc$, and
  \item there is no $\bEv < \cEv < \aEv$ such that
    $\labelling(\cEv)$ writes $\bVal$ to $\aLoc$.
  \end{itemize}
\end{definition}
We visualize rf-pomsets by drawing a dashed edge between nodes in $\RF$,
labelled with the memory location,
for example:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{x1}{\DR{\aLoc}{1}}{right=5em of wx1}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \rfx{wx1}{x}{x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
In most cases, the memory location is obvious from context,
so we elide it:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{\aLoc}{1}}{}
  \event{x1}{\DR{\aLoc}{1}}{right=5em of wx1}
  \nonevent{y0}{\DW{\bLoc}{0}}{below left=of x1}
  \event{y1}{\DW{\bLoc}{1}}{below right=of x1}
  \rf{wx1}{x1}
  \po{x1}{y0}
  \po{x1}{y1}
\end{tikzpicture}\]
As we shall see, this is a possible execution of the
program:
\begin{verbatim}
    x := 1;  ||  r := x; if (r) { y := 1; } else { y := 0; }
\end{verbatim}
\begin{definition}
  An rf-pomset is $\aLoc$-closed if
  for $\aEv\in\Event$ with $\labelling(\aEv)=(\aForm \mid \aAct)$:
  \begin{itemize}
  \item $\aForm$ is independent of $\aLoc$, and
  \item if $\aAct$ reads $\aVal$ from $\aLoc$, then there is a $\bEv$ with $(\bEv,\aLoc,\aEv) \in \RF$.
  \end{itemize}
\end{definition}

\subsection{Sets of pomsets}
\label{sec:sets-of-pomsets}

Let $\aPSS_1 \sqcup \aPSS_2$ be the set $\aPSS_0$ where $\aPS_0 \in \aPSS_0$
whenever there are $\aPS_1 \in \aPSS_1$ and  $\aPS_2 \in \aPSS_2$ such that:
\begin{itemize}
\item $\Event_0 = \Event_1 \cup \Event_2$,
\item $\RF_0 = \RF_1 \cup \RF_2$,
\item if $\aEv \le_1 \bEv$ or $\aEv \le_2 \bEv$ then $\aEv \le_0 \bEv$,
\item if $\labelling_0(\aEv) = (\aForm_0 \mid \aAct)$ then either:
  \begin{itemize}
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$
    and $\aForm_0$ implies $\aForm_1 \lor \aForm_2$,
  \item $\labelling_1(\aEv) = (\aForm_1 \mid \aAct)$ and $\aEv \not\in \Event_2$
    and $\aForm_0$ implies $\aForm_1$, or
  \item $\labelling_2(\aEv) = (\aForm_2 \mid \aAct)$ and $\aEv \not\in \Event_1$
    and $\aForm_0$ implies $\aForm_2$.
  \end{itemize}
\end{itemize}
Let $\aPSS_1 \parallel \aPSS_2$ be defined the same as $\aPSS_1 \sqcup \aPSS_2$ except that:
\begin{itemize}
\item $\RF_0 \supseteq \RF_1 \cup \RF_2$, and
 for any $\bEv, \aEv \in \Event_i$, if $(\bEv,\aEv)\in\RF_0$ then $(\bEv,\aEv)\in\RF_i$.
\end{itemize}
Let $(\phi \mid \aAct) \prefix \aPSS$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event \cup \{0\}$,
\item $\RF' = \RF$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$,
\item $\labelling'(0) = (\bForm, \aAct)$, where $\bForm$ implies $\aForm$, and
\item if $\labelling(\aEv) = (\bForm \mid \bAct)$ then:
  \begin{itemize}
  \item $\labelling'(\aEv) = (\bForm' \mid \bAct)$,
  \item $\bForm'$ implies $\bForm[\vec\aVal/\vec\aLoc]$, where $\aAct$ reads $\vec\aVal$ from $\vec\aLoc$, and
  \item $0 \le' \aEv$ or $\bForm'$ implies $\bForm$.
  \end{itemize}
\end{itemize}
Let $\aPSS[\aExp/\aLV]$ be the set $\aPSS'$ where $\aPS'\in\aPSS'$ whenever
there is $\aPS\in\aPSS$ such that:
\begin{itemize}
\item $\Event' = \Event$,
\item $\RF' = \RF$,
\item if $\bEv \le \aEv$ then $\bEv \le' \aEv$, and
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\labelling'(\aEv) = (\bForm[\aExp/\aLV] \mid \aAct)$.
\end{itemize}
Let $(\aForm \mid \aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever:
\begin{itemize}
\item if $\labelling(\aEv) = (\bForm \mid \aAct)$ then $\aForm$ implies $\bForm$.
\end{itemize}
Let $(\nu\aLoc\st\aPSS)$ be the subset of $\aPSS$ such that $\aPS\in\aPSS$ whenever
$\aPS$ is $\aLoc$-closed.

\subsection{Semantics of programs}
\label{sec:semantics}

Define:
\begin{eqnarray*}
  \sem{\SKIP} & = & \{ \emptyset \} \\
  \sem{\aLoc\GETS\aExp\SEMI \aCmd} & = & \bigcup_\aVal\; (\aExp=\aVal \mid \DW\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc] \\
  \sem{\aReg\GETS\aLoc\SEMI \aCmd} & = & \sem{\aCmd}[\aLoc/\aReg] \cup \bigcup_\aVal\; (\TRUE \mid \DR\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
  \sem{\IF \aExp \THEN \aCmd \ELSE \bCmd} & = & (\aExp \neq 0 \mid \sem{\aCmd}) \sqcup (\aExp=0 \mid \sem{\bCmd}) \\
  \sem{\aCmd \PAR \bCmd} & = & \sem{\aCmd} \parallel \sem{\bCmd} \\
  \sem{\VAR\aLoc\SEMI \aCmd} & = & \nu \aLoc \st \sem{\aCmd}
\end{eqnarray*}
