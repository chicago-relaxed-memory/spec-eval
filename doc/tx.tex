\subsection{Fences and release/acquire synchronization}

We assume there are sets $\Rel$ and $\Acq \subseteq\Act$.  We say that
$\aAct$ is a \emph{release action} if $\aAct\in\Rel$ and $\aAct$ is an
\emph{acquire action} if $\aAct\in\Rel$.  

We model release/acquire synchronization by introducing the actions:
\begin{itemize}
%\item $(\DF)$ is both a release and an acquire action
\item $(\DWRel{\aLoc}{\aVal})$, a release action that writes $\aVal$ to $\aLoc$, and
\item $(\DRAcq{\aLoc}{\aVal})$, an acquire action that reads $\aVal$ from $\aLoc$,
\end{itemize}
with semantics:
\begin{eqnarray*}
  %\sem{\FENCE\SEMI \bCmd} & = & (\TRUE \mid \DF) \prefix \sem{\bCmd} \\
  \sem{\REL\aLoc\GETS\aExp\SEMI \bCmd}
  & = & \textstyle\bigcup_\aVal\; (\aExp=\aVal \mid \DWRel\aLoc\aVal) \prefix \sem{\bCmd}[\aExp/\aLoc]
  \\
  \sem{\aReg\GETS\ACQ\aLoc\SEMI \bCmd}
  & = & \textstyle\bigcup_\aVal\; (\TRUE \mid \DRAcq\aLoc\aVal) \prefix \sem{\bCmd}[\aLoc/\aReg] 
\end{eqnarray*}
%There are no additional requirements for $\aLoc$-closure is.

Publication example:
\begin{alltt}
    var x; var f; x:=0; f:=0; (x:=1; \REL{f}:=1;  ||  r:=\ACQ{f}; s:=x;)
\end{alltt}
We disallow the execution where \texttt{r==1} and \texttt{s!=1}
Note that $\RF$ is only augmented in the parallel rule, so neither thread can have an $\RF$ from an init action.

\subsection{Transactions}

We model transactions by introducing the actions:
\begin{itemize}
\item $(\DB)$, an acquire action, and
\item $(\DC{\vec\aLoc}{\vec\aVal})$, a release action that writes $\vec\aVal$ to $\vec\aLoc$,
\end{itemize}
with semantics:
\begin{eqnarray*}
  \sem{\BEGIN\SEMI \bCmd}
  & = & %\mathit{atomic}(
  (\TRUE \mid \DB) \prefix \sem{\bCmd}
  \\
  \sem{\IF\COMMIT\vec\aLoc\THEN \bCmd_1 \ELSE \bCmd_2}
  & = & \textstyle\bigcup_{\vec\aVal,\,\aForm\,\text{implies}\,\vec\aLoc=\vec\aVal}\;
        ((\aForm \mid \DC{\vec\aLoc}{\vec\aVal}) \prefix (\aForm \mid \sem{\bCmd_1}))
        \sqcup  (\lnot\aForm \mid \sem{\bCmd_2})
\end{eqnarray*}
where we require that all pomsets in the semantics of programs be
\emph{atomic}.

Before defining atomicity, we provide some auxiliary notation.

We say that $\aEv$ is a \emph{begin event} if
$\labelling(\aEv)=(\aForm\mid\DB)$ and a \emph{commit event} if
$\labelling(\aEv)=(\aForm\mid\DC{\vec\aLoc}{\vec\aVal})$.

We write $\aForm_\aEv$ for the formula and $\aAct_\aEv$ for the
action of $\aEv$; that is, when $\labelling(\aEv)=(\aForm_\aEv\mid\aAct_\aEv)$.

We say that $\aEv$ is \emph{compatible with} $\bEv$ when
$\aForm_\aEv\land\aForm_\bEv$ is satisfiable.

We say that  event $\aEv$ \emph{belongs to} $(\begEv,\vec\comEv)$ when
\begin{itemize}
\item $\begEv$ is a begin event, $\begEv<\aEv$, and
  there is no commit event $\bEv$ such that $\begEv<\bEv<\aEv$,
\item $\vec\comEv$ are the commit events $\comEv_i$ such that $\aEv<\comEv_i$ and
  there is no begin event $\bEv$ such that $\aEv<\bEv<\comEv_i$.
\end{itemize}

\begin{definition}
  A pomset is \emph{atomic} when for any $\aEv$ that belongs to $(\begEv,\vec\comEv)$:
  \begin{enumerate}
  \item\label{xcommitform} $\aForm_{\aEv}$ implies $\textstyle\bigvee_i\aForm_{\comEv_i}$,
  \item\label{xliftb} if $\bEv<\aEv$ then $\bEv<\begEv$, 
  \item\label{xliftc} if $\aEv<\bEv$ and $\bEv$ is compatible with
    $\comEv_i$ then $\comEv_i<\bEv$, 
  \item\label{xtotal} if $\aEv'\neq\aEv$ belongs to $(\begEv',\vec\comEv')$ but not
    $(\begEv,\dontcare)$ and
    \begin{itemize}
    \item $\comEv'_j$ is compatible with $\aEv$, and 
    \item $\comEv_i$ is compatible with $\aEv'$ 
    \end{itemize}
    then either
    $\comEv'_j<\begEv$ or
    $\comEv_i<\begEv'$,
  % \item\label{xrf} if $\aEv'\neq\aEv$ belongs to $(\begEv,\dontcare)$ but not
  %   $(\begEv,\dontcare)$ and
  %   \begin{itemize}
  %   \item $\aEv$ reads from $\bEv'$ that belongs to $(\begEv',\vec\comEv')$,
  %   \item $\aEv'$ reads from $\bEv''\neq\beV'$ that belongs to $(\begEv'',\vec\comEv'')$,
  %   \item $\comEv''_j$ is compatible with $\bEv'$, and 
  %   \item $\comEv'_i$ is compatible with $\bEv''$ 
  %   \end{itemize}
  %   then either
  %   $\comEv''_j<\begEv'$ or
  %   $\comEv'_i<\begEv''$ .
  \item\label{xcommitvars} if $\aEv$ writes $\aLoc$ and $\comEv_i$ writes
    $\vec\aLoc$ then $\aLoc=\aLoc_i$, for some $i$, and
  \item\label{xreadunique} if $\aEv$ reads $\aLoc$ and $\aEv'\neq\aEv$ reads
    $\aLoc$, belongs to $(\begEv,\dontcare)$ and is compatible with $\aEv$
    then $\aAct_{\aEv}=\aAct_{\aEv'}$.
  \end{enumerate}
\end{definition}
Clause \eqref{xcommitform} requires that the precondition on $\aEv$ is false on an
aborted transaction.
The \emph{lifting clauses}, \eqref{xliftb} and \eqref{xliftc}, require order
come in or out of $\aEv$ is lifted to the corresponding begin or commit event.
% Clause \eqref{xrf} requires that whenever a transaction reads from two other
% transactions, the other transactions must be ordered.
Clause \eqref{xtotal} requires that transactions be totally ordered.
Clause \eqref{xcommitvars} requires that all writes be committed.
Clause \eqref{xreadunique} requires that multiple reads of a location in a
single transaction must see the same value.


The definition of atomicity guarantees strong isolation.  For weak isolation,
clauses \eqref{xcommitvars} and \eqref{xreadunique} are unnecessary,
\eqref{xliftb} only applies when $\bEv$ is a commit, and \eqref{xliftc} only
applies when $\bEv$ is a begin.

The definition handles simple examples:
\begin{itemize}
\item Single threaded example: $\DB_1 \DC{}{}_1 \DB_2 \DC{}{}_2$.  Because
  $\DC{}{}_2$ is a release, we know that $\DC{}{}_1<\DC{}{}_2$.  Because
  $\DB_1$ is an acquire, we know that $\DB_1<\DB_2$ By lifting, either of
  these is sufficient to require that $\DC{}{}_1<\DB_2$.
\[\begin{tikzpicture}[node distance=1em,baselinecenter]
  \event{b1}{\DB_1}{}
  \event{c1}{\DC{}{}_1}{right=of b1}
  \event{b2}{\DB_2}{below right=of b1}
  \event{c2}{\DC{}{}_2}{right=of b2}
  \po{b1}{c1}
  \po{b1}{b2}
  \po{b2}{c2}
  \po{c1}{c2}
\end{tikzpicture}
\;\text{implies}\;
\begin{tikzpicture}[node distance=1em,baselinecenter]
  \event{b1}{\DB_1}{}
  \event{c1}{\DC{}{}_1}{right=of b1}
  \event{b2}{\DB_2}{below right=of b1}
  \event{c2}{\DC{}{}_2}{right=of b2}
  \po{b1}{c1}
  \po{c1}{b2}
  \po{b2}{c2}
\end{tikzpicture}\]
\item Abort example:
\[\begin{tikzpicture}[node distance=1em,baselinecenter]
  \event{b1}{\DB}{}
  \event{wx1}{\DW{x}{1}}{right=of b1}
  \event{c1}{\DC{}{}_1}{above right=of wx1}
  \nonevent{c2}{\DC{}{}_2}{below right=of wx1}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
  \po{b1}{wx1}
  \po{wx1}{c1}
  \po{wx1}{c2}
  \rf{wx1}{rx1}
\end{tikzpicture}
\;\text{implies}\;
\begin{tikzpicture}[node distance=1em,baselinecenter]
  \event{b1}{\DB}{}
  \event{wx1}{\DW{x}{1}}{right=of b1}
  \event{c1}{\DC{}{}_1}{above right=of wx1}
  \nonevent{c2}{\DC{}{}_2}{below right=of wx1}
  \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
  \po{b1}{wx1}
  \po{wx1}{c1}
  \po{wx1}{c2}
  \rf{wx1}{rx1}
  \po{c1}{rx1}
\end{tikzpicture}\]
  
\item Clause \eqref{xrf} stops transaction from reading two different values
  for the same variable from transactions (it is possible with no
  transactional writes).  
\item Clause \eqref{xrf} also stops transactional IRIW.
\end{itemize}
% \begin{definition}
%   An rf-pomset is transaction-closed if the $\DB$ and $\DC{}{}$ actions with
%   satisfiable preconditions are totally ordered by $<$.
% \end{definition}

Let ``$\END\SEMI \bCmd$'' be syntax sugar for
``$\IF\COMMIT\vec\aLoc\THEN\bCmd \ELSE \bCmd$'', where $\vec\aLoc$ are the
free variables of $\bCmd$.

The semantics of
\begin{alltt}
  x:=1; begin; x:=2; end; y:=x;
\end{alltt}
includes
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{b}{\DB}{right=of wx1}
  \event{wx2}{\DW{x}{2}}{right=of b}
  \event{c}{\DC{x}{2}}{right=of wx2}
  \event{wy2}{\DW{y}{2}}{right=of c}
  \nonevent{wy1}{\DW{y}{1}}{below=of wy2}
  \po{b}{wx2}
  \po[bend right]{b}{wy1}
  \po[bend left]{b}{wy2}
  \po{wx2}{c}
  \po[bend left]{wx1}{c}
  %\po{rz0}{wy2}
\end{tikzpicture}\]
and
\[\begin{tikzpicture}[node distance=1em]
  \event{wx1}{\DW{x}{1}}{}
  \event{b}{\DB}{right=of wx1}
  \nonevent{wx2}{\DW{x}{2}}{right=of b}
  \nonevent{c}{\DC{x}{2}}{right=of wx2}
  \nonevent{wy2}{\DW{y}{2}}{right=of c}
  \event{wy1}{\DW{y}{1}}{below=of wy2}
  \po{b}{wx2}
  \po[bend right]{b}{wy1}
  \po[bend left]{b}{wy2}
  \po{wx2}{c}
  \po[bend left]{wx1}{c}
  %\po{rz0}{wy2}
\end{tikzpicture}\]

Publication example:
\begin{alltt}
  var x; var f; x:=0; f:=0; 
     x:=1; (begin; f:=1; end;) || (begin; r:=f; end; s:=x;)
\end{alltt}

\subsection{Picky details}

The relations $\rreads$ and $\rwrites$ and $\RF$ should be restricted
to elements of $(\Act \times \Loc \times \Val)$ that are in
$(\Act \times (\Loc \rightarrow \Val))$.

$(\DT{\aLoc})$ neither reads nor writes $\aLoc$.

% Note: we could also include a transaction factory, and close the factory.
% \begin{alltt}
%   TransactionFactory T; var x; var f; x:=0; f:=0; fence; 
%      x:=1; (begin T; f:=1; f:=2; end T;) || (begin T; r:=f; end T; s:=x;)
% \end{alltt}

% Local Variables:
% TeX-master: "x"
% End:
