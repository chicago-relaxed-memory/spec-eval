\subsection{Release/acquire synchronization}
\label{sec:ra}

In relaxed memory models, synchronization actions act as memory fences: that
is, they are a barrier to reordering memory accesses.  In this section, we
present a simple model of release/acquire fencing. In
\S\ref{sec:transactions}, we show that this can be scaled up to a model of
transactional memory.

We assume there are sets $\Rel$ and $\Acq \subseteq\Act$.  We say that
$\aAct$ is a \emph{release action} if $\aAct\in\Rel$ and $\aAct$ is an
\emph{acquire action} if $\aAct\in\Rel$.
In a pomset, a release event is one labelled with a release action,
and an acquire event is one labelled by an acquire action.
The semantics of fences are given by adding an extra constraint
to the definition of $(\aForm\mid\aAct)\prefix\aPSS$
(recalling that $\cEv$ is the $\aAct$-labelled event being introduced):
\begin{itemize}
\item $\cEv \le \aEv$ whenever $\cEv$ is an acquire event or $\aEv$ is a release event.
\end{itemize}
This constraint ensures that events are ordered before a
release and after an acquire.

% In addition, we must change the semantics of write from
% \S\ref{sec:sets-of-pomsets} to ensure that an action is generated for every
% write that might be published by a subsequent release action.
% Formally, $\sem{\aLoc\GETS\aExp\SEMI \aCmd}$ only includes pomsets
% from $\sem{\aCmd}[\aExp/\aLoc]$ that contain a write to
% $\aLoc$ that is not preceded by a release.

In examples, we will use
releasing writes and acquiring reads:
\begin{itemize}
\item $(\DWRel{\aLoc}{\aVal})$, a release action that writes $\aVal$ to $\aLoc$, and
\item $(\DRAcq{\aLoc}{\aVal})$, an acquire action that reads $\aVal$ from $\aLoc$.
\end{itemize}
The semantics of programs with releasing write and acquiring read are the
same as for regular write and read and, but with $\DWRel\aLoc\aVal$ replacing
$\DW\aLoc\aVal$ and $\DRAcq\aLoc\aVal$ replacing $\DR\aLoc\aVal$.  
\begin{eqnarray*}
  \sem{\REL\aLoc\GETS\aExp\SEMI \aCmd} & = & \bigcup_\aVal\; (\aExp=\aVal \mid \DWRel\aLoc\aVal) \prefix \sem{\aCmd}[\aExp/\aLoc] \\
  \sem{\ACQ\aReg\GETS\aLoc\SEMI \aCmd} & = & \sem{\aCmd}[\aLoc/\aReg] \cup \bigcup_\aVal\; (\TRUE \mid \DRAcq\aLoc\aVal) \prefix \sem{\aCmd}[\aLoc/\aReg] \\
\end{eqnarray*}

For example, consider the program:
\begin{verbatim}
  (x := 0; f := 0; x:= 1; rel f := 1;) || (acq r := f; s := x;)
\end{verbatim}
This has an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wf0}{\DW{f}{0}}{right=of wx1}
  \event{wf1}{\DWRel{f}{1}}{right=of wf0}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx1}{\DR{x}{1}}{right=of rf1}
  \po{wx0}{wx1}
  \po{wf0}{wf1}
  \po[out=25,in=155]{wx1}{wf1}
  \po{rf1}{rx1}
  \rf{wf1}{rf1}
  \rf[out=25,in=155]{wx1}{rx1}
\end{tikzpicture}\]
but \emph{not}:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wf0}{\DW{f}{0}}{right=of wx1}
  \event{wf1}{\DWRel{f}{1}}{right=of wf0}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx0}{\DR{x}{0}}{right=of rf1}
  \po{wx0}{wx1}
  \po{wf0}{wf1}
  \po[out=25,in=155]{wx1}{wf1}
  \po{rf1}{rx0}
  \rf{wf1}{rf1}
  \rf[out=20,in=160]{wx0}{rx0}
\end{tikzpicture}\]
since $(\DW x0) < (\DW x1) < (\DR x0)$, so this pomset does not satisfy the
requirements to be an rf-pomset.
\todo{FIXME: we no longer define the term ``rf-pomset''.}
If we replace the release
with a plain write, then the outcome $(\DRAcq f1)$ and $(\DR x0)$ is possible:
\[\begin{tikzpicture}[node distance=1em]
  \event{wx0}{\DW{x}{0}}{}
  \event{wx1}{\DW{x}{1}}{right=of wx0}
  \event{wf0}{\DW{f}{0}}{right=of wx1}
  \event{wf1}{\DW{f}{1}}{right=of wf0}
  \event{rf1}{\DRAcq{f}{1}}{right=2.5em of wf1}
  \event{rx0}{\DR{x}{0}}{right=of rf1}
  \po{wx0}{wx1}
  \po{wf0}{wf1}
  %\po[bend left]{wx1}{wf1}
  \po{rf1}{rx0}
  \rf{wf1}{rf1}
  \rf[out=20,in=160]{wx0}{rx0}
\end{tikzpicture}\]
since no order is required between $(\DW x1)$ and $(\DW f1)$.  
Symmetrically, if we replace the acquire of the original program
with a plain read, then the outcome $(\DR f1)$ and $(\DR x0)$ is possible.
% \begin{verbatim}
%   x := 0; rel f := 0; ||
%   acq r := f; if (r == 0) { x := x+1; rel f := 1; } ||
%   acq s := f; if (r == 1) { x := x+1; rel f := 2; }
% \end{verbatim}
% This has an execution:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wf0}{\DWRel{f}{0}}{below=of wx0}
%   \event{rf0}{\DRAcq{f}{0}}{right=2.5 em of wx0}
%   \event{rx0}{\DR{x}{0}}{below=of rf0}
%   \event{wx1}{\DW{x}{1}}{below=of rx0}
%   \event{wf1}{\DWRel{f}{1}}{below=of wx1}
%   \event{rf1}{\DRAcq{f}{1}}{right=2.5 em of rf0}
%   \event{rx1}{\DR{x}{1}}{below=of rf1}
%   \event{wx2}{\DW{x}{2}}{below=of rx1}
%   \event{wf2}{\DWRel{f}{2}}{below=of wx2}
%   \po{wx0}{wf0}
%   \po{rf0}{rx0}
%   \po{rx0}{wx1}
%   \po{wx1}{wf1}
%   \po{rf1}{rx1}
%   \po{rx1}{wx2}
%   \po{wx2}{wf2}
%   \rf{wf0}{rf0}
%   \rf{wx0}{rx0}
%   \rf{wf1}{rf1}
%   \rf{wx1}{rx1}
% \end{tikzpicture}\]
% but \emph{not}:
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx0}{\DW{x}{0}}{}
%   \event{wf0}{\DWRel{f}{0}}{below=of wx0}
%   \event{rf0}{\DRAcq{f}{0}}{right=2.5 em of wx0}
%   \event{rx0}{\DR{x}{0}}{below=of rf0}
%   \event{wx1}{\DW{x}{1}}{below=of rx0}
%   \event{wf1}{\DWRel{f}{1}}{below=of wx1}
%   \event{rf1}{\DRAcq{f}{1}}{right=2.5 em of rf0}
%   \event{rx0b}{\DR{x}{0}}{below=of rf1}
%   \event{wx1b}{\DW{x}{1}}{below=of rx0b}
%   \event{wf2}{\DWRel{f}{2}}{below=of wx1b}
%   \po{wx0}{wf0}
%   \po{rf0}{rx0}
%   \po{rx0}{wx1}
%   \po{wx1}{wf1}
%   \po{rf1}{rx0b}
%   \po{rx0b}{wx1b}
%   \po{wx1b}{wf2}
%   \rf{wf0}{rf0}
%   \rf{wx0}{rx0}
%   \rf{wf1}{rf1}
%   \rf{wx0}{rx0b}
% \end{tikzpicture}\]
% since $(\DW x0) < (\DW x1) < (\DR x0)$, so this pomset does not satisfy the
% requirements to be an rf-pomset.

% The notion rf-pomset is sufficient to capture hardware models and
% release/acquire access in C++, where reads-from implies happens-before
% \cite{alglave}.  To model C++ relaxed access, it
% would be necessary to use a more general notion of rf-pomset, where
% $(\bEv,\aLoc,\aEv) \in \RF$ does not necessarily imply $\bEv < \aEv$, instead
% requiring that $(\mathord< \cup \mathord\RF)$ be acyclic.

\subsection{Transactions}
\label{sec:transactions}

We present a simple model of serializable transactions. The action
$(\DB{\aVal})\in\Acq$ represents the begin of a transaction with id $\aVal$
and $(\DC{\aVal})\in \Rel$ represents the corresponding commit, with
semantics:
\begin{eqnarray*}
  \sem{\aReg\GETS\BEGIN\aVal\SEMI \bCmd}
  & = &
  (\TRUE \mid \DB{\aVal}) \prefix \sem{\aCmd}[\aVal/\aReg]
  \\
  \sem{\aReg\GETS\COMMIT\aVal\SEMI \bCmd}
  & = &
  (\TRUE \mid \DC{\aVal}) \prefix \sem{\bCmd}[1/\aReg]
  \cup
  (\FALSE \mid \DC{\aVal}) \prefix \sem{\bCmd}[0/\aReg]
\end{eqnarray*}
At top level, we require that pomsets be \emph{serializable}, as defined below.
\begin{definition}
  We say that event $\comEv$ \emph{matches} $\begEv$ if
  $\labelling(\comEv)=(\DC{\aVal})$ and
  $\labelling(\begEv)=(\DB{\aVal})$. %, for some $\aVal$.
  We say that a begin event \emph{aborts} if every matching commit is
  unsatisfiable.  We say that begin event $\begEv$ \emph{begins} $\aEv$ if
  $\begEv\le\aEv$ and there is no intervening matching commit; in this case
  $\aEv$ \emph{belongs to} $\begEv$.
  % event $\comEv$ such that $\begEv\le\comEv\le\aEv$
  We say that commit event $\comEv$ \emph{commits} $\aEv$ if $\aEv\le\comEv$
  and there is no intervening matching begin.
  % event $\begEv$ such that $\aEv\le\begEv\le\comEv$.
% \end{definition}
% \begin{definition}
  A pomset is \emph{serializable} if:
  \begin{enumerate}
  \item\label{tx:1} no two begins have the same id,
  \item\label{tx:2} every commit follows the matching begin,
  \item\label{tx:3} $\le$ totally orders tautological begins and commits,
  %\item\label{tx:4} if $\begEv$ begins $\aEv$, but not $\bEv$, and $\bEv\le\aEv$ then $\bEv\le\begEv$,
  \item\label{tx:4} if $\begEv$ begins $\aEv$, but not $\bEv$, then
    $\bEv\le\aEv$ implies $\bEv\le\begEv$ and $\aEv\ltN\bEv$ implies $\begEv\ltN\bEv$
  %\item\label{tx:5} if $\comEv$ ends $\aEv$, but not $\bEv$, and $\aEv\le\bEv$ then $\comEv\le\bEv$,
  \item\label{tx:5} if $\comEv$ ends $\aEv$, but not $\bEv$, then
    $\aEv\le\bEv$ implies $\comEv\le\bEv$ and $\bEv\ltN\aEv$ implies $\bEv\ltN\comEv$,
  \item\label{tx:6} if $\aEv$ and $\bEv$ belong to $\begEv$ and read the same
    location, then both read the same value, 
  % \item\label{tx:6} if $\begEv$ begins $\aEv$ then some matching $\comEv$ both implies and ends $\aEv$,    
  % \item\label{tx:6} if $\begEv$ begins $\aEv$ then some matching $\comEv$
  %   ends $\aEv$ such that both $\aEv$ implies $\comEv$ and $\comEv$ implies $\aEv$,    
  \item\label{tx:7} if $\aEv$ belongs to $\begEv$, then $\aEv$ implies some
    matching $\comEv$ that ends $\aEv$, and
  \item\label{tx:8} if $\begEv$ aborts then there must be some $\aEv$ that
    belongs to $\begEv$ and some tautologous $\bEv\le\aEv$ that does not belong to
    $\begEv$ such that $\aEv$ and $\bEv$ touch the same location.
  \end{enumerate}
\end{definition}
In discussion, we identify transactions by their unique begin event.  A
transaction that does not abort is \emph{successful}.
%
Conditions \ref{tx:1}-\ref{tx:5} ensure serializability.  Conditions
\ref{tx:4}-\ref{tx:6} also ensure strong isolation for non-transactional
events \cite{DBLP:journals/pacmpl/DongolJR18}. Condition \ref{tx:7} ensures
that all events in aborted transactions are unsatisfiable.
Condition \ref{tx:8} requires that aborts only occur due to caching
conflicts---this is similar to the treatment of the touch operation in
\S\ref{sec:spectre}.

% The definition handles simple examples:
% \begin{itemize}
% \item Single threaded example: $\DB_1 \DC_1 \DB_2 \DC_2$.  Because
%   $\DC_2$ is a release, we know that $\DC_1<\DC_2$.  Because
%   $\DB_1$ is an acquire, we know that $\DB_1<\DB_2$ By lifting, either of
%   these is sufficient to require that $\DC_1<\DB_2$.
% \[\begin{tikzpicture}[node distance=1em,baselinecenter]
%   \event{b1}{\DB_1}{}
%   \event{c1}{\DC_1}{right=of b1}
%   \event{b2}{\DB_2}{below right=of b1}
%   \event{c2}{\DC_2}{right=of b2}
%   \po{b1}{c1}
%   \po{b1}{b2}
%   \po{b2}{c2}
%   \po{c1}{c2}
% \end{tikzpicture}
% \;\text{implies}\;
% \begin{tikzpicture}[node distance=1em,baselinecenter]
%   \event{b1}{\DB_1}{}
%   \event{c1}{\DC_1}{right=of b1}
%   \event{b2}{\DB_2}{below right=of b1}
%   \event{c2}{\DC_2}{right=of b2}
%   \po{b1}{c1}
%   \po{c1}{b2}
%   \po{b2}{c2}
% \end{tikzpicture}\]
% \item Abort example:
% \[\begin{tikzpicture}[node distance=1em,baselinecenter]
%   \event{b1}{\DB}{}
%   \event{wx1}{\DW{x}{1}}{right=of b1}
%   \event{c1}{\DC_1}{above right=of wx1}
%   \nonevent{c2}{\DC_2}{below right=of wx1}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
%   \po{b1}{wx1}
%   \po{wx1}{c1}
%   \po{wx1}{c2}
%   \rf{wx1}{rx1}
% \end{tikzpicture}
% \;\text{implies}\;
% \begin{tikzpicture}[node distance=1em,baselinecenter]
%   \event{b1}{\DB}{}
%   \event{wx1}{\DW{x}{1}}{right=of b1}
%   \event{c1}{\DC_1}{above right=of wx1}
%   \nonevent{c2}{\DC_2}{below right=of wx1}
%   \event{rx1}{\DR{x}{1}}{right=2.5 em of wx1}
%   \po{b1}{wx1}
%   \po{wx1}{c1}
%   \po{wx1}{c2}
%   \rf{wx1}{rx1}
%   \po{c1}{rx1}
% \end{tikzpicture}\]
  
% % \item Clause \eqref{xrf} stops transaction from reading two different values
% %   for the same variable from transactions (it is possible with no
% %   transactional writes).  
% % \item Clause \eqref{xrf} also stops transactional IRIW.
% \end{itemize}
% % \begin{definition}
% %   An rf-pomset is transaction-closed if the $\DB$ and $\DC$ actions with
% %   satisfiable preconditions are totally ordered by $<$.
% % \end{definition}

% Let ``$\END\SEMI \bCmd$'' be syntax sugar for
% ``$\IF\COMMIT\vec\aLoc\THEN\bCmd \ELSE \bCmd$'', where $\vec\aLoc$ are the
% free variables of $\bCmd$.

% The semantics of
% \begin{alltt}
%   x:=1; begin; x:=2; end; y:=x;
% \end{alltt}
% includes
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx1}{\DW{x}{1}}{}
%   \event{b}{\DB}{right=of wx1}
%   \event{wx2}{\DW{x}{2}}{right=of b}
%   \event{c}{\DC}{right=of wx2}
%   \event{wy2}{\DW{y}{2}}{right=of c}
%   \nonevent{wy1}{\DW{y}{1}}{below=of wy2}
%   \po{b}{wx2}
%   \po[bend right]{b}{wy1}
%   \po[bend left]{b}{wy2}
%   \po{wx2}{c}
%   \po[bend left]{wx1}{c}
%   %\po{rz0}{wy2}
% \end{tikzpicture}\]
% and
% \[\begin{tikzpicture}[node distance=1em]
%   \event{wx1}{\DW{x}{1}}{}
%   \event{b}{\DB}{right=of wx1}
%   \nonevent{wx2}{\DW{x}{2}}{right=of b}
%   \nonevent{c}{\DC}{right=of wx2}
%   \nonevent{wy2}{\DW{y}{2}}{right=of c}
%   \event{wy1}{\DW{y}{1}}{below=of wy2}
%   \po{b}{wx2}
%   \po[bend right]{b}{wy1}
%   \po[bend left]{b}{wy2}
%   \po{wx2}{c}
%   \po[bend left]{wx1}{c}
%   %\po{rz0}{wy2}
% \end{tikzpicture}\]

% Publication example:
% \begin{alltt}
%   var x; var f; x:=0; f:=0; 
%      x:=1; (begin; f:=1; end;) || (begin; r:=f; end; s:=x;)
% \end{alltt}

% Note: we could also include a transaction factory, and close the factory.
% \begin{alltt}
%   TransactionFactory T; var x; var f; x:=0; f:=0; fence; 
%      x:=1; (begin T; f:=1; f:=2; end T;) || (begin T; r:=f; end T; s:=x;)
% \end{alltt}

% Before defining atomicity, we provide some auxiliary notation.
%
% We say that $\aEv$ is a \emph{begin event} if
% $\labelling(\aEv)=(\aForm\mid\DB)$ and a \emph{commit event} if
% $\labelling(\aEv)=(\aForm\mid\DC)$.
%
% We write $\aForm_\aEv$ for the formula and $\aAct_\aEv$ for the
% action of $\aEv$; that is, when $\labelling(\aEv)=(\aForm_\aEv\mid\aAct_\aEv)$.
%
% We say that $\aEv$ is \emph{compatible with} $\bEv$ when
% $\aForm_\aEv\land\aForm_\bEv$ is satisfiable.
%
% \begin{definition}
%   A pomset is \emph{atomic} when for any $\aEv$ that belongs to $(\begEv,\vec\comEv)$:
%   \begin{enumerate}
%   \item\label{xcommitform} $\aForm_{\aEv}$ implies $\textstyle\bigvee_i\aForm_{\comEv_i}$,
%   \item\label{xliftb} if $\bEv<\aEv$ then $\bEv<\begEv$, 
%   \item\label{xliftc} if $\aEv<\bEv$ and $\bEv$ is compatible with
%     $\comEv_i$ then $\comEv_i<\bEv$, 
%   \item\label{xtotal} if $\aEv'\neq\aEv$ belongs to $(\begEv',\vec\comEv')$ but not
%     $(\begEv,\dontcare)$ and
%     \begin{itemize}
%     \item $\comEv'_j$ is compatible with $\aEv$, and 
%     \item $\comEv_i$ is compatible with $\aEv'$ 
%     \end{itemize}
%     then either
%     $\comEv'_j<\begEv$ or
%     $\comEv_i<\begEv'$,
%   % \item\label{xrf} if $\aEv'\neq\aEv$ belongs to $(\begEv,\dontcare)$ but not
%   %   $(\begEv,\dontcare)$ and
%   %   \begin{itemize}
%   %   \item $\aEv$ reads from $\bEv'$ that belongs to $(\begEv',\vec\comEv')$,
%   %   \item $\aEv'$ reads from $\bEv''\neq\beV'$ that belongs to $(\begEv'',\vec\comEv'')$,
%   %   \item $\comEv''_j$ is compatible with $\bEv'$, and 
%   %   \item $\comEv'_i$ is compatible with $\bEv''$ 
%   %   \end{itemize}
%   %   then either
%   %   $\comEv''_j<\begEv'$ or
%   %   $\comEv'_i<\begEv''$ .
%   \item\label{xcommitvars} if $\aEv$ writes $\aLoc$ and $\comEv_i$ writes
%     $\vec\aLoc$ then $\aLoc=\aLoc_i$, for some $i$, and
%   \item\label{xreadunique} if $\aEv$ reads $\aLoc$ and $\aEv'\neq\aEv$ reads
%     $\aLoc$, belongs to $(\begEv,\dontcare)$ and is compatible with $\aEv$
%     then $\aAct_{\aEv}=\aAct_{\aEv'}$.
%   \end{enumerate}
% \end{definition}
% Clause \eqref{xcommitform} requires that the precondition on $\aEv$ is false on an
% aborted transaction.
% The \emph{lifting clauses}, \eqref{xliftb} and \eqref{xliftc}, require order
% come in or out of $\aEv$ is lifted to the corresponding begin or commit event.
% % Clause \eqref{xrf} requires that whenever a transaction reads from two other
% % transactions, the other transactions must be ordered.
% Clause \eqref{xtotal} requires that transactions be totally ordered.
% Clause \eqref{xcommitvars} requires that all writes be committed.
% Clause \eqref{xreadunique} requires that multiple reads of a location in a
% single transaction must see the same value.
%
% The definition of atomicity guarantees strong isolation.  For weak isolation,
% clauses \eqref{xcommitvars} and \eqref{xreadunique} are unnecessary,
% \eqref{xliftb} only applies when $\bEv$ is a commit, and \eqref{xliftc} only
% applies when $\bEv$ is a begin.

% Local Variables:
% TeX-master: "x"
% End:
