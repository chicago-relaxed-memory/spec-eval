\section{Logic}
\label{sec:logic}

\newcommand{\since}[2]{{#1} \  {\tt  S } \  {#2}}
\newcommand{\pLTL}{{\tt PLTL}}
\newcommand{\once}{\Diamond^{-1}}
\newcommand{\pastalways}{\Box^{-1}}
\newcommand{\afo}{\phi}
\newcommand{\bfo}{\psi}
\newcommand{\mods}{\tt Models}



We work with a variant of \pLTL\ \footnote{ Our presentation differs from standard presentations of past LTL\citet{Lichtenstein:1985:GP:648065.747612} in two ways.  First, we eschew the previous instant operator, to account for the current setting of partial orders; second, we consider strictly past  versions of the ``once'' and ``always in the past'' operators, by not evaluating the formula at the current instant.}   interpreted over pomsets.  The atoms of our logic are write and read events, and we use strictly in the past modal operators in addition to the usual boolean connectives.
\[
\begin{array}{lrl}
 \afo &::=&\DR{\aLoc}{\aVal}  \mid \DW\aLoc\aVal \\
      &&  \afo \vee\ \bfo \mid \neg \afo  \\
      && \once\afo \\
      && \pastalways\afo
\end{array} 
\]

\begin{definition} [Satisfaction]
Given an rf-pomset  $\aPS= (\Event, {\le}, \labelling)$ with alphabet $\Alphabet$, and  $\aEv \in \Event$, define:
\[
\begin{array}{lrl}
 \aPS,\aEv & \models& \DR{\aLoc}{\aVal}, \ \mbox{if } \labelling(\aEv) =  (\TRUE, \DR{\aLoc}{\aVal}) \\
\aPS,\aEv &\models& \DW{\aLoc}{\aVal}, \ \mbox{if } \labelling(\aEv) =  (\TRUE, \DW{\aLoc}{\aVal}) \\
\aPS,\aEv &\models&  \afo\wedge\bfo, \ \mbox{if } \aPS,\aEv \models  \afo\ \mbox{ and } \aPS,\aEv \models  \bfo\  \\
\aPS,\aEv &\models&  \neg\afo\ , \ \mbox{if } \aPS,\aEv \not\models \afo \\
 \aPS,\aEv &\models& \once\afo, \mbox{if } (\exists \bEv \le \aEv, \bEv\not=\aEv) \  \aPS,\bEv \models \afo\  \\
 \aPS,\aEv &\models& \pastalways\afo, \mbox{if } (\forall \bEv \le \aEv, \bEv\not=\aEv) \  \aPS,\bEv \models \afo\ 
\end{array} 
\]

Define $\aPS \models \afo$ if $(\forall \aEv \in \Event) \ \aPS,\aEv  \models\ \afo$.

For a set of rf-pomsets $\aPSS$, define $\aPSS\models \afo$ if $(\forall \aPS \in \aPSS) \ \aPS \models\ \afo$.
\end{definition}
While the boolean connectives are interpreted as expected, the strict past operators explore the past of the current event as determined by the pomset ordering.  Their interpretation does not include the current instant.  Thus, while they are connected by a DeMorgan law:
\[ \pastalways\afo = \neg\once(\neg\afo) \]
they do {\emph not} satisfy the rule:
\[ \pastalways\afo\ \Rightarrow\ \once\afo \]
The above semantics also validates the following proof rules:
\begin{description}
\item[Coinduction. ]
\[ \frac{\afo \Rightarrow\ \once{\afo}}{\neg \afo} \]
\item[Induction.] 
\[ \frac{\pastalways\afo \Rightarrow\ \afo}{\afo} \]
\end{description}
The definition of satisfaction of formulas by pomsets validates:
\[ \aPS \models \afo \Rightarrow\ \aPS \models \afo \wedge \pastalways\afo \]



We next state a composition result in the style of Abadi and Lamport~\cite{Abadi:1993:CS:151646.151649}.  Our statement and proof is intentionally less general to focus on the underlying ideas in a setting that eschews circularity.    We view this compositiona result as capturing key aspects of no-ThinAirRead, as will become clearer in the examples below.

The statement of the theorem requires us to incorporate environment assumptions.  
\begin{definition}
Let $\afo \in \pLTL$.  Then, define:
\[ \mods{(\afo)} = \{ \aPS \mid \ \aPS \models \afo \} \]
\end{definition}
$ \mods{(\afo)}$ are the models of the formula $\afo$, i.e. the pomsets that satisfy the formula.    We say that $\afo$ is prefix closed, if $ \mods{(\afo)}$ is prefix-closed.

\begin{definition}
Let $\afo \in \pLTL$ be prefix-closed.  Let $ \bfo \in \pLTL$.  Then:
\[ \afo, \aPS \models \bfo  \mbox{ if } \mods{(\afo)} \parallel \aPS \models \bfo \]
\end{definition}
Now, we are ready to state the composition theorem.  
\begin{lemma}[Composition]
For any prefix-closed $\afo \in \pLTL$, for any prefix closed $\aPSS_1, \aPSS_2$, \[
\frac{\afo, \aPSS_1 \models\ \afo, \ \ \ \ \ \afo, \aPSS_2 \models\ \afo}{\aPSS_1 \parallel \aPSS_2 \models \afo}
\]
\end{lemma}
\begin{proof}(Sketch)
$\aPSS_1 \parallel \aPSS_2$ is prefix closed because $\aPSS_1,\aPSS_2$ and $ \mods{(\pastalways\afo)}$ are all prefix closed.  Proof proceeds by induction on prefixes of $\aPS \in \aPSS_1 \parallel \aPSS_2$.    

The case for empty prefix  follows from assumption that  $\afo$ is prefix closed.  

For the inductive case, consider $\aPS \in \aPSS_1 \parallel \aPSS_2$, i.e. $\aPS = \aPS_1 \parallel \aPS_2$ where $\aPS_i \in \aPSS_i$.  Consider a prefix (say $\aPS'$) got by deleting a maximal element, say $\aEv$, of $\aPS$.  There are two cases depending on whether $\aEv$ comes from $\aPS_1$ or $\aPS_2$.  In the case when $\aEv$ comes from $\aPS_1$, since $\aPS_2$ is a prefix of $\aPS'$ and $\aPS' \models \afo$ by induction hypothesis, we deduce that  $\aPS_2 \models \afo$.     Thus, $\aPS_2 \in \mods{(\afo)}$.  Since $\aPS_1 \in \aPSS_1$, assumption $\afo, \aPSS_1 \models\ \afo$,  we deduce that $\aPS_1 \parallel \aPS_2 \models \afo$.   
\end{proof}

\endinput

Closed at x:
\begin{verbatim}
  Define closed(x) = (Rxv => F(Wxv))
\end{verbatim}
Local declaration [sound proof rule]:
\begin{verbatim}
  x notin phi
  Es |= closed(x) => phi
  ----------------------
  var x; Es |= phi
\end{verbatim}
Conditional TAR example:
\begin{verbatim}
  var x,y,z;
  y:=0; y:=x  ||  x:=0; if(~z){x:=1}else{x:=y;a:=y}  ||  z:=0; z:=1
\end{verbatim}
\begin{verbatim}
Goal: Es |= ~ F(Wa1)   [impossible to write a=1]
\end{verbatim}
Invariant:
\begin{verbatim}
     F(Wy1) => F(Rx1)
  /\ F(Wa1) => F(Ry1) /\ G(Wx1 => F(Ry1))
\end{verbatim}
Closing y:
\begin{verbatim}
  F(Wa1) => F(Rx1) /\ G(Wx1 => F(Rx1))
\end{verbatim}
Closing x:
\begin{verbatim}
  F(Wa1) => F(Wx1) /\ G(Wx1 => F(Wx1))
\end{verbatim}
Using coinduction for F:  
\begin{verbatim}
  F(Wa1) => F(Wx1) /\ G(~ Wx1)
\end{verbatim}
Simplifying:  
\begin{verbatim}
  F(Wa1) => false
\end{verbatim}