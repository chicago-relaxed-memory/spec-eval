\section{Conclusions and future work}

In this paper, we have presented a model of speculative evaluation, and
showed that it captures non-trivial properties of speculations produced
by hardware, compiler optimizations, and transactions. These properties
include information flow attacks: in the case of hardware and transactions
this is modelling known attacks~\cite{DBLP:journals/corr/abs-1801-01203,DBLP:conf/uss/DisselkoenKPT17},
but in the case of compiler optimizations the attacks are new, and were
discovered as a direct result of developing the model. We have experimentally
validated that the attacks can be carried out against \verb|gcc| and \verb|clang|,
though only against secrets known at compile time.

The model of relaxed memory used in this paper is deliberately
simplified, compared for example to
C11~\cite{Boehm:2008:FCC:1375581.1375591,Batty:2011:MCC:1926385.1926394}.
In particular our model of reads-from is strong, and could be weakened
by replacing the requirement $\bEv<\aEv$ in Definition~\ref{def:rf}
by $\aEv\ltN\bEv$. It remains to be seen how this impacts the model,
in particular the logical formulation of $\aLoc$-closure in
\S\ref{sec:logic} as
$((\DR{\aLoc}{\aVal}) \Rightarrow \once(\DW{\aLoc}{\aVal}))$
would no longer be sound.
The model is also not considering coherence, though we speculate it
can be added by requiring that for each $\aLoc$, $\ltN$ form a total
order when restricted to events that write to $\aLoc$.

The design space for transactions is very rich~\cite{DBLP:journals/pacmpl/DongolJR18}.
We have only presented one design choice, and it remains to be seen how other
design choices could be adopted. For example we have chosen to pun between
commits which are aborted due to transaction failure, and ones which are aborted
for other reasons such as failed speculation.

% \todo{Integrate this example on information flow?}

% Let {\tt P(hi)} be a function with domain $\{0, . . . ,n \}$  and codomain $\{1, . . . ,n \}$. Our aim is to write a
% program that tests whether there is information flow from input {\tt  hi} to the return value {\tt lo}. Consider:
% \begin{alltt}
%  s:=y; if (s!=0) { x=P(s); z:=1; } else { x=P(0); }
% \end{alltt}
% When there is a dependency of the output on the input, there are at least two different possible
% assignments to {\tt z}. In this case, the only possible execution, as validated by our model, of the above
% program is the SC execution that reads {\tt m} as $0$ and leaves {\tt noflow} untouched.
% When there is no dependency from input to output the value of {\tt z} is the same, say {\tt k} in all cases,
% non-zero by assumption. In this case, the compiler can hoist the assignment of  to  {\tt z} outside the
% conditional and swap with the independent asignment to {\tt hi}, 
% thus rewriting T2 to:
% \begin{alltt}
% T2: z=k; s=m; if (s!=0) { noflow=true; }
% \end{alltt}
% In this case, the program has an execution, validated by our model, that sets {\tt noflow} to {\tt true}.

One interesting feature of this model is that (in the language
of~\cite{Pichon-Pharabod:2016:CSR:2837614.2837616}) it is a
\emph{per-candidate execution model}, in that the correctness of an
execution only requires looking at that one execution, not at
others. This is explicit in memory models such
as~\cite{Jagadeesan:2010:GOS:2175486.2175503,Kang:2017:PSR:3009837.3009850} in which
``alternative futures'' are explored, in a style reminiscent of
Abramsky's bisimulation as a testing equivalence~\cite{ABRAMSKY1987225}. Models of
information flow are similar, in that they require comparing different
runs to test for the presence of dependencies. In contrast, the model
presented here explicitly captures dependency in the pomset order, and
models multiple runs by giving the semantics of $\IF$ in terms of a
concurrent semantics of both branches.
In the parlance
of information flow, the humble conditional suffices to construct a composition operator to detect information flow  in the presence of speculation.
