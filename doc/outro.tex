\section{Conclusions and future work}

One oddity of the model is that
$\sem{r \GETS x\SEMI y \GETS r\SEMI\SKIP}$ includes:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx0}{\DR{x}{0}}{}
  \nonevent{wy1}{\DW{y}{1}}{right=of rx0}
  \po{rx0}{wy1}
\end{tikzpicture}\]
where the write action guessed its value incorrectly, and therefore has
precondition $0=1$.   This form of speculative
execution does not appear to be used in practice. In order to disallow it,
one could change the semantics of $\SKIP$ to introduce a tick 
action denoting successful completion of the thread and only consider
executions in which the precondition of every tick action is satisfiable.  We
leave the elaboration of this idea as future work.

\todo{Comment on the following:}
\begin{itemize}
\item coherence = per location total order on $\not<$

\item Validation of write removal requires some tricks to ensure that thread
  does not rf its own write

\item Definition of rf can use $\not<$ in first clause, rather than $\leq$.
  We chose the stronger definition because it makes some of the examples
  simpler: in particular, the example motivating rf needs a volatile in the
  other thread if you don't have rf-implies-hb.

  Old text: The notion rf-pomset is sufficient to capture hardware models and
  release/acquire access in C++, where reads-from implies happens-before
  \cite{alglave}.  To model C++ relaxed access, it would be necessary to use
  a more general notion of rf-pomset, where $(\bEv,\aLoc,\aEv) \in \RF$ does
  not necessarily imply $\bEv < \aEv$, instead requiring that
  $(\mathord< \cup \mathord\RF)$ be acyclic.

\item The design space for transactions is very rich
  \cite{DBLP:journals/pacmpl/DongolJR18}.  We have only presented one option.
  we pun between abort and false commit
  
\end{itemize}



% \todo{Integrate this example on information flow?}

% Let {\tt P(hi)} be a function with domain $\{0, . . . ,n \}$  and codomain $\{1, . . . ,n \}$. Our aim is to write a
% program that tests whether there is information flow from input {\tt  hi} to the return value {\tt lo}. Consider:
% \begin{alltt}
%  s:=y; if (s!=0) { x=P(s); z:=1; } else { x=P(0); }
% \end{alltt}
% When there is a dependency of the output on the input, there are at least two different possible
% assignments to {\tt z}. In this case, the only possible execution, as validated by our model, of the above
% program is the SC execution that reads {\tt m} as $0$ and leaves {\tt noflow} untouched.
% When there is no dependency from input to output the value of {\tt z} is the same, say {\tt k} in all cases,
% non-zero by assumption. In this case, the compiler can hoist the assignment of  to  {\tt z} outside the
% conditional and swap with the independent asignment to {\tt hi}, 
% thus rewriting T2 to:
% \begin{alltt}
% T2: z=k; s=m; if (s!=0) { noflow=true; }
% \end{alltt}
% In this case, the program has an execution, validated by our model, that sets {\tt noflow} to {\tt true}.

% In the parlance
% of information flow, the humble conditional suffices to construct a composition operator to detect information flow  in the presence of speculation.
