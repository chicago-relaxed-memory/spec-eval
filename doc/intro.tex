\newcommand{\LOW}{{\mbox {\texttt LOW}}}
\newcommand{\HIGH}{{\mbox {\texttt HIGH}}}

\section{Introduction}

This paper studies information flow caused by speculation mechanisms
in hardware and software.

Information flow provides a formal
foundation for end-to-end security.  Informally, a program is secure
if there is no observable dependency of low-security outputs on high-security inputs.
The precise formalization of this intuitive idea has been the topic of
extensive research \cite{Sabelfeld:2006:LIS:2312191.2314769}, encompassing a variety of language
features such as non-determinism~\cite{Wittbold1990InformationFI},
concurrency~\cite{Smith:1998:SIF:268946.268975}, reactivity~\cite{O'Neill:2006:ISI:1155442.1155677}, and
probability~\cite{Gray:1992:TMF:2699806.2699811}. The static and dynamic enforcement
of these definitions in general purpose languages~\cite{myers-popl99} has % also
% been studied extensively and has
influenced language design and implementation.

A key parameter in defining information flow is the \emph{observational power} of the attacker model. Whereas the classical
input-output behavior is often an adequate foundation,
it has long been known~\cite{Lampson:1973:NCP:362375.362389,Biswas:2017:STC:3058791.3023872} that side-channels that leak
information arise from other observables such as execution time and
power consumption.
Recently, the Spectre family of attacks~\cite{DBLP:journals/corr/abs-1801-01203} has
shown that speculative evaluation, in conjunction with cache-timing side-channels,
allows adversaries to bypass dynamic security checks.



%In this paper, we develop a formal model of such attacks.

There are several sources of speculative evaluation.  Each of these is
designed so that failed speculation does not affect the input-output behavior
of the program, but may affect other observable behavior, opening an opportunity
for side-channels:
\begin{itemize}
\item Hardware micro-architectures make use of
  speculation, using \emph{branch prediction}
  to speculatively execute the result of
  a conditional jump or indirect jump instruction.
  These are intended to be micro-architectural optimizations
  that are not visible at the architectural level, but
  the Spectre family of
  attacks~\cite{DBLP:journals/corr/abs-1801-01203} have shown how to exploit
  cache timing to create side channels.
  %% This means,
  %% for example, that a single execution of
  %% $(\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI)$ may depend on both $\aCmd$ and
  %% $\bCmd$.  This differs from the standard semantics of the conditional, in
  %% which executions of $\aCmd$ and $\bCmd$ are disjoint.
\item Some modern microprocessors also support transactional
  memory~\cite{ChongSW18}, where aborted transactions are meant to be
  unobservable.  Transactions may abort due to cache conflicts, however, and
  this mechanism can be exploited to improve the efficacy of Spectre-like
  attacks~\cite{DBLP:conf/uss/DisselkoenKPT17}.
\item Relaxed memory models
  \cite{Manson:2005:JMM:1047659.1040336,Boehm:2008:FCC:1375581.1375591,DBLP:conf/popl/ZhaoNMZ12}
  allow for the observation of control and data dependencies. This creates an
  opportunity for information flows caused by optimizing compilers, whose
  behavior is driven by dependency analysis.
  %% For example,
  %% $(\IF(\aReg)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS1 \FI)$ can be optimized to
  %% $(\aLoc\GETS1)$, whereas
  %% $(\IF(\aReg)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS2 \FI)$ cannot be so
  %% optimized.  
\end{itemize}
We develop a model to capture such attacks.  From a hardware perspective, ~\citet{Chien:2018} argues that  the Spectre family of attacks forces one to
``extend the functional specification of the architecture to include its detailed performance''.    In analogy, our model intends to ``extend the functional specification of a programming language  to include speculation''.
%% This line of research was initiated by~\citet{Zhang:2012:LCM:2345156.2254078}.  
%% Whereas they explore static annotations to address side channels in the context of hardware description languages, we explore a model of programs
%% that captures enough detail to reveal and analyze the presence of side
%% channels revealed by speculative execution.  
%

The information flow literature, with the notable exceptions of ~\cite{Zhang:2012:LCM:2345156.2254078,hyperflow},  does not address observables such as execution time and  power consumption.  For example, the well-known Smith-Volpano type system (which guarantees noninterference) will allow the \textsc{Prime+Abort} attacks~\cite{DBLP:conf/uss/DisselkoenKPT17}.     While~\cite{6957104,Vaughan:2012:SIF} analyze  information flow arising from thread-specific speculation in hardware relaxed memory~\cite{SparcV9}, they do not address branch-speculation.  

The model of this paper is designed to capture information flow attacks on speculative evaluation,
but in contrast to existing work such as~\cite{Zhang:2012:LCM:2345156.2254078,hyperflow}, we do \emph{not} model micro-architectural
details such as caches or timing. We try to give as simple a model as possible, while still
capturing shared-memory concurrency and speculation.

Our model is based on \emph{partially ordered multisets}~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600}
(``pomsets''), whose labels are given by read and write actions. These can be
visualized as a graph where the edges indicate dependencies, for example
$(\aReg\GETS\aLoc\SEMI \bLoc\GETS1\SEMI \cLoc\GETS\aReg+1)$
has an execution modeled by the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \event{wy1}{\DW{\bLoc}{1}}{right=of rx1}
  \event{wz2}{\DW{\cLoc}{2}}{right=of wy1}
  \po[out=25,in=155]{rx1}{wz2}
\end{tikzpicture}\]
The edge from $(\DR{\aLoc}{1})$ to $(\DW{\cLoc}{2})$ indicates a
data dependency. Since there is no dependency between
$(\DW{\bLoc}{1})$ and $(\DW{\cLoc}{2})$, the write actions may
take place in either order, becuase of optimizations in
hardware (for example caching) or the compiler (for example
instruction reordering).

The novel aspect of the model is that events have
\emph{preconditions} which may be false. These are used in giving the
semantics of conditionals, for example the program
$(\IF(\aLoc)\THEN \bLoc\GETS1\SEMI\cLoc\GETS1 \ELSE \bLoc\GETS2\SEMI\cLoc\GETS1\FI)$
has an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \event{wy1}{\DW{\bLoc}{1}}{right=of rx1}
  \nonevent{wy2}{\DW{\bLoc}{2}}{below=of wy1}
  \event{wz1}{\DW{\cLoc}{1}}{right=of wy1}
  \po{rx1}{wy1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
The edges from $(\DR{\aLoc}{1})$ to $(\DW{\bLoc}{1})$ and
$(\DW{\bLoc}{2})$ indicate control dependencies. The presence of
a crossed out $(\DW{\bLoc}{2})$ indicates an event with an unsatisfiable precondition,
modelling an unsuccessful speculation.
Since the $(\DW{\cLoc}{1})$ action is performed on both branches of the conditional,
there is no control dependency from $(\DR{\aLoc}{1})$.  Indeed, from an information-flow perspective,
this refined treatment of dependencies in conditionals identifies a novel distinguishing feature of our model, namely that the traditional conditional is a self-composition operator in the sense of~\cite{Barthe:2004:SIF:1009380.1009669}.  

There do exist models of programs which include speculation, notably
the Java Memory Model~\cite{Manson:2005:JMM:1047659.1040336}, and the
generative~\cite{Jagadeesan:2010:GOS:2175486.2175503} and
promising~\cite{DBLP:conf/popl/KangHLVD17} operational semantics for
relaxed memory.  In all of these models a valid execution is defined
with reference to other possible executions of the program. These
models are not, however, designed for modelling Spectre-style attacks
on speculation. For example all of these models will consider the
straight-line code:
\[
  r\GETS x\SEMI s\GETS\SEC \SEMI
  a[r]\GETS 1
\]
to be the same as the conditional:
\[\begin{array}{ll}
  r\GETS x\SEMI s\GETS\SEC \SEMI \\[\jot]
  \IF(r\EQ s) \THEN a[s]\GETS 1 \ELSE a[r]\GETS 1 \FI
\end{array}\]
An attacker can mount a Spectre-style attack on the
conditional code, for example by setting $x$ to be~$0$,
flushing the cache,
executing the program, then using timing effects to
determine if $a[1]$ is in the cache. If it is, then $\SEC$
must have been~$1$. This attack is not possible against
the straight-line code, and so any model trying to
capture Spectre must distinguish them.

If $r,x,a$ (resp. $\SEC,s$) are at security level $\LOW$ (resp. security level $\HIGH$), there is no information flow from $\HIGH$ to $\LOW$ in either of the above programs in the usual approaches.   Thus, the only existing models of non-interference which capture this
information flow are ones such as~\cite{Zhang:2012:LCM:2345156.2254078} which model micro-architectural features such as caching and timing.  

In our model, these programs are not equated, since the conditional code has the execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx0}{\DR{\aLoc}{0}}{}
  \event{rs1}{\DR{\SEC}{1}}{below=of rx0}
  \event{wa01}{\DW{a[0]}{1}}{right=3em of rx0}
  \nonevent{wa11}{\DW{a[1]}{1}}{below=of wa01}
  \po{rx0}{wa01}
  \po{rs1}{wa01}
  \po{rx0}{wa11}
  \po{rs1}{wa11}
\end{tikzpicture}\]
which is not matched in the straight-line code.  Thus, ordinary compiler optimizations can
violate intuitively expected informal information flow guarantees, resulting in information flows that might even be observable without timers.


The model in this paper leads to new attacks on optimizing
compilers~(\S\ref{sec:info-flow-attack} and~\S\ref{sec:dse}) which
were discovered as a consequence of building the model. A natural
question is whether these attacks are an artefact of the model, or if
they can be mounted in practice? We mounted the attacks on gcc and
clang, where they succeeded in leaking a $\SEC$ as long as the secret
was a constant known at compile time. By itself this is not too
worrying, since secrets are not normally static constants. If the same
attacks could be mounted against Just-In-Time~(JIT) compilers, this
is potentially significant, as secrets are often known at JIT-compile
time. Fortunately, our attempts to mount the attacks against SpiderMonkey,
V8 and HotSpot did not succeed.

The novel contributions of this paper are:
\begin{itemize}

\item a compositional model of program execution that includes speculation (\S\ref{sec:model}),

\item examples showing how the model can be applied,
  including existing information flow attacks on
  hardware and transactional memory, and new attacks on optimizing compilers (\S\ref{sec:examples}), and

\item experimental evidence about how practical it is to mount
  the new class of attacks (\S\ref{sec:experiments}).

\end{itemize}
Readers who wish to focus on the impact of the model can skip past \S\ref{sec:model}
on first reading, and refer back to it when needed.
