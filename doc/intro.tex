\section{Introduction}

This paper studies information flow caused by speculation mechanisms
in hardware and software.

Information flow provides a formal
foundation for end-to-end security.  Informally, a program is secure
if there is no observable dependency of low-security observables on high-security inputs.
The precise formalization of this intuitive idea has been the topic of
extensive research \cite{Sabelfeld:2006:LIS:2312191.2314769}, encompassing a variety of language
features such as non-determinism~\cite{Wittbold1990InformationFI},
concurrency~\cite{Smith:1998:SIF:268946.268975}, reactivity~\cite{O'Neill:2006:ISI:1155442.1155677}, and
probability~\cite{Gray:1992:TMF:2699806.2699811}. The static and dynamic enforcement
of these definitions in general purpose languages~\cite{myers-popl99} has % also
% been studied extensively and has
influenced language design and implementation.

A key parameter in defining information flow is the \emph{observational power} of the attacker model. Whereas the classical
input-output behavior is often an adequate foundation,
it has long been known~\cite{Lampson:1973:NCP:362375.362389,Biswas:2017:STC:3058791.3023872} that side-channels that leak
information arise from other observables such as execution time and
power consumption.
Recently, the Spectre family of attacks~\cite{DBLP:journals/corr/abs-1801-01203} has
shown that side-channels arise from speculative evaluation.
%In this paper, we develop a formal model of such attacks.

There are several sources of speculative evaluation.  Each of these is
designed so that failed speculation does not affect the input-output behavior
of the program, but may affect the behavior, opening an opportunity
for a side-channel attack:
\begin{itemize}
\item To facilitate pipelining, microprocessors use heuristics to predict the
  outcome of instructions. Execution proceeds until these predictions can be
  validated, at which point the relevant instructions are either committed or
  aborted.  The Spectre family of
  attacks~\cite{DBLP:journals/corr/abs-1801-01203} exploit the timing
  differences between successful and unsuccessful predictions.  This means,
  for example, that a single execution of
  $(\IF(\aExp)\THEN \aCmd \ELSE \bCmd \FI)$ may depend on both $\aCmd$ and
  $\bCmd$.  This differs from the standard semantics of the conditional, in
  which executions of $\aCmd$ and $\bCmd$ are disjoint.
\item Some modern microprocessors also support transactional
  memory~\cite{ChongSW18}, where aborted transactions are meant to be
  unobservable.  Transactions may abort due to cache conflicts, however, and
  this mechanism can be exploited to improve the efficacy of Spectre-like
  attacks~\cite{DBLP:conf/uss/DisselkoenKPT17}.
\item Relaxed memory models
  \cite{Manson:2005:JMM:1047659.1040336,Boehm:2008:FCC:1375581.1375591,DBLP:conf/popl/ZhaoNMZ12}
  allow for the observation of control and data dependencies. This creates an
  opportunity for information flows caused by optimizing compilers, whose
  behavior is driven by dependency analysis.  For example,
  $(\IF(\aReg)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS1 \FI)$ can be optimized to
  $(\aLoc\GETS1)$, whereas
  $(\IF(\aReg)\THEN \aLoc\GETS1 \ELSE \aLoc\GETS2 \FI)$ cannot be so
  optimized.  
\end{itemize}

We develop a model to capture such attacks.
%% This line of research was initiated by~\citet{Zhang:2012:LCM:2345156.2254078}.  
%% Whereas they explore static annotations to address side channels in the context of hardware description languages, we explore a model of programs
%% that captures enough detail to reveal and analyze the presence of side
%% channels revealed by speculative execution.  
%
Our model is based on \emph{partially ordered multisets}~\cite{GISCHER1988199,Plotkin:1997:TSP:266557.266600}
(``pomsets''), whose labels are given by read and write actions. These can be
visualized as a graph where the edges indicate dependencies, for example
$(\aReg\GETS\aLoc\SEMI \bLoc\GETS1\SEMI \cLoc\GETS\aReg+1)$
has an execution modeled by the pomset:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \event{wy1}{\DW{\bLoc}{1}}{right=of rx1}
  \event{wz2}{\DW{\cLoc}{2}}{right=of wy1}
  \po[out=25,in=155]{rx1}{wz2}
\end{tikzpicture}\]
The edge from $(\DR{\aLoc}{1})$ to $(\DW{\cLoc}{2})$ indicates a
data dependency. The novel aspect of the model is that events have
\emph{preconditions} which may be false. These are used in giving the
semantics of conditionals, for example
$(\IF(\aLoc)\THEN \bLoc\GETS1\SEMI\cLoc\GETS1 \ELSE \bLoc\GETS2\SEMI\cLoc\GETS1\FI)$
has an execution:
\[\begin{tikzpicture}[node distance=1em]
  \event{rx1}{\DR{\aLoc}{1}}{}
  \event{wy1}{\DW{\bLoc}{1}}{right=of rx1}
  \nonevent{wy2}{\DW{\bLoc}{2}}{below=of wy1}
  \event{wz1}{\DW{\cLoc}{1}}{right=of wy1}
  \po{rx1}{wy1}
  \po{rx1}{wy2}
\end{tikzpicture}\]
The edges from $(\DR{\aLoc}{1})$ to $(\DW{\bLoc}{1})$ and
$(\DW{\bLoc}{2})$ indicate control dependencies. The presence of
a crossed out $(\DW{\bLoc}{2})$ indicates an event with an unsatisfiable precondition,

The novel contributions of this paper are:
\begin{itemize}

\item a model of program execution that includes speculation (\S\ref{sec:model}),

\item examples showing how the model can be applied,
  including information flow attacks on
  hardware, optimizing compilers, and transactional memory (\S\ref{sec:examples}),

\item a new class of attacks targeting optimizing compilers and relaxed memory
  (\S\ref{sec:info-flow-attack} and \S\ref{sec:dse}),

\item experimental evidence about how practical it is to mount
  the new class of attacks (\S\ref{sec:experiments}), and

\item a temporal logic which supports compositional proof (\S\ref{sec:logic}).

\end{itemize}
Readers who wish to focus on the impact of the model can skip past \S\ref{sec:model}
on first reading, and refer back to it when needed.
